/**************************************************
porcupine.js Folder Gather/Compiler

Built on {date} 
This file is automatically generated from source bundle
Single and multi-line comments have been removed. 

Copyright 2011-2012 Mindary AB 
Visit our website at www.mindary.se for more projects
Or contact us at contact@mindary.se 

{license}
*************************************************/


var porcupine = { version : '0.0.1' };


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/core/log.js: */

/***************************************	
*	public
*	--------
*	Prettyprints console logs w/ time	
*
****************************************/

porcupine.log = function() { porcupine._log_core(console.log, arguments ); };
porcupine.warn = function() { porcupine._log_core(console.warn, arguments ); };
porcupine.debug = function() { porcupine._log_core(console.debug, arguments ); };
porcupine.error = function() { porcupine._log_core(console.error, arguments ); };


/***************************************	
*	internal
*	--------
*   the functions used by core/instance
*   to output to console
*
****************************************/
porcupine._log_core = function(f,args)
{
	porcupine.log_instance( {id : "CORE" }, f, args );
};

porcupine.log_instance = function( instance,f,args ) 
{
	var d      = new Date();
	var hours  = d.getHours();
	var minutes = d.getMinutes();
	var seconds = d.getSeconds();
	var prefix = "[{0}:{1}:{2}][{3}]".format(hours,minutes,seconds,instance.id);
	var arglist = args_to_list(args);

	arglist.unshift(prefix);
	f.apply(console,arglist);
};


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/lib/gl-matrix.js: */

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations for WebGL
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 1.3.6
 */

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Updated to use a modification of the "returnExportsGlobal" pattern from https://github.com/umdjs/umd

(function (root, factory) {
    if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory(global);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function () {
            return factory(root);
        });
    } else {
        // Browser globals
        factory(root);
    }
}(this, function (root) {
    "use strict";

    // Tweak to your liking
    var FLOAT_EPSILON = 0.000001;

    var glMath = {};
    (function() {
        if (typeof(Float32Array) != 'undefined') {
            var y = new Float32Array(1);
            var i = new Int32Array(y.buffer);

            /**
             * Fast way to calculate the inverse square root,
             * see http://jsperf.com/inverse-square-root/5
             *
             * If typed arrays are not available, a slower
             * implementation will be used.
             *
             * @param {Number} number the number
             * @returns {Number} Inverse square root
             */
            glMath.invsqrt = function(number) {
              var x2 = number * 0.5;
              y[0] = number;
              var threehalfs = 1.5;

              i[0] = 0x5f3759df - (i[0] >> 1);

              var number2 = y[0];

              return number2 * (threehalfs - (x2 * number2 * number2));
            };
        } else {
            glMath.invsqrt = function(number) { return 1.0 / Math.sqrt(number); };
        }
    })();

    /**
     * @class System-specific optimal array type
     * @name MatrixArray
     */
    var MatrixArray = null;
    
    // explicitly sets and returns the type of array to use within glMatrix
    function setMatrixArrayType(type) {
        MatrixArray = type;
        return MatrixArray;
    }

    // auto-detects and returns the best type of array to use within glMatrix, falling
    // back to Array if typed arrays are unsupported
    function determineMatrixArrayType() {
        MatrixArray = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
        return MatrixArray;
    }
    
    determineMatrixArrayType();

    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};
     
    /**
     * Creates a new instance of a vec3 using the default array type
     * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
     *
     * @param {vec3} [vec] vec3 containing values to initialize with
     *
     * @returns {vec3} New vec3
     */
    vec3.create = function (vec) {
        var dest = new MatrixArray(3);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
        } else {
            dest[0] = dest[1] = dest[2] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a vec3, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value

     * @returns {vec3} New vec3
     */
    vec3.createFrom = function (x, y, z) {
        var dest = new MatrixArray(3);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;

        return dest;
    };

    /**
     * Copies the values of one vec3 to another
     *
     * @param {vec3} vec vec3 containing values to copy
     * @param {vec3} dest vec3 receiving copied values
     *
     * @returns {vec3} dest
     */
    vec3.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];

        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec3} a First vector
     * @param {vec3} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    vec3.compare = function (a, b) {
        return (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON
        );
    };

    /**
     * Performs a vector addition
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.add = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] += vec2[0];
            vec[1] += vec2[1];
            vec[2] += vec2[2];
            return vec;
        }

        dest[0] = vec[0] + vec2[0];
        dest[1] = vec[1] + vec2[1];
        dest[2] = vec[2] + vec2[2];
        return dest;
    };

    /**
     * Performs a vector subtraction
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.subtract = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] -= vec2[0];
            vec[1] -= vec2[1];
            vec[2] -= vec2[2];
            return vec;
        }

        dest[0] = vec[0] - vec2[0];
        dest[1] = vec[1] - vec2[1];
        dest[2] = vec[2] - vec2[2];
        return dest;
    };

    /**
     * Performs a vector multiplication
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.multiply = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] *= vec2[0];
            vec[1] *= vec2[1];
            vec[2] *= vec2[2];
            return vec;
        }

        dest[0] = vec[0] * vec2[0];
        dest[1] = vec[1] * vec2[1];
        dest[2] = vec[2] * vec2[2];
        return dest;
    };

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} vec vec3 to negate
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.negate = function (vec, dest) {
        if (!dest) { dest = vec; }

        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        return dest;
    };

    /**
     * Multiplies the components of a vec3 by a scalar value
     *
     * @param {vec3} vec vec3 to scale
     * @param {number} val Value to scale by
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.scale = function (vec, val, dest) {
        if (!dest || vec === dest) {
            vec[0] *= val;
            vec[1] *= val;
            vec[2] *= val;
            return vec;
        }

        dest[0] = vec[0] * val;
        dest[1] = vec[1] * val;
        dest[2] = vec[2] * val;
        return dest;
    };

    /**
     * Generates a unit vector of the same direction as the provided vec3
     * If vector length is 0, returns [0, 0, 0]
     *
     * @param {vec3} vec vec3 to normalize
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.normalize = function (vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        } else if (len === 1) {
            dest[0] = x;
            dest[1] = y;
            dest[2] = z;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Generates the cross product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.cross = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    };

    /**
     * Caclulates the length of a vec3
     *
     * @param {vec3} vec vec3 to calculate length of
     *
     * @returns {number} Length of vec
     */
    vec3.length = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return Math.sqrt(x * x + y * y + z * z);
    };

    /**
     * Caclulates the squared length of a vec3
     *
     * @param {vec3} vec vec3 to calculate squared length of
     *
     * @returns {number} Squared Length of vec
     */
    vec3.squaredLength = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return x * x + y * y + z * z;
    };

    /**
     * Caclulates the dot product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     *
     * @returns {number} Dot product of vec and vec2
     */
    vec3.dot = function (vec, vec2) {
        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
    };

    /**
     * Generates a unit vector pointing from one vector to another
     *
     * @param {vec3} vec Origin vec3
     * @param {vec3} vec2 vec3 to point to
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.direction = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0] - vec2[0],
            y = vec[1] - vec2[1],
            z = vec[2] - vec2[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Performs a linear interpolation between two vec3
     *
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     * @param {number} lerp Interpolation amount between the two inputs
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.lerp = function (vec, vec2, lerp, dest) {
        if (!dest) { dest = vec; }

        dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
        dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
        dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec3
     *
     * Params:
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     *
     * @returns {number} Distance between vec and vec2
     */
    vec3.dist = function (vec, vec2) {
        var x = vec2[0] - vec[0],
            y = vec2[1] - vec[1],
            z = vec2[2] - vec[2];
            
        return Math.sqrt(x*x + y*y + z*z);
    };

    // Pre-allocated to prevent unecessary garbage collection
    var unprojectMat = null;
    var unprojectVec = new MatrixArray(4);
    /**
     * Projects the specified vec3 from screen space into object space
     * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
     *
     * @param {vec3} vec Screen-space vector to project
     * @param {mat4} view View matrix
     * @param {mat4} proj Projection matrix
     * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
     * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.unproject = function (vec, view, proj, viewport, dest) {
        if (!dest) { dest = vec; }

        if(!unprojectMat) {
            unprojectMat = mat4.create();
        }

        var m = unprojectMat;
        var v = unprojectVec;
        
        v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
        v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
        v[2] = 2.0 * vec[2] - 1.0;
        v[3] = 1.0;
        
        mat4.multiply(proj, view, m);
        if(!mat4.inverse(m)) { return null; }
        
        mat4.multiplyVec4(m, v);
        if(v[3] === 0.0) { return null; }

        dest[0] = v[0] / v[3];
        dest[1] = v[1] / v[3];
        dest[2] = v[2] / v[3];
        
        return dest;
    };

    var xUnitVec3 = vec3.createFrom(1,0,0);
    var yUnitVec3 = vec3.createFrom(0,1,0);
    var zUnitVec3 = vec3.createFrom(0,0,1);

    var tmpvec3 = vec3.create();
    /**
     * Generates a quaternion of rotation between two given normalized vectors
     *
     * @param {vec3} a Normalized source vector
     * @param {vec3} b Normalized target vector
     * @param {quat4} [dest] quat4 receiving operation result.
     *
     * @returns {quat4} dest if specified, a new quat4 otherwise
     */
    vec3.rotationTo = function (a, b, dest) {
        if (!dest) { dest = quat4.create(); }
        
        var d = vec3.dot(a, b);
        var axis = tmpvec3;
        if (d >= 1.0) {
            quat4.set(identityQuat4, dest);
        } else if (d < (0.000001 - 1.0)) {
            vec3.cross(xUnitVec3, a, axis);
            if (vec3.length(axis) < 0.000001)
                vec3.cross(yUnitVec3, a, axis);
            if (vec3.length(axis) < 0.000001)
                vec3.cross(zUnitVec3, a, axis);
            vec3.normalize(axis);
            quat4.fromAngleAxis(Math.PI, axis, dest);
        } else {
            var s = Math.sqrt((1.0 + d) * 2.0);
            var sInv = 1.0 / s;
            vec3.cross(a, b, axis);
            dest[0] = axis[0] * sInv;
            dest[1] = axis[1] * sInv;
            dest[2] = axis[2] * sInv;
            dest[3] = s * 0.5;
            quat4.normalize(dest);
        }
        if (dest[3] > 1.0) dest[3] = 1.0;
        else if (dest[3] < -1.0) dest[3] = -1.0;
        return dest;
    };

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec Vector to represent as a string
     *
     * @returns {string} String representation of vec
     */
    vec3.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
    };

    /**
     * @class 3x3 Matrix
     * @name mat3
     */
    var mat3 = {};

    /**
     * Creates a new instance of a mat3 using the default array type
     * Any javascript array-like object containing at least 9 numeric elements can serve as a mat3
     *
     * @param {mat3} [mat] mat3 containing values to initialize with
     *
     * @returns {mat3} New mat3
     */
    mat3.create = function (mat) {
        var dest = new MatrixArray(9);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
        } else {
            dest[0] = dest[1] =
            dest[2] = dest[3] =
            dest[4] = dest[5] =
            dest[6] = dest[7] =
            dest[8] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat3, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22

     * @returns {mat3} New mat3
     */
    mat3.createFrom = function (m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        var dest = new MatrixArray(9);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m02;
        dest[3] = m10;
        dest[4] = m11;
        dest[5] = m12;
        dest[6] = m20;
        dest[7] = m21;
        dest[8] = m22;

        return dest;
    };

    /**
     * Calculates the determinant of a mat3
     *
     * @param {mat3} mat mat3 to calculate determinant of
     *
     * @returns {Number} determinant of mat
     */
    mat3.determinant = function (mat) {
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[3], a11 = mat[4], a12 = mat[5],
            a20 = mat[6], a21 = mat[7], a22 = mat[8];

        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
    };

    /**
     * Calculates the inverse matrix of a mat3
     *
     * @param {mat3} mat mat3 to calculate inverse of
     * @param {mat3} [dest] mat3 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat3} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat3.inverse = function (mat, dest) {
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[3], a11 = mat[4], a12 = mat[5],
            a20 = mat[6], a21 = mat[7], a22 = mat[8],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) { return null; }
        id = 1 / d;

        if (!dest) { dest = mat3.create(); }

        dest[0] = b01 * id;
        dest[1] = (-a22 * a01 + a02 * a21) * id;
        dest[2] = (a12 * a01 - a02 * a11) * id;
        dest[3] = b11 * id;
        dest[4] = (a22 * a00 - a02 * a20) * id;
        dest[5] = (-a12 * a00 + a02 * a10) * id;
        dest[6] = b21 * id;
        dest[7] = (-a21 * a00 + a01 * a20) * id;
        dest[8] = (a11 * a00 - a01 * a10) * id;
        return dest;
    };
    
    /**
     * Performs a matrix multiplication
     *
     * @param {mat3} mat First operand
     * @param {mat3} mat2 Second operand
     * @param {mat3} [dest] mat3 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat3} dest if specified, mat otherwise
     */
    mat3.multiply = function (mat, mat2, dest) {
        if (!dest) { dest = mat; }
        

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[3], a11 = mat[4], a12 = mat[5],
            a20 = mat[6], a21 = mat[7], a22 = mat[8],

            b00 = mat2[0], b01 = mat2[1], b02 = mat2[2],
            b10 = mat2[3], b11 = mat2[4], b12 = mat2[5],
            b20 = mat2[6], b21 = mat2[7], b22 = mat2[8];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22;

        dest[3] = b10 * a00 + b11 * a10 + b12 * a20;
        dest[4] = b10 * a01 + b11 * a11 + b12 * a21;
        dest[5] = b10 * a02 + b11 * a12 + b12 * a22;

        dest[6] = b20 * a00 + b21 * a10 + b22 * a20;
        dest[7] = b20 * a01 + b21 * a11 + b22 * a21;
        dest[8] = b20 * a02 + b21 * a12 + b22 * a22;

        return dest;
    };

    /**
     * Transforms the vec2 according to the given mat3.
     *
     * @param {mat3} matrix mat3 to multiply against
     * @param {vec2} vec    the vector to multiply
     * @param {vec2} [dest] an optional receiving vector. If not given, vec is used.
     *
     * @returns {vec2} The multiplication result
     **/
    mat3.multiplyVec2 = function(matrix, vec, dest) {
      if (!dest) dest = vec;
      var x = vec[0], y = vec[1];
      dest[0] = x * matrix[0] + y * matrix[3] + matrix[6];
      dest[1] = x * matrix[1] + y * matrix[4] + matrix[7];
      return dest;
    };

    /**
     * Transforms the vec3 according to the given mat3
     *
     * @param {mat3} matrix mat3 to multiply against
     * @param {vec3} vec    the vector to multiply
     * @param {vec3} [dest] an optional receiving vector. If not given, vec is used.
     *
     * @returns {vec3} The multiplication result
     **/
    mat3.multiplyVec3 = function(matrix, vec, dest) {
      if (!dest) dest = vec;
      var x = vec[0], y = vec[1], z = vec[2];
      dest[0] = x * matrix[0] + y * matrix[3] + z * matrix[6];
      dest[1] = x * matrix[1] + y * matrix[4] + z * matrix[7];
      dest[2] = x * matrix[2] + y * matrix[5] + z * matrix[8];
      
      return dest;
    };

    /**
     * Copies the values of one mat3 to another
     *
     * @param {mat3} mat mat3 containing values to copy
     * @param {mat3} dest mat3 receiving copied values
     *
     * @returns {mat3} dest
     */
    mat3.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat3} a First matrix
     * @param {mat3} b Second matrix
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    mat3.compare = function (a, b) {
        return (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON &&
            Math.abs(a[4] - b[4]) < FLOAT_EPSILON &&
            Math.abs(a[5] - b[5]) < FLOAT_EPSILON &&
            Math.abs(a[6] - b[6]) < FLOAT_EPSILON &&
            Math.abs(a[7] - b[7]) < FLOAT_EPSILON &&
            Math.abs(a[8] - b[8]) < FLOAT_EPSILON
        );
    };

    /**
     * Sets a mat3 to an identity matrix
     *
     * @param {mat3} dest mat3 to set
     *
     * @returns dest if specified, otherwise a new mat3
     */
    mat3.identity = function (dest) {
        if (!dest) { dest = mat3.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 1;
        dest[5] = 0;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 1;
        return dest;
    };

    /**
     * Transposes a mat3 (flips the values over the diagonal)
     *
     * Params:
     * @param {mat3} mat mat3 to transpose
     * @param {mat3} [dest] mat3 receiving transposed values. If not specified result is written to mat
     *
     * @returns {mat3} dest is specified, mat otherwise
     */
    mat3.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2],
                a12 = mat[5];

            mat[1] = mat[3];
            mat[2] = mat[6];
            mat[3] = a01;
            mat[5] = mat[7];
            mat[6] = a02;
            mat[7] = a12;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[3];
        dest[2] = mat[6];
        dest[3] = mat[1];
        dest[4] = mat[4];
        dest[5] = mat[7];
        dest[6] = mat[2];
        dest[7] = mat[5];
        dest[8] = mat[8];
        return dest;
    };

    /**
     * Copies the elements of a mat3 into the upper 3x3 elements of a mat4
     *
     * @param {mat3} mat mat3 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat3.toMat4 = function (mat, dest) {
        if (!dest) { dest = mat4.create(); }

        dest[15] = 1;
        dest[14] = 0;
        dest[13] = 0;
        dest[12] = 0;

        dest[11] = 0;
        dest[10] = mat[8];
        dest[9] = mat[7];
        dest[8] = mat[6];

        dest[7] = 0;
        dest[6] = mat[5];
        dest[5] = mat[4];
        dest[4] = mat[3];

        dest[3] = 0;
        dest[2] = mat[2];
        dest[1] = mat[1];
        dest[0] = mat[0];

        return dest;
    };

    /**
     * Returns a string representation of a mat3
     *
     * @param {mat3} mat mat3 to represent as a string
     *
     * @param {string} String representation of mat
     */
    mat3.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] +
            ', ' + mat[3] + ', ' + mat[4] + ', ' + mat[5] +
            ', ' + mat[6] + ', ' + mat[7] + ', ' + mat[8] + ']';
    };

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new instance of a mat4 using the default array type
     * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
     *
     * @param {mat4} [mat] mat4 containing values to initialize with
     *
     * @returns {mat4} New mat4
     */
    mat4.create = function (mat) {
        var dest = new MatrixArray(16);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat4, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33

     * @returns {mat4} New mat4
     */
    mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var dest = new MatrixArray(16);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m02;
        dest[3] = m03;
        dest[4] = m10;
        dest[5] = m11;
        dest[6] = m12;
        dest[7] = m13;
        dest[8] = m20;
        dest[9] = m21;
        dest[10] = m22;
        dest[11] = m23;
        dest[12] = m30;
        dest[13] = m31;
        dest[14] = m32;
        dest[15] = m33;

        return dest;
    };

    /**
     * Copies the values of one mat4 to another
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} dest mat4 receiving copied values
     *
     * @returns {mat4} dest
     */
    mat4.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat4} a First matrix
     * @param {mat4} b Second matrix
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    mat4.compare = function (a, b) {
        return (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON &&
            Math.abs(a[4] - b[4]) < FLOAT_EPSILON &&
            Math.abs(a[5] - b[5]) < FLOAT_EPSILON &&
            Math.abs(a[6] - b[6]) < FLOAT_EPSILON &&
            Math.abs(a[7] - b[7]) < FLOAT_EPSILON &&
            Math.abs(a[8] - b[8]) < FLOAT_EPSILON &&
            Math.abs(a[9] - b[9]) < FLOAT_EPSILON &&
            Math.abs(a[10] - b[10]) < FLOAT_EPSILON &&
            Math.abs(a[11] - b[11]) < FLOAT_EPSILON &&
            Math.abs(a[12] - b[12]) < FLOAT_EPSILON &&
            Math.abs(a[13] - b[13]) < FLOAT_EPSILON &&
            Math.abs(a[14] - b[14]) < FLOAT_EPSILON &&
            Math.abs(a[15] - b[15]) < FLOAT_EPSILON
        );
    };

    /**
     * Sets a mat4 to an identity matrix
     *
     * @param {mat4} dest mat4 to set
     *
     * @returns {mat4} dest
     */
    mat4.identity = function (dest) {
        if (!dest) { dest = mat4.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 1;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = 1;
        dest[11] = 0;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;
        return dest;
    };

    /**
     * Transposes a mat4 (flips the values over the diagonal)
     *
     * @param {mat4} mat mat4 to transpose
     * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise
     */
    mat4.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2], a03 = mat[3],
                a12 = mat[6], a13 = mat[7],
                a23 = mat[11];

            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} mat mat4 to calculate determinant of
     *
     * @returns {number} determinant of mat
     */
    mat4.determinant = function (mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        return (a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
                a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
                a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
                a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
                a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
                a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33);
    };

    /**
     * Calculates the inverse matrix of a mat4
     *
     * @param {mat4} mat mat4 to calculate inverse of
     * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat4.inverse = function (mat, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

            d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
            invDet;

            // Calculate the determinant
            if (!d) { return null; }
            invDet = 1 / d;

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into another mat4
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest is specified, a new mat4 otherwise
     */
    mat4.toRotationMat = function (mat, dest) {
        if (!dest) { dest = mat4.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into a mat3
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat3} [dest] mat3 receiving copied values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise
     */
    mat4.toMat3 = function (mat, dest) {
        if (!dest) { dest = mat3.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[4];
        dest[4] = mat[5];
        dest[5] = mat[6];
        dest[6] = mat[8];
        dest[7] = mat[9];
        dest[8] = mat[10];

        return dest;
    };

    /**
     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
     * The resulting matrix is useful for calculating transformed normals
     *
     * Params:
     * @param {mat4} mat mat4 containing values to invert and copy
     * @param {mat3} [dest] mat3 receiving values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
     */
    mat4.toInverseMat3 = function (mat, dest) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[4], a11 = mat[5], a12 = mat[6],
            a20 = mat[8], a21 = mat[9], a22 = mat[10],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) { return null; }
        id = 1 / d;

        if (!dest) { dest = mat3.create(); }

        dest[0] = b01 * id;
        dest[1] = (-a22 * a01 + a02 * a21) * id;
        dest[2] = (a12 * a01 - a02 * a11) * id;
        dest[3] = b11 * id;
        dest[4] = (a22 * a00 - a02 * a20) * id;
        dest[5] = (-a12 * a00 + a02 * a10) * id;
        dest[6] = b21 * id;
        dest[7] = (-a21 * a00 + a01 * a20) * id;
        dest[8] = (a11 * a00 - a01 * a10) * id;

        return dest;
    };

    /**
     * Performs a matrix multiplication
     *
     * @param {mat4} mat First operand
     * @param {mat4} mat2 Second operand
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.multiply = function (mat, mat2, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[ 0], a01 = mat[ 1], a02 = mat[ 2], a03 = mat[3];
        var a10 = mat[ 4], a11 = mat[ 5], a12 = mat[ 6], a13 = mat[7];
        var a20 = mat[ 8], a21 = mat[ 9], a22 = mat[10], a23 = mat[11];
        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        // Cache only the current line of the second matrix
        var b0  = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];  
        dest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[4];
        b1 = mat2[5];
        b2 = mat2[6];
        b3 = mat2[7];
        dest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[8];
        b1 = mat2[9];
        b2 = mat2[10];
        b3 = mat2[11];
        dest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[12];
        b1 = mat2[13];
        b2 = mat2[14];
        b3 = mat2[15];
        dest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        return dest;
    };

    /**
     * Transforms a vec3 with the given matrix
     * 4th vector component is implicitly '1'
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    mat4.multiplyVec3 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

        return dest;
    };

    /**
     * Transforms a vec4 with the given matrix
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec4} vec vec4 to transform
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    mat4.multiplyVec4 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2], w = vec[3];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

        return dest;
    };

    /**
     * Translates a matrix by the given vector
     *
     * @param {mat4} mat mat4 to translate
     * @param {vec3} vec vec3 specifying the translation
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.translate = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2],
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23;

        if (!dest || mat === dest) {
            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
            return mat;
        }

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        dest[0] = a00; dest[1] = a01; dest[2] = a02; dest[3] = a03;
        dest[4] = a10; dest[5] = a11; dest[6] = a12; dest[7] = a13;
        dest[8] = a20; dest[9] = a21; dest[10] = a22; dest[11] = a23;

        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
        return dest;
    };

    /**
     * Scales a matrix by the given vector
     *
     * @param {mat4} mat mat4 to scale
     * @param {vec3} vec vec3 specifying the scale for each axis
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @param {mat4} dest if specified, mat otherwise
     */
    mat4.scale = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2];

        if (!dest || mat === dest) {
            mat[0] *= x;
            mat[1] *= x;
            mat[2] *= x;
            mat[3] *= x;
            mat[4] *= y;
            mat[5] *= y;
            mat[6] *= y;
            mat[7] *= y;
            mat[8] *= z;
            mat[9] *= z;
            mat[10] *= z;
            mat[11] *= z;
            return mat;
        }

        dest[0] = mat[0] * x;
        dest[1] = mat[1] * x;
        dest[2] = mat[2] * x;
        dest[3] = mat[3] * x;
        dest[4] = mat[4] * y;
        dest[5] = mat[5] * y;
        dest[6] = mat[6] * y;
        dest[7] = mat[7] * y;
        dest[8] = mat[8] * z;
        dest[9] = mat[9] * z;
        dest[10] = mat[10] * z;
        dest[11] = mat[11] * z;
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the specified axis
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {vec3} axis vec3 representing the axis to rotate around
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotate = function (mat, angle, axis, dest) {
        var x = axis[0], y = axis[1], z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s, c, t,
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23,
            b00, b01, b02,
            b10, b11, b12,
            b20, b21, b22;

        if (!len) { return null; }
        if (len !== 1) {
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
        }

        s = Math.sin(angle);
        c = Math.cos(angle);
        t = 1 - c;

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
        b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
        b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform rotation-specific matrix multiplication
        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateX = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[4] = a10 * c + a20 * s;
        dest[5] = a11 * c + a21 * s;
        dest[6] = a12 * c + a22 * s;
        dest[7] = a13 * c + a23 * s;

        dest[8] = a10 * -s + a20 * c;
        dest[9] = a11 * -s + a21 * c;
        dest[10] = a12 * -s + a22 * c;
        dest[11] = a13 * -s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateY = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a20 * -s;
        dest[1] = a01 * c + a21 * -s;
        dest[2] = a02 * c + a22 * -s;
        dest[3] = a03 * c + a23 * -s;

        dest[8] = a00 * s + a20 * c;
        dest[9] = a01 * s + a21 * c;
        dest[10] = a02 * s + a22 * c;
        dest[11] = a03 * s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateZ = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a10 * s;
        dest[1] = a01 * c + a11 * s;
        dest[2] = a02 * c + a12 * s;
        dest[3] = a03 * c + a13 * s;

        dest[4] = a00 * -s + a10 * c;
        dest[5] = a01 * -s + a11 * c;
        dest[6] = a02 * -s + a12 * c;
        dest[7] = a03 * -s + a13 * c;

        return dest;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.frustum = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.perspective = function (fovy, aspect, near, far, dest) {
        var top = near * Math.tan(fovy * Math.PI / 360.0),
            right = top * aspect;
        return mat4.frustum(-right, right, -top, top, near, far, dest);
    };

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.ortho = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = 2 / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 2 / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = -2 / fn;
        dest[11] = 0;
        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1;
        return dest;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing "up"
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.lookAt = function (eye, center, up, dest) {
        if (!dest) { dest = mat4.create(); }

        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (eyex === centerx && eyey === centery && eyez === centerz) {
            return mat4.identity(dest);
        }

        //vec3.direction(eye, center, z);
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        dest[15] = 1;

        return dest;
    };

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {quat4} quat Rotation quaternion
     * @param {vec3} vec Translation vector
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.fromRotationTranslation = function (quat, vec, dest) {
        if (!dest) { dest = mat4.create(); }

        // Quaternion math
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;
        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;
        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;
        dest[12] = vec[0];
        dest[13] = vec[1];
        dest[14] = vec[2];
        dest[15] = 1;
        
        return dest;
    };

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat mat4 to represent as a string
     *
     * @returns {string} String representation of mat
     */
    mat4.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
            ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
            ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
            ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
    };

    /**
     * @class Quaternion
     * @name quat4
     */
    var quat4 = {};

    /**
     * Creates a new instance of a quat4 using the default array type
     * Any javascript array containing at least 4 numeric elements can serve as a quat4
     *
     * @param {quat4} [quat] quat4 containing values to initialize with
     *
     * @returns {quat4} New quat4
     */
    quat4.create = function (quat) {
        var dest = new MatrixArray(4);

        if (quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a quat4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {quat4} New quat4
     */
    quat4.createFrom = function (x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };

    /**
     * Copies the values of one quat4 to another
     *
     * @param {quat4} quat quat4 containing values to copy
     * @param {quat4} dest quat4 receiving copied values
     *
     * @returns {quat4} dest
     */
    quat4.set = function (quat, dest) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];

        return dest;
    };

    /**
     * Compares two quaternions for equality within a certain margin of error
     *
     * @param {quat4} a First vector
     * @param {quat4} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    quat4.compare = function (a, b) {
        return (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON
        );
    };

    /**
     * Creates a new identity Quat4
     *
     * @param {quat4} [dest] quat4 receiving copied values
     *
     * @returns {quat4} dest is specified, new quat4 otherwise
     */
    quat4.identity = function (dest) {
        if (!dest) { dest = quat4.create(); }
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    var identityQuat4 = quat4.identity();

    /**
     * Calculates the W component of a quat4 from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat4} quat quat4 to calculate W component of
     * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.calculateW = function (quat, dest) {
        var x = quat[0], y = quat[1], z = quat[2];

        if (!dest || quat === dest) {
            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return quat;
        }
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return dest;
    };

    /**
     * Calculates the dot product of two quaternions
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     *
     * @return {number} Dot product of quat and quat2
     */
    quat4.dot = function(quat, quat2){
        return quat[0]*quat2[0] + quat[1]*quat2[1] + quat[2]*quat2[2] + quat[3]*quat2[3];
    };

    /**
     * Calculates the inverse of a quat4
     *
     * @param {quat4} quat quat4 to calculate inverse of
     * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.inverse = function(quat, dest) {
        var q0 = quat[0], q1 = quat[1], q2 = quat[2], q3 = quat[3],
            dot = q0*q0 + q1*q1 + q2*q2 + q3*q3,
            invDot = dot ? 1.0/dot : 0;
        
        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
        
        if(!dest || quat === dest) {
            quat[0] *= -invDot;
            quat[1] *= -invDot;
            quat[2] *= -invDot;
            quat[3] *= invDot;
            return quat;
        }
        dest[0] = -quat[0]*invDot;
        dest[1] = -quat[1]*invDot;
        dest[2] = -quat[2]*invDot;
        dest[3] = quat[3]*invDot;
        return dest;
    };


    /**
     * Calculates the conjugate of a quat4
     * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
     *
     * @param {quat4} quat quat4 to calculate conjugate of
     * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.conjugate = function (quat, dest) {
        if (!dest || quat === dest) {
            quat[0] *= -1;
            quat[1] *= -1;
            quat[2] *= -1;
            return quat;
        }
        dest[0] = -quat[0];
        dest[1] = -quat[1];
        dest[2] = -quat[2];
        dest[3] = quat[3];
        return dest;
    };

    /**
     * Calculates the length of a quat4
     *
     * Params:
     * @param {quat4} quat quat4 to calculate length of
     *
     * @returns Length of quat
     */
    quat4.length = function (quat) {
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Generates a unit quaternion of the same direction as the provided quat4
     * If quaternion length is 0, returns [0, 0, 0, 0]
     *
     * @param {quat4} quat quat4 to normalize
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.normalize = function (quat, dest) {
        if (!dest) { dest = quat; }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len === 0) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            return dest;
        }
        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        dest[3] = w * len;

        return dest;
    };

    /**
     * Performs quaternion addition
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.add = function (quat, quat2, dest) {
        if(!dest || quat === dest) {
            quat[0] += quat2[0];
            quat[1] += quat2[1];
            quat[2] += quat2[2];
            quat[3] += quat2[3];
            return quat;
        }
        dest[0] = quat[0]+quat2[0];
        dest[1] = quat[1]+quat2[1];
        dest[2] = quat[2]+quat2[2];
        dest[3] = quat[3]+quat2[3];
        return dest;
    };

    /**
     * Performs a quaternion multiplication
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.multiply = function (quat, quat2, dest) {
        if (!dest) { dest = quat; }

        var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3],
            qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];

        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return dest;
    };

    /**
     * Transforms a vec3 with the given quaternion
     *
     * @param {quat4} quat quat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns dest if specified, vec otherwise
     */
    quat4.multiplyVec3 = function (quat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3],

            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    };

    /**
     * Multiplies the components of a quaternion by a scalar value
     *
     * @param {quat4} quat to scale
     * @param {number} val Value to scale by
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.scale = function (quat, val, dest) {
        if(!dest || quat === dest) {
            quat[0] *= val;
            quat[1] *= val;
            quat[2] *= val;
            quat[3] *= val;
            return quat;
        }
        dest[0] = quat[0]*val;
        dest[1] = quat[1]*val;
        dest[2] = quat[2]*val;
        dest[3] = quat[3]*val;
        return dest;
    };

    /**
     * Calculates a 3x3 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat3} [dest] mat3 receiving operation result
     *
     * @returns {mat3} dest if specified, a new mat3 otherwise
     */
    quat4.toMat3 = function (quat, dest) {
        if (!dest) { dest = mat3.create(); }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;

        dest[3] = xy - wz;
        dest[4] = 1 - (xx + zz);
        dest[5] = yz + wx;

        dest[6] = xz + wy;
        dest[7] = yz - wx;
        dest[8] = 1 - (xx + yy);

        return dest;
    };

    /**
     * Calculates a 4x4 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat4} [dest] mat4 receiving operation result
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    quat4.toMat4 = function (quat, dest) {
        if (!dest) { dest = mat4.create(); }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;

        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;

        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;

        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Performs a spherical linear interpolation between two quat4
     *
     * @param {quat4} quat First quaternion
     * @param {quat4} quat2 Second quaternion
     * @param {number} slerp Interpolation amount between the two inputs
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.slerp = function (quat, quat2, slerp, dest) {
        if (!dest) { dest = quat; }

        var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3],
            halfTheta,
            sinHalfTheta,
            ratioA,
            ratioB;

        if (Math.abs(cosHalfTheta) >= 1.0) {
            if (dest !== quat) {
                dest[0] = quat[0];
                dest[1] = quat[1];
                dest[2] = quat[2];
                dest[3] = quat[3];
            }
            return dest;
        }

        halfTheta = Math.acos(cosHalfTheta);
        sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
            dest[0] = (quat[0] * 0.5 + quat2[0] * 0.5);
            dest[1] = (quat[1] * 0.5 + quat2[1] * 0.5);
            dest[2] = (quat[2] * 0.5 + quat2[2] * 0.5);
            dest[3] = (quat[3] * 0.5 + quat2[3] * 0.5);
            return dest;
        }

        ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
        ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

        dest[0] = (quat[0] * ratioA + quat2[0] * ratioB);
        dest[1] = (quat[1] * ratioA + quat2[1] * ratioB);
        dest[2] = (quat[2] * ratioA + quat2[2] * ratioB);
        dest[3] = (quat[3] * ratioA + quat2[3] * ratioB);

        return dest;
    };

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * If dest is omitted, a new quaternion will be created.
     *
     * @param {mat3}  mat    the rotation matrix
     * @param {quat4} [dest] an optional receiving quaternion
     *
     * @returns {quat4} the quaternion constructed from the rotation matrix
     *
     */
    quat4.fromRotationMatrix = function(mat, dest) {
        if (!dest) dest = quat4.create();
        
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".

        var fTrace = mat[0] + mat[4] + mat[8];
        var fRoot;

        if ( fTrace > 0.0 ) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
            dest[3] = 0.5 * fRoot;
            fRoot = 0.5/fRoot;  // 1/(4w)
            dest[0] = (mat[7]-mat[5])*fRoot;
            dest[1] = (mat[2]-mat[6])*fRoot;
            dest[2] = (mat[3]-mat[1])*fRoot;
        } else {
            // |w| <= 1/2
            var s_iNext = quat4.fromRotationMatrix.s_iNext = quat4.fromRotationMatrix.s_iNext || [1,2,0];
            var i = 0;
            if ( mat[4] > mat[0] )
              i = 1;
            if ( mat[8] > mat[i*3+i] )
              i = 2;
            var j = s_iNext[i];
            var k = s_iNext[j];
            
            fRoot = Math.sqrt(mat[i*3+i]-mat[j*3+j]-mat[k*3+k] + 1.0);
            dest[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            dest[3] = (mat[k*3+j] - mat[j*3+k]) * fRoot;
            dest[j] = (mat[j*3+i] + mat[i*3+j]) * fRoot;
            dest[k] = (mat[k*3+i] + mat[i*3+k]) * fRoot;
        }
        
        return dest;
    };

    /**
     * Alias. See the description for quat4.fromRotationMatrix().
     */
    mat3.toQuat4 = quat4.fromRotationMatrix;

    (function() {
        var mat = mat3.create();
        
        /**
         * Creates a quaternion from the 3 given vectors. They must be perpendicular
         * to one another and represent the X, Y and Z axes.
         *
         * If dest is omitted, a new quat4 will be created.
         *
         * Example: The default OpenGL orientation has a view vector [0, 0, -1],
         * right vector [1, 0, 0], and up vector [0, 1, 0]. A quaternion representing
         * this orientation could be constructed with:
         *
         *   quat = quat4.fromAxes([0, 0, -1], [1, 0, 0], [0, 1, 0], quat4.create());
         *
         * @param {vec3}  view   the view vector, or direction the object is pointing in
         * @param {vec3}  right  the right vector, or direction to the "right" of the object
         * @param {vec3}  up     the up vector, or direction towards the object's "up"
         * @param {quat4} [dest] an optional receiving quat4
         *
         * @returns {quat4} dest
         **/
        quat4.fromAxes = function(view, right, up, dest) {
            mat[0] = right[0];
            mat[3] = right[1];
            mat[6] = right[2];

            mat[1] = up[0];
            mat[4] = up[1];
            mat[7] = up[2];

            mat[2] = view[0];
            mat[5] = view[1];
            mat[8] = view[2];

            return quat4.fromRotationMatrix(mat, dest);
        };
    })();

    /**
     * Sets a quat4 to the Identity and returns it.
     *
     * @param {quat4} [dest] quat4 to set. If omitted, a
     * new quat4 will be created.
     *
     * @returns {quat4} dest
     */
    quat4.identity = function(dest) {
        if (!dest) dest = quat4.create();
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Sets a quat4 from the given angle and rotation axis,
     * then returns it. If dest is not given, a new quat4 is created.
     *
     * @param {Number} angle  the angle in radians
     * @param {vec3}   axis   the axis around which to rotate
     * @param {quat4}  [dest] the optional quat4 to store the result
     *
     * @returns {quat4} dest
     **/
    quat4.fromAngleAxis = function(angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();
        
        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];
        
        return dest;
    };

    /**
     * Stores the angle and axis in a vec4, where the XYZ components represent
     * the axis and the W (4th) component is the angle in radians.
     *
     * If dest is not given, src will be modified in place and returned, after
     * which it should not be considered not a quaternion (just an axis and angle).
     *
     * @param {quat4} quat   the quaternion whose angle and axis to store
     * @param {vec4}  [dest] the optional vec4 to receive the data
     *
     * @returns {vec4} dest
     */
    quat4.toAngleAxis = function(src, dest) {
        if (!dest) dest = src;
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

        var sqrlen = src[0]*src[0]+src[1]*src[1]+src[2]*src[2];
        if (sqrlen > 0)
        {
            dest[3] = 2 * Math.acos(src[3]);
            var invlen = glMath.invsqrt(sqrlen);
            dest[0] = src[0]*invlen;
            dest[1] = src[1]*invlen;
            dest[2] = src[2]*invlen;
        } else {
            // angle is 0 (mod 2*pi), so any axis will do
            dest[3] = 0;
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
        }
        
        return dest;
    };

    /**
     * Returns a string representation of a quaternion
     *
     * @param {quat4} quat quat4 to represent as a string
     *
     * @returns {string} String representation of quat
     */
    quat4.str = function (quat) {
        return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
    };
    
    /**
     * @class 2 Dimensional Vector
     * @name vec2
     */
    var vec2 = {};
     
    /**
     * Creates a new vec2, initializing it from vec if vec
     * is given.
     *
     * @param {vec2} [vec] the vector's initial contents
     * @returns {vec2} a new 2D vector
     */
    vec2.create = function(vec) {
        var dest = new MatrixArray(2);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
        } else {
            dest[0] = 0;
            dest[1] = 0;
        }
        return dest;
    };

    /**
     * Creates a new instance of a vec2, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value

     * @returns {vec2} New vec2
     */
    vec2.createFrom = function (x, y) {
        var dest = new MatrixArray(2);

        dest[0] = x;
        dest[1] = y;

        return dest;
    };
    
    /**
     * Adds the vec2's together. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec2} vecA the first operand
     * @param {vec2} vecB the second operand
     * @param {vec2} [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.add = function(vecA, vecB, dest) {
        if (!dest) dest = vecB;
        dest[0] = vecA[0] + vecB[0];
        dest[1] = vecA[1] + vecB[1];
        return dest;
    };
    
    /**
     * Subtracts vecB from vecA. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec2} vecA the first operand
     * @param {vec2} vecB the second operand
     * @param {vec2} [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.subtract = function(vecA, vecB, dest) {
        if (!dest) dest = vecB;
        dest[0] = vecA[0] - vecB[0];
        dest[1] = vecA[1] - vecB[1];
        return dest;
    };
    
    /**
     * Multiplies vecA with vecB. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec2} vecA the first operand
     * @param {vec2} vecB the second operand
     * @param {vec2} [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.multiply = function(vecA, vecB, dest) {
        if (!dest) dest = vecB;
        dest[0] = vecA[0] * vecB[0];
        dest[1] = vecA[1] * vecB[1];
        return dest;
    };
    
    /**
     * Divides vecA by vecB. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec2} vecA the first operand
     * @param {vec2} vecB the second operand
     * @param {vec2} [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.divide = function(vecA, vecB, dest) {
        if (!dest) dest = vecB;
        dest[0] = vecA[0] / vecB[0];
        dest[1] = vecA[1] / vecB[1];
        return dest;
    };
    
    /**
     * Scales vecA by some scalar number. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecA.
     *
     * This is the same as multiplying each component of vecA
     * by the given scalar.
     *
     * @param {vec2}   vecA the vector to be scaled
     * @param {Number} scalar the amount to scale the vector by
     * @param {vec2}   [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.scale = function(vecA, scalar, dest) {
        if (!dest) dest = vecA;
        dest[0] = vecA[0] * scalar;
        dest[1] = vecA[1] * scalar;
        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec2
     *
     * Params:
     * @param {vec2} vecA First vector
     * @param {vec2} vecB Second vector
     *
     * @returns {number} Distance between vecA and vecB
     */
    vec2.dist = function (vecA, vecB) {
        var x = vecB[0] - vecA[0],
            y = vecB[1] - vecA[1];
        return Math.sqrt(x*x + y*y);
    };

    /**
     * Copies the values of one vec2 to another
     *
     * @param {vec2} vec vec2 containing values to copy
     * @param {vec2} dest vec2 receiving copied values
     *
     * @returns {vec2} dest
     */
    vec2.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec2} a First vector
     * @param {vec2} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    vec2.compare = function (a, b) {
        return (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON
        );
    };

    /**
     * Negates the components of a vec2
     *
     * @param {vec2} vec vec2 to negate
     * @param {vec2} [dest] vec2 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec2} dest if specified, vec otherwise
     */
    vec2.negate = function (vec, dest) {
        if (!dest) { dest = vec; }
        dest[0] = -vec[0];
        dest[1] = -vec[1];
        return dest;
    };

    /**
     * Normlize a vec2
     *
     * @param {vec2} vec vec2 to normalize
     * @param {vec2} [dest] vec2 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec2} dest if specified, vec otherwise
     */
    vec2.normalize = function (vec, dest) {
        if (!dest) { dest = vec; }
        var mag = vec[0] * vec[0] + vec[1] * vec[1];
        if (mag > 0) {
            mag = Math.sqrt(mag);
            dest[0] = vec[0] / mag;
            dest[1] = vec[1] / mag;
        } else {
            dest[0] = dest[1] = 0;
        }
        return dest;
    };

    /**
     * Computes the cross product of two vec2's. Note that the cross product must by definition
     * produce a 3D vector. If a dest vector is given, it will contain the resultant 3D vector.
     * Otherwise, a scalar number will be returned, representing the vector's Z coordinate, since
     * its X and Y must always equal 0.
     *
     * Examples:
     *    var crossResult = vec3.create();
     *    vec2.cross([1, 2], [3, 4], crossResult);
     *    //=> [0, 0, -2]
     *
     *    vec2.cross([1, 2], [3, 4]);
     *    //=> -2
     *
     * See http://stackoverflow.com/questions/243945/calculating-a-2d-vectors-cross-product
     * for some interesting facts.
     *
     * @param {vec2} vecA left operand
     * @param {vec2} vecB right operand
     * @param {vec2} [dest] optional vec2 receiving result. If not specified a scalar is returned
     *
     */
    vec2.cross = function (vecA, vecB, dest) {
        var z = vecA[0] * vecB[1] - vecA[1] * vecB[0];
        if (!dest) return z;
        dest[0] = dest[1] = 0;
        dest[2] = z;
        return dest;
    };
    
    /**
     * Caclulates the length of a vec2
     *
     * @param {vec2} vec vec2 to calculate length of
     *
     * @returns {Number} Length of vec
     */
    vec2.length = function (vec) {
      var x = vec[0], y = vec[1];
      return Math.sqrt(x * x + y * y);
    };

    /**
     * Caclulates the squared length of a vec2
     *
     * @param {vec2} vec vec2 to calculate squared length of
     *
     * @returns {Number} Squared Length of vec
     */
    vec2.squaredLength = function (vec) {
      var x = vec[0], y = vec[1];
      return x * x + y * y;
    };

    /**
     * Caclulates the dot product of two vec2s
     *
     * @param {vec2} vecA First operand
     * @param {vec2} vecB Second operand
     *
     * @returns {Number} Dot product of vecA and vecB
     */
    vec2.dot = function (vecA, vecB) {
        return vecA[0] * vecB[0] + vecA[1] * vecB[1];
    };
    
    /**
     * Generates a 2D unit vector pointing from one vector to another
     *
     * @param {vec2} vecA Origin vec2
     * @param {vec2} vecB vec2 to point to
     * @param {vec2} [dest] vec2 receiving operation result. If not specified result is written to vecA
     *
     * @returns {vec2} dest if specified, vecA otherwise
     */
    vec2.direction = function (vecA, vecB, dest) {
        if (!dest) { dest = vecA; }

        var x = vecA[0] - vecB[0],
            y = vecA[1] - vecB[1],
            len = x * x + y * y;

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }

        len = 1 / Math.sqrt(len);
        dest[0] = x * len;
        dest[1] = y * len;
        return dest;
    };

    /**
     * Performs a linear interpolation between two vec2
     *
     * @param {vec2} vecA First vector
     * @param {vec2} vecB Second vector
     * @param {Number} lerp Interpolation amount between the two inputs
     * @param {vec2} [dest] vec2 receiving operation result. If not specified result is written to vecA
     *
     * @returns {vec2} dest if specified, vecA otherwise
     */
    vec2.lerp = function (vecA, vecB, lerp, dest) {
        if (!dest) { dest = vecA; }
        dest[0] = vecA[0] + lerp * (vecB[0] - vecA[0]);
        dest[1] = vecA[1] + lerp * (vecB[1] - vecA[1]);
        return dest;
    };

    /**
     * Returns a string representation of a vector
     *
     * @param {vec2} vec Vector to represent as a string
     *
     * @returns {String} String representation of vec
     */
    vec2.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ']';
    };
    
    /**
     * @class 2x2 Matrix
     * @name mat2
     */
    var mat2 = {};
    
    /**
     * Creates a new 2x2 matrix. If src is given, the new matrix
     * is initialized to those values.
     *
     * @param {mat2} [src] the seed values for the new matrix, if any
     * @returns {mat2} a new matrix
     */
    mat2.create = function(src) {
        var dest = new MatrixArray(4);
        
        if (src) {
            dest[0] = src[0];
            dest[1] = src[1];
            dest[2] = src[2];
            dest[3] = src[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }
        return dest;
    };

    /**
     * Creates a new instance of a mat2, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m10
     * @param {number} m11

     * @returns {mat2} New mat2
     */
    mat2.createFrom = function (m00, m01, m10, m11) {
        var dest = new MatrixArray(4);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m10;
        dest[3] = m11;

        return dest;
    };
    
    /**
     * Copies the values of one mat2 to another
     *
     * @param {mat2} mat mat2 containing values to copy
     * @param {mat2} dest mat2 receiving copied values
     *
     * @returns {mat2} dest
     */
    mat2.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat2} a First matrix
     * @param {mat2} b Second matrix
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    mat2.compare = function (a, b) {
        return (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON
        );
    };

    /**
     * Sets a mat2 to an identity matrix
     *
     * @param {mat2} [dest] mat2 to set. If omitted a new one will be created.
     *
     * @returns {mat2} dest
     */
    mat2.identity = function (dest) {
        if (!dest) { dest = mat2.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Transposes a mat2 (flips the values over the diagonal)
     *
     * @param {mat2} mat mat2 to transpose
     * @param {mat2} [dest] mat2 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat2} dest if specified, mat otherwise
     */
    mat2.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a00 = mat[1];
            mat[1] = mat[2];
            mat[2] = a00;
            return mat;
        }
        
        dest[0] = mat[0];
        dest[1] = mat[2];
        dest[2] = mat[1];
        dest[3] = mat[3];
        return dest;
    };

    /**
     * Calculates the determinant of a mat2
     *
     * @param {mat2} mat mat2 to calculate determinant of
     *
     * @returns {Number} determinant of mat
     */
    mat2.determinant = function (mat) {
      return mat[0] * mat[3] - mat[2] * mat[1];
    };
    
    /**
     * Calculates the inverse matrix of a mat2
     *
     * @param {mat2} mat mat2 to calculate inverse of
     * @param {mat2} [dest] mat2 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat2} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat2.inverse = function (mat, dest) {
        if (!dest) { dest = mat; }
        var a0 = mat[0], a1 = mat[1], a2 = mat[2], a3 = mat[3];
        var det = a0 * a3 - a2 * a1;
        if (!det) return null;
        
        det = 1.0 / det;
        dest[0] =  a3 * det;
        dest[1] = -a1 * det;
        dest[2] = -a2 * det;
        dest[3] =  a0 * det;
        return dest;
    };
    
    /**
     * Performs a matrix multiplication
     *
     * @param {mat2} matA First operand
     * @param {mat2} matB Second operand
     * @param {mat2} [dest] mat2 receiving operation result. If not specified result is written to matA
     *
     * @returns {mat2} dest if specified, matA otherwise
     */
    mat2.multiply = function (matA, matB, dest) {
        if (!dest) { dest = matA; }
        var a11 = matA[0],
            a12 = matA[1],
            a21 = matA[2],
            a22 = matA[3];
        dest[0] = a11 * matB[0] + a12 * matB[2];
        dest[1] = a11 * matB[1] + a12 * matB[3];
        dest[2] = a21 * matB[0] + a22 * matB[2];
        dest[3] = a21 * matB[1] + a22 * matB[3];
        return dest;
    };

    /**
     * Rotates a 2x2 matrix by an angle
     *
     * @param {mat2}   mat   The matrix to rotate
     * @param {Number} angle The angle in radians
     * @param {mat2} [dest]  Optional mat2 receiving the result. If omitted mat will be used.
     *
     * @returns {mat2} dest if specified, mat otherwise
     */
    mat2.rotate = function (mat, angle, dest) {
        if (!dest) { dest = mat; }
        var a11 = mat[0],
            a12 = mat[1],
            a21 = mat[2],
            a22 = mat[3],
            s = Math.sin(angle),
            c = Math.cos(angle);
        dest[0] = a11 *  c + a12 * s;
        dest[1] = a11 * -s + a12 * c;
        dest[2] = a21 *  c + a22 * s;
        dest[3] = a21 * -s + a22 * c;
        return dest;
    };

    /**
     * Multiplies the vec2 by the given 2x2 matrix
     *
     * @param {mat2} matrix the 2x2 matrix to multiply against
     * @param {vec2} vec    the vector to multiply
     * @param {vec2} [dest] an optional receiving vector. If not given, vec is used.
     *
     * @returns {vec2} The multiplication result
     **/
    mat2.multiplyVec2 = function(matrix, vec, dest) {
      if (!dest) dest = vec;
      var x = vec[0], y = vec[1];
      dest[0] = x * matrix[0] + y * matrix[1];
      dest[1] = x * matrix[2] + y * matrix[3];
      return dest;
    };
    
    /**
     * Scales the mat2 by the dimensions in the given vec2
     *
     * @param {mat2} matrix the 2x2 matrix to scale
     * @param {vec2} vec    the vector containing the dimensions to scale by
     * @param {vec2} [dest] an optional receiving mat2. If not given, matrix is used.
     *
     * @returns {mat2} dest if specified, matrix otherwise
     **/
    mat2.scale = function(matrix, vec, dest) {
      if (!dest) { dest = matrix; }
      var a11 = matrix[0],
          a12 = matrix[1],
          a21 = matrix[2],
          a22 = matrix[3],
          b11 = vec[0],
          b22 = vec[1];
      dest[0] = a11 * b11;
      dest[1] = a12 * b22;
      dest[2] = a21 * b11;
      dest[3] = a22 * b22;
      return dest;
    };

    /**
     * Returns a string representation of a mat2
     *
     * @param {mat2} mat mat2 to represent as a string
     *
     * @param {String} String representation of mat
     */
    mat2.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] + ']';
    };
    
    /**
     * @class 4 Dimensional Vector
     * @name vec4
     */
    var vec4 = {};
     
    /**
     * Creates a new vec4, initializing it from vec if vec
     * is given.
     *
     * @param {vec4} [vec] the vector's initial contents
     * @returns {vec4} a new 2D vector
     */
    vec4.create = function(vec) {
        var dest = new MatrixArray(4);
        
        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
            dest[3] = vec[3];
        } else {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
        }
        return dest;
    };

    /**
     * Creates a new instance of a vec4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {vec4} New vec4
     */
    vec4.createFrom = function (x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };
    
    /**
     * Adds the vec4's together. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec4} vecA the first operand
     * @param {vec4} vecB the second operand
     * @param {vec4} [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.add = function(vecA, vecB, dest) {
      if (!dest) dest = vecB;
      dest[0] = vecA[0] + vecB[0];
      dest[1] = vecA[1] + vecB[1];
      dest[2] = vecA[2] + vecB[2];
      dest[3] = vecA[3] + vecB[3];
      return dest;
    };
    
    /**
     * Subtracts vecB from vecA. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec4} vecA the first operand
     * @param {vec4} vecB the second operand
     * @param {vec4} [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.subtract = function(vecA, vecB, dest) {
      if (!dest) dest = vecB;
      dest[0] = vecA[0] - vecB[0];
      dest[1] = vecA[1] - vecB[1];
      dest[2] = vecA[2] - vecB[2];
      dest[3] = vecA[3] - vecB[3];
      return dest;
    };
    
    /**
     * Multiplies vecA with vecB. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec4} vecA the first operand
     * @param {vec4} vecB the second operand
     * @param {vec4} [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.multiply = function(vecA, vecB, dest) {
      if (!dest) dest = vecB;
      dest[0] = vecA[0] * vecB[0];
      dest[1] = vecA[1] * vecB[1];
      dest[2] = vecA[2] * vecB[2];
      dest[3] = vecA[3] * vecB[3];
      return dest;
    };
    
    /**
     * Divides vecA by vecB. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec4} vecA the first operand
     * @param {vec4} vecB the second operand
     * @param {vec4} [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.divide = function(vecA, vecB, dest) {
      if (!dest) dest = vecB;
      dest[0] = vecA[0] / vecB[0];
      dest[1] = vecA[1] / vecB[1];
      dest[2] = vecA[2] / vecB[2];
      dest[3] = vecA[3] / vecB[3];
      return dest;
    };
    
    /**
     * Scales vecA by some scalar number. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecA.
     *
     * This is the same as multiplying each component of vecA
     * by the given scalar.
     *
     * @param {vec4}   vecA the vector to be scaled
     * @param {Number} scalar the amount to scale the vector by
     * @param {vec4}   [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.scale = function(vecA, scalar, dest) {
      if (!dest) dest = vecA;
      dest[0] = vecA[0] * scalar;
      dest[1] = vecA[1] * scalar;
      dest[2] = vecA[2] * scalar;
      dest[3] = vecA[3] * scalar;
      return dest;
    };

    /**
     * Copies the values of one vec4 to another
     *
     * @param {vec4} vec vec4 containing values to copy
     * @param {vec4} dest vec4 receiving copied values
     *
     * @returns {vec4} dest
     */
    vec4.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];
        dest[3] = vec[3];
        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec4} a First vector
     * @param {vec4} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    vec4.compare = function (a, b) {
        return (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON
        );
    };

    /**
     * Negates the components of a vec4
     *
     * @param {vec4} vec vec4 to negate
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    vec4.negate = function (vec, dest) {
        if (!dest) { dest = vec; }
        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        dest[3] = -vec[3];
        return dest;
    };

    /**
     * Caclulates the length of a vec2
     *
     * @param {vec2} vec vec2 to calculate length of
     *
     * @returns {Number} Length of vec
     */
    vec4.length = function (vec) {
      var x = vec[0], y = vec[1], z = vec[2], w = vec[3];
      return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Caclulates the squared length of a vec4
     *
     * @param {vec4} vec vec4 to calculate squared length of
     *
     * @returns {Number} Squared Length of vec
     */
    vec4.squaredLength = function (vec) {
      var x = vec[0], y = vec[1], z = vec[2], w = vec[3];
      return x * x + y * y + z * z + w * w;
    };

    /**
     * Performs a linear interpolation between two vec4
     *
     * @param {vec4} vecA First vector
     * @param {vec4} vecB Second vector
     * @param {Number} lerp Interpolation amount between the two inputs
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vecA
     *
     * @returns {vec4} dest if specified, vecA otherwise
     */
    vec4.lerp = function (vecA, vecB, lerp, dest) {
        if (!dest) { dest = vecA; }
        dest[0] = vecA[0] + lerp * (vecB[0] - vecA[0]);
        dest[1] = vecA[1] + lerp * (vecB[1] - vecA[1]);
        dest[2] = vecA[2] + lerp * (vecB[2] - vecA[2]);
        dest[3] = vecA[3] + lerp * (vecB[3] - vecA[3]);
        return dest;
    };

    /**
     * Returns a string representation of a vector
     *
     * @param {vec4} vec Vector to represent as a string
     *
     * @returns {String} String representation of vec
     */
    vec4.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ', ' + vec[3] + ']';
    };

    /*
     * Exports
     */

    if(root) {
        root.glMatrixArrayType = MatrixArray;
        root.MatrixArray = MatrixArray;
        root.setMatrixArrayType = setMatrixArrayType;
        root.determineMatrixArrayType = determineMatrixArrayType;
        root.glMath = glMath;
        root.vec2 = vec2;
        root.vec3 = vec3;
        root.vec4 = vec4;
        root.mat2 = mat2;
        root.mat3 = mat3;
        root.mat4 = mat4;
        root.quat4 = quat4;
    }

    return {
        glMatrixArrayType: MatrixArray,
        MatrixArray: MatrixArray,
        setMatrixArrayType: setMatrixArrayType,
        determineMatrixArrayType: determineMatrixArrayType,
        glMath: glMath,
        vec2: vec2,
        vec3: vec3,
        vec4: vec4,
        mat2: mat2,
        mat3: mat3,
        mat4: mat4,
        quat4: quat4
    };
}));



/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/lib/zlib.js: */

/*
 * Extracted from pdf.js
 * https://github.com/andreasgal/pdf.js
 *
 * Copyright (c) 2011 Mozilla Foundation
 *
 * Contributors: Andreas Gal <gal@mozilla.com>
 *               Chris G Jones <cjones@mozilla.com>
 *               Shaon Barman <shaon.barman@gmail.com>
 *               Vivien Nicolas <21@vingtetun.org>
 *               Justin D'Arcangelo <justindarc@gmail.com>
 *               Yury Delendik
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

var DecodeStream = (function() {
  function constructor() {
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = null;
  }

  constructor.prototype = {
    ensureBuffer: function decodestream_ensureBuffer(requested) {
      var buffer = this.buffer;
      var current = buffer ? buffer.byteLength : 0;
      if (requested < current)
        return buffer;
      var size = 512;
      while (size < requested)
        size <<= 1;
      var buffer2 = new Uint8Array(size);
      for (var i = 0; i < current; ++i)
        buffer2[i] = buffer[i];
      return this.buffer = buffer2;
    },
    getByte: function decodestream_getByte() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof)
          return null;
        this.readBlock();
      }
      return this.buffer[this.pos++];
    },
    getBytes: function decodestream_getBytes(length) {
      var pos = this.pos;

      if (length) {
        this.ensureBuffer(pos + length);
        var end = pos + length;

        while (!this.eof && this.bufferLength < end)
          this.readBlock();

        var bufEnd = this.bufferLength;
        if (end > bufEnd)
          end = bufEnd;
      } else {
        while (!this.eof)
          this.readBlock();

        var end = this.bufferLength;
      }

      this.pos = end;
      return this.buffer.subarray(pos, end);
    },
    lookChar: function decodestream_lookChar() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof)
          return null;
        this.readBlock();
      }
      return String.fromCharCode(this.buffer[this.pos]);
    },
    getChar: function decodestream_getChar() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof)
          return null;
        this.readBlock();
      }
      return String.fromCharCode(this.buffer[this.pos++]);
    },
    makeSubStream: function decodestream_makeSubstream(start, length, dict) {
      var end = start + length;
      while (this.bufferLength <= end && !this.eof)
        this.readBlock();
      return new Stream(this.buffer, start, length, dict);
    },
    skip: function decodestream_skip(n) {
      if (!n)
        n = 1;
      this.pos += n;
    },
    reset: function decodestream_reset() {
      this.pos = 0;
    }
  };

  return constructor;
})();

var FlateStream = (function() {
  var codeLenCodeMap = new Uint32Array([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
  ]);

  var lengthDecode = new Uint32Array([
    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,
    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,
    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,
    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102
  ]);

  var distDecode = new Uint32Array([
    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,
    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,
    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,
    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001
  ]);

  var fixedLitCodeTab = [new Uint32Array([
    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,
    0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,
    0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,
    0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,
    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,
    0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,
    0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,
    0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,
    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,
    0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,
    0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,
    0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,
    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,
    0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,
    0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,
    0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,
    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,
    0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,
    0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,
    0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,
    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,
    0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,
    0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,
    0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,
    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,
    0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,
    0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,
    0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,
    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,
    0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,
    0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,
    0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,
    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,
    0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,
    0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,
    0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,
    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,
    0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,
    0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,
    0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,
    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,
    0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,
    0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,
    0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,
    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,
    0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,
    0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,
    0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,
    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,
    0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,
    0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,
    0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,
    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,
    0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,
    0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,
    0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,
    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,
    0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,
    0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,
    0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,
    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,
    0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,
    0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,
    0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff
  ]), 9];

  var fixedDistCodeTab = [new Uint32Array([
    0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,
    0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,
    0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,
    0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000
  ]), 5];
  
  function error(e) {
      throw new Error(e)
  }

  function constructor(bytes) {
    //var bytes = stream.getBytes();
    var bytesPos = 0;

    var cmf = bytes[bytesPos++];
    var flg = bytes[bytesPos++];
    if (cmf == -1 || flg == -1)
      error('Invalid header in flate stream');
    if ((cmf & 0x0f) != 0x08)
      error('Unknown compression method in flate stream');
    if ((((cmf << 8) + flg) % 31) != 0)
      error('Bad FCHECK in flate stream');
    if (flg & 0x20)
      error('FDICT bit set in flate stream');

    this.bytes = bytes;
    this.bytesPos = bytesPos;

    this.codeSize = 0;
    this.codeBuf = 0;

    DecodeStream.call(this);
  }

  constructor.prototype = Object.create(DecodeStream.prototype);

  constructor.prototype.getBits = function(bits) {
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var bytes = this.bytes;
    var bytesPos = this.bytesPos;

    var b;
    while (codeSize < bits) {
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad encoding in flate stream');
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    b = codeBuf & ((1 << bits) - 1);
    this.codeBuf = codeBuf >> bits;
    this.codeSize = codeSize -= bits;
    this.bytesPos = bytesPos;
    return b;
  };

  constructor.prototype.getCode = function(table) {
    var codes = table[0];
    var maxLen = table[1];
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var bytes = this.bytes;
    var bytesPos = this.bytesPos;

    while (codeSize < maxLen) {
      var b;
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad encoding in flate stream');
      codeBuf |= (b << codeSize);
      codeSize += 8;
    }
    var code = codes[codeBuf & ((1 << maxLen) - 1)];
    var codeLen = code >> 16;
    var codeVal = code & 0xffff;
    if (codeSize == 0 || codeSize < codeLen || codeLen == 0)
      error('Bad encoding in flate stream');
    this.codeBuf = (codeBuf >> codeLen);
    this.codeSize = (codeSize - codeLen);
    this.bytesPos = bytesPos;
    return codeVal;
  };

  constructor.prototype.generateHuffmanTable = function(lengths) {
    var n = lengths.length;

    // find max code length
    var maxLen = 0;
    for (var i = 0; i < n; ++i) {
      if (lengths[i] > maxLen)
        maxLen = lengths[i];
    }

    // build the table
    var size = 1 << maxLen;
    var codes = new Uint32Array(size);
    for (var len = 1, code = 0, skip = 2;
         len <= maxLen;
         ++len, code <<= 1, skip <<= 1) {
      for (var val = 0; val < n; ++val) {
        if (lengths[val] == len) {
          // bit-reverse the code
          var code2 = 0;
          var t = code;
          for (var i = 0; i < len; ++i) {
            code2 = (code2 << 1) | (t & 1);
            t >>= 1;
          }

          // fill the table entries
          for (var i = code2; i < size; i += skip)
            codes[i] = (len << 16) | val;

          ++code;
        }
      }
    }

    return [codes, maxLen];
  };

  constructor.prototype.readBlock = function() {
    function repeat(stream, array, len, offset, what) {
      var repeat = stream.getBits(len) + offset;
      while (repeat-- > 0)
        array[i++] = what;
    }

    // read block header
    var hdr = this.getBits(3);
    if (hdr & 1)
      this.eof = true;
    hdr >>= 1;

    if (hdr == 0) { // uncompressed block
      var bytes = this.bytes;
      var bytesPos = this.bytesPos;
      var b;

      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad block header in flate stream');
      var blockLen = b;
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad block header in flate stream');
      blockLen |= (b << 8);
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad block header in flate stream');
      var check = b;
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad block header in flate stream');
      check |= (b << 8);
      if (check != (~blockLen & 0xffff))
        error('Bad uncompressed block length in flate stream');

      this.codeBuf = 0;
      this.codeSize = 0;

      var bufferLength = this.bufferLength;
      var buffer = this.ensureBuffer(bufferLength + blockLen);
      var end = bufferLength + blockLen;
      this.bufferLength = end;
      for (var n = bufferLength; n < end; ++n) {
        if (typeof (b = bytes[bytesPos++]) == 'undefined') {
          this.eof = true;
          break;
        }
        buffer[n] = b;
      }
      this.bytesPos = bytesPos;
      return;
    }

    var litCodeTable;
    var distCodeTable;
    if (hdr == 1) { // compressed block, fixed codes
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } else if (hdr == 2) { // compressed block, dynamic codes
      var numLitCodes = this.getBits(5) + 257;
      var numDistCodes = this.getBits(5) + 1;
      var numCodeLenCodes = this.getBits(4) + 4;

      // build the code lengths code table
      var codeLenCodeLengths = Array(codeLenCodeMap.length);
      var i = 0;
      while (i < numCodeLenCodes)
        codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);
      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);

      // build the literal and distance code tables
      var len = 0;
      var i = 0;
      var codes = numLitCodes + numDistCodes;
      var codeLengths = new Array(codes);
      while (i < codes) {
        var code = this.getCode(codeLenCodeTab);
        if (code == 16) {
          repeat(this, codeLengths, 2, 3, len);
        } else if (code == 17) {
          repeat(this, codeLengths, 3, 3, len = 0);
        } else if (code == 18) {
          repeat(this, codeLengths, 7, 11, len = 0);
        } else {
          codeLengths[i++] = len = code;
        }
      }

      litCodeTable =
        this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));
      distCodeTable =
        this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));
    } else {
      error('Unknown block type in flate stream');
    }

    var buffer = this.buffer;
    var limit = buffer ? buffer.length : 0;
    var pos = this.bufferLength;
    while (true) {
      var code1 = this.getCode(litCodeTable);
      if (code1 < 256) {
        if (pos + 1 >= limit) {
          buffer = this.ensureBuffer(pos + 1);
          limit = buffer.length;
        }
        buffer[pos++] = code1;
        continue;
      }
      if (code1 == 256) {
        this.bufferLength = pos;
        return;
      }
      code1 -= 257;
      code1 = lengthDecode[code1];
      var code2 = code1 >> 16;
      if (code2 > 0)
        code2 = this.getBits(code2);
      var len = (code1 & 0xffff) + code2;
      code1 = this.getCode(distCodeTable);
      code1 = distDecode[code1];
      code2 = code1 >> 16;
      if (code2 > 0)
        code2 = this.getBits(code2);
      var dist = (code1 & 0xffff) + code2;
      if (pos + len >= limit) {
        buffer = this.ensureBuffer(pos + len);
        limit = buffer.length;
      }
      for (var k = 0; k < len; ++k, ++pos)
        buffer[pos] = buffer[pos - dist];
    }
  };

  return constructor;
})();


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/lib/hammer.js: */

/*! Hammer.JS - v1.0.9 - 2014-03-18
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

/*************************
 * PORCUPINE INPUT HACK..
 *************************/
window.navigator.pointerEnabled = true;
/*************************
 * PORCUPINE INPUT HACK..
 *************************/

(function(window, undefined) {
  'use strict';

/**
 * Hammer
 * use this to create instances
 * @param   {HTMLElement}   element
 * @param   {Object}        options
 * @returns {Hammer.Instance}
 * @constructor
 */
var Hammer = function(element, options) {
  return new Hammer.Instance(element, options || {});
};

Hammer.VERSION = '1.0.9';

// default settings
Hammer.defaults = {
  // add styles and attributes to the element to prevent the browser from doing
  // its native behavior. this doesnt prevent the scrolling, but cancels
  // the contextmenu, tap highlighting etc
  // set to false to disable this
  stop_browser_behavior: {
    // this also triggers onselectstart=false for IE
    userSelect       : 'none',
    // this makes the element blocking in IE10 >, you could experiment with the value
    // see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
    touchAction      : 'none',
    touchCallout     : 'none',
    contentZooming   : 'none',
    userDrag         : 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }

  //
  // more settings are defined per gesture at gestures.js
  //
};


// detect touchevents
Hammer.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

// dont use mouseevents on mobile devices
Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && window.navigator.userAgent.match(Hammer.MOBILE_REGEX);

// eventtypes per touchevent (start, move, end)
// are filled by Event.determineEventTypes on setup
Hammer.EVENT_TYPES = {};

// interval in which Hammer recalculates current velocity in ms
Hammer.UPDATE_VELOCITY_INTERVAL = 16;

// hammer document where the base events are added at
Hammer.DOCUMENT = window.document;

// define these also as vars, for internal usage.
// direction defines
var DIRECTION_DOWN = Hammer.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = Hammer.DIRECTION_LEFT = 'left';
var DIRECTION_UP = Hammer.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = Hammer.DIRECTION_RIGHT = 'right';

// pointer type
var POINTER_MOUSE = Hammer.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = Hammer.POINTER_TOUCH = 'touch';
var POINTER_PEN = Hammer.POINTER_PEN = 'pen';

// touch event defines
var EVENT_START = Hammer.EVENT_START = 'start';
var EVENT_MOVE = Hammer.EVENT_MOVE = 'move';
var EVENT_END = Hammer.EVENT_END = 'end';


// plugins and gestures namespaces
Hammer.plugins = Hammer.plugins || {};
Hammer.gestures = Hammer.gestures || {};


// if the window events are set...
Hammer.READY = false;

/**
 * setup events to detect gestures on the document
 */
function setup() {
  if(Hammer.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Event.determineEventTypes();

  // Register all gestures inside Hammer.gestures
  Utils.each(Hammer.gestures, function(gesture){
    Detection.register(gesture);
  });

  // Add touch events on the document
  Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);
  Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);

  // Hammer is ready...!
  Hammer.READY = true;
}

var Utils = Hammer.utils = {
  /**
   * extend method,
   * also used for cloning when dest is an empty object
   * @param   {Object}    dest
   * @param   {Object}    src
   * @parm  {Boolean}  merge    do a merge
   * @returns {Object}    dest
   */
  extend: function extend(dest, src, merge) {
    for(var key in src) {
      if(dest[key] !== undefined && merge) {
        continue;
      }
      dest[key] = src[key];
    }
    return dest;
  },


  /**
   * for each
   * @param obj
   * @param iterator
   */
  each: function(obj, iterator, context) {
    var i, o;
    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
    }
    // arrays
    else if(obj.length !== undefined) {
      for(i=-1; (o=obj[++i]);) {
        if (iterator.call(context, o, i, obj) === false) {
          return;
        }
      }
    }
    // objects
    else {
      for(i in obj) {
        if(obj.hasOwnProperty(i) &&
            iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a node is in the given parent
   * used for event delegation tricks
   * @param   {HTMLElement}   node
   * @param   {HTMLElement}   parent
   * @returns {boolean}       has_parent
   */
  hasParent: function(node, parent) {
    while(node) {
      if(node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },


  /**
   * get the center of all the touches
   * @param   {Array}     touches
   * @returns {Object}    center
   */
  getCenter: function getCenter(touches) {
    var valuesX = [], valuesY = [];

    Utils.each(touches, function(touch) {
      // I prefer clientX because it ignore the scrolling position
      valuesX.push(typeof touch.clientX !== 'undefined' ? touch.clientX : touch.pageX);
      valuesY.push(typeof touch.clientY !== 'undefined' ? touch.clientY : touch.pageY);
    });

    return {
      pageX: (Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2,
      pageY: (Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2
    };
  },


  /**
   * calculate the velocity between two points
   * @param   {Number}    delta_time
   * @param   {Number}    delta_x
   * @param   {Number}    delta_y
   * @returns {Object}    velocity
   */
  getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
    return {
      x: Math.abs(delta_x / delta_time) || 0,
      y: Math.abs(delta_y / delta_time) || 0
    };
  },


  /**
   * calculate the angle between two coordinates
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {Number}    angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var y = touch2.pageY - touch1.pageY
      , x = touch2.pageX - touch1.pageX;
    return Math.atan2(y, x) * 180 / Math.PI;
  },


  /**
   * angle to direction define
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {String}    direction constant, like DIRECTION_LEFT
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.pageX - touch2.pageX)
      , y = Math.abs(touch1.pageY - touch2.pageY);
    if(x >= y) {
      return touch1.pageX - touch2.pageX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return touch1.pageY - touch2.pageY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  },


  /**
   * calculate the distance between two touches
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {Number}    distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.pageX - touch1.pageX
      , y = touch2.pageY - touch1.pageY;
    return Math.sqrt((x * x) + (y * y));
  },


  /**
   * calculate the scale factor between two touchLists (fingers)
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param   {Array}     start
   * @param   {Array}     end
   * @returns {Number}    scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if(start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
    }
    return 1;
  },


  /**
   * calculate the rotation degrees between two touchLists (fingers)
   * @param   {Array}     start
   * @param   {Array}     end
   * @returns {Number}    rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if(start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
    }
    return 0;
  },


  /**
   * boolean if the direction is vertical
   * @param    {String}    direction
   * @returns  {Boolean}   is_vertical
   */
  isVertical: function isVertical(direction) {
    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
  },


  /**
   * toggle browser default behavior with css props
   * @param   {HtmlElement}   element
   * @param   {Object}        css_props
   * @param   {Boolean}       toggle
   */
  toggleDefaultBehavior: function toggleDefaultBehavior(element, css_props, toggle) {
    if(!css_props || !element || !element.style) {
      return;
    }

    // with css properties for modern browsers
    Utils.each(['webkit', 'moz', 'Moz', 'ms', 'o', ''], function(vendor) {
      Utils.each(css_props, function(value, prop) {
          // vender prefix at the property
          if(vendor) {
            prop = vendor + prop.substring(0, 1).toUpperCase() + prop.substring(1);
          }
          // set the style
          if(prop in element.style) {
            element.style[prop] = !toggle && value;
          }
      });
    });

    var false_fn = function(){ return false; };

    // also the disable onselectstart
    if(css_props.userSelect == 'none') {
      element.onselectstart = !toggle && false_fn;
    }
    // and disable ondragstart
    if(css_props.userDrag == 'none') {
      element.ondragstart = !toggle && false_fn;
    }
  }
};


/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @param   {Object}            [options={}]
 * @returns {Hammer.Instance}
 * @constructor
 */
Hammer.Instance = function(element, options) {
  var self = this;

  // setup HammerJS window events and register all gestures
  // this also sets up the default options
  setup();

  this.element = element;

  // start/stop detection option
  this.enabled = true;

  // merge options
  this.options = Utils.extend(
    Utils.extend({}, Hammer.defaults),
    options || {});

  // add some css to the element to prevent the browser from doing its native behavoir
  if(this.options.stop_browser_behavior) {
    Utils.toggleDefaultBehavior(this.element, this.options.stop_browser_behavior, false);
  }

  // start detection on touchstart
  this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {
    if(self.enabled) {
      Detection.startDetect(self, ev);
    }
  });

  // keep a list of user event handlers which needs to be removed when calling 'dispose'
  this.eventHandlers = [];

  // return instance
  return this;
};


Hammer.Instance.prototype = {
  /**
   * bind events to the instance
   * @param   {String}      gesture
   * @param   {Function}    handler
   * @returns {Hammer.Instance}
   */
  on: function onEvent(gesture, handler) {
    var gestures = gesture.split(' ');
    Utils.each(gestures, function(gesture) {
      this.element.addEventListener(gesture, handler, false);
      this.eventHandlers.push({ gesture: gesture, handler: handler });
    }, this);
    return this;
  },


  /**
   * unbind events to the instance
   * @param   {String}      gesture
   * @param   {Function}    handler
   * @returns {Hammer.Instance}
   */
  off: function offEvent(gesture, handler) {
    var gestures = gesture.split(' ')
      , i, eh;
    Utils.each(gestures, function(gesture) {
      this.element.removeEventListener(gesture, handler, false);

      // remove the event handler from the internal list
      for(i=-1; (eh=this.eventHandlers[++i]);) {
        if(eh.gesture === gesture && eh.handler === handler) {
          this.eventHandlers.splice(i, 1);
        }
      }
    }, this);
    return this;
  },


  /**
   * trigger gesture event
   * @param   {String}      gesture
   * @param   {Object}      [eventData]
   * @returns {Hammer.Instance}
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if(!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = Hammer.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if(Utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },


  /**
   * enable of disable hammer.js detection
   * @param   {Boolean}   state
   * @returns {Hammer.Instance}
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  },


  /**
   * dispose this hammer instance
   * @returns {Hammer.Instance}
   */
  dispose: function dispose() {
    var i, eh;

    // undo all changes made by stop_browser_behavior
    if(this.options.stop_browser_behavior) {
      Utils.toggleDefaultBehavior(this.element, this.options.stop_browser_behavior, true);
    }

    // unbind all custom event handlers
    for(i=-1; (eh=this.eventHandlers[++i]);) {
      this.element.removeEventListener(eh.gesture, eh.handler, false);
    }
    this.eventHandlers = [];

    // unbind the start event listener
    Event.unbindDom(this.element, Hammer.EVENT_TYPES[EVENT_START], this.eventStartHandler);

    return null;
  }
};


/**
 * this holds the last move event,
 * used to fix empty touchend issue
 * see the onTouch event for an explanation
 * @type {Object}
 */
var last_move_event = null;

/**
 * when the mouse is hold down, this is true
 * @type {Boolean}
 */
var enable_detect = false;

/**
 * when touch events have been fired, this is true
 * @type {Boolean}
 */
var touch_triggered = false;

var Event = Hammer.event = {
  /**
   * simple addEventListener
   * @param   {HTMLElement}   element
   * @param   {String}        type
   * @param   {Function}      handler
   */
  bindDom: function(element, type, handler) {
    var types = type.split(' ');
    Utils.each(types, function(type){
      element.addEventListener(type, handler, false);
    });
  },


  /**
   * simple removeEventListener
   * @param   {HTMLElement}   element
   * @param   {String}        type
   * @param   {Function}      handler
   */
  unbindDom: function(element, type, handler) {
    var types = type.split(' ');
    Utils.each(types, function(type){
      element.removeEventListener(type, handler, false);
    });
  },


  /**
   * touch events with mouse fallback
   * @param   {HTMLElement}   element
   * @param   {String}        eventType        like EVENT_MOVE
   * @param   {Function}      handler
   */
  onTouch: function onTouch(element, eventType, handler) {
    var self = this;

    var bindDomOnTouch = function(ev) {
      var srcEventType = ev.type.toLowerCase();

      // onmouseup, but when touchend has been fired we do nothing.
      // this is for touchdevices which also fire a mouseup on touchend
      if(srcEventType.match(/mouse/) && touch_triggered) {
        return;
      }

      // mousebutton must be down or a touch event
      else if(srcEventType.match(/touch/) ||   // touch events are always on screen
        srcEventType.match(/pointerdown/) || // pointerevents touch
        (srcEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
        ) {
        enable_detect = true;
      }

      // mouse isn't pressed
      else if(srcEventType.match(/mouse/) && !ev.which) {
        enable_detect = false;
      }


      // we are in a touch event, set the touch triggered bool to true,
      // this for the conflicts that may occur on ios and android
      if(srcEventType.match(/touch|pointer/)) {
        touch_triggered = true;
      }

      // count the total touches on the screen
      var count_touches = 0;

      // when touch has been triggered in this detection session
      // and we are now handling a mouse event, we stop that to prevent conflicts
      if(enable_detect) {
        // update pointerevent
        if(Hammer.HAS_POINTEREVENTS && eventType != EVENT_END) {
          count_touches = PointerEvent.updatePointer(eventType, ev);
        }
        // touch
        else if(srcEventType.match(/touch/)) {
          count_touches = ev.touches.length;
        }
        // mouse
        else if(!touch_triggered) {
          count_touches = srcEventType.match(/up/) ? 0 : 1;
        }

        // if we are in a end event, but when we remove one touch and
        // we still have enough, set eventType to move
        if(count_touches > 0 && eventType == EVENT_END) {
          eventType = EVENT_MOVE;
        }
        // no touches, force the end event
        else if(!count_touches) {
          eventType = EVENT_END;
        }

        // store the last move event
        if(count_touches || last_move_event === null) {
          last_move_event = ev;
        }

        // trigger the handler
        handler.call(Detection, self.collectEventData(element, eventType,
                                         self.getTouchList(last_move_event, eventType),
                                         ev));

        // remove pointerevent from list
        if(Hammer.HAS_POINTEREVENTS && eventType == EVENT_END) {
          count_touches = PointerEvent.updatePointer(eventType, ev);
        }
      }

      // on the end we reset everything
      if(!count_touches) {
        last_move_event = null;
        enable_detect = false;
        touch_triggered = false;
        PointerEvent.reset();
      }
    };

    this.bindDom(element, Hammer.EVENT_TYPES[eventType], bindDomOnTouch);

    // return the bound function to be able to unbind it later
    return bindDomOnTouch;
  },


  /**
   * we have different events for each device/browser
   * determine what we need and set them in the Hammer.EVENT_TYPES constant
   */
  determineEventTypes: function determineEventTypes() {
    // determine the eventtype we want to set
    var types;

    // pointerEvents magic
    if(Hammer.HAS_POINTEREVENTS) {
      types = PointerEvent.getEvents();
    }
    // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
    else if(Hammer.NO_MOUSEEVENTS) {
      types = [
        'touchstart',
        'touchmove',
        'touchend touchcancel'];
    }
    // for non pointer events browsers and mixed browsers,
    // like chrome on windows8 touch laptop
    else {
      types = [
        'touchstart mousedown',
        'touchmove mousemove',
        'touchend touchcancel mouseup'];
    }

    Hammer.EVENT_TYPES[EVENT_START] = types[0];
    Hammer.EVENT_TYPES[EVENT_MOVE] = types[1];
    Hammer.EVENT_TYPES[EVENT_END] = types[2];
  },


  /**
   * create touchlist depending on the event
   * @param   {Object}    ev
   * @param   {String}    eventType   used by the fakemultitouch plugin
   */
  getTouchList: function getTouchList(ev/*, eventType*/) {
    // get the fake pointerEvent touchlist
    if(Hammer.HAS_POINTEREVENTS) {
      return PointerEvent.getTouchList();
    }

    // get the touchlist
    if(ev.touches) {
      return ev.touches;
    }

    // make fake touchlist from mouse position
    ev.identifier = 1;
    return [ev];
  },


  /**
   * collect event data for Hammer js
   * @param   {HTMLElement}   element
   * @param   {String}        eventType        like EVENT_MOVE
   * @param   {Object}        eventData
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = POINTER_TOUCH;
    if(ev.type.match(/mouse/) || PointerEvent.matchType(POINTER_MOUSE, ev)) {
      pointerType = POINTER_MOUSE;
    }

    return {
      center     : Utils.getCenter(touches),
      timeStamp  : new Date().getTime(),
      target     : ev.target,
      touches    : touches,
      eventType  : eventType,
      pointerType: pointerType,
      srcEvent   : ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function() {
        if(this.srcEvent.preventManipulation) {
          this.srcEvent.preventManipulation();
        }

        if(this.srcEvent.preventDefault) {
          this.srcEvent.preventDefault();
        }
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function() {
        return Detection.stopDetect();
      }
    };
  }
};

var PointerEvent = Hammer.PointerEvent = {
  /**
   * holds all pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get a list of pointers
   * @returns {Array}     touchlist
   */
  getTouchList: function() {
    var touchlist = [];
    // we can use forEach since pointerEvents only is in IE10
    Utils.each(this.pointers, function(pointer){
      touchlist.push(pointer);
    });

    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param   {String}   type             EVENT_END
   * @param   {Object}   pointerEvent
   */
  updatePointer: function(type, pointerEvent) {
    if(type == EVENT_END) {
      delete this.pointers[pointerEvent.pointerId];
    }
    else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }

    // it's save to use Object.keys, since pointerEvents are only in newer browsers
    return Object.keys(this.pointers).length;
  },

  /**
   * check if ev matches pointertype
   * @param   {String}        pointerType     POINTER_MOUSE
   * @param   {PointerEvent}  ev
   */
  matchType: function(pointerType, ev) {
    if(!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType
      , types = {};

    types[POINTER_MOUSE] = (pt === POINTER_MOUSE);
    types[POINTER_TOUCH] = (pt === POINTER_TOUCH);
    types[POINTER_PEN] = (pt === POINTER_PEN);
    return types[pointerType];
  },


  /**
   * get events
   */
  getEvents: function() {
    return [
      'pointerdown MSPointerDown',
      'pointermove MSPointerMove',
      'pointerup pointercancel MSPointerUp MSPointerCancel'
    ];
  },

  /**
   * reset the list
   */
  reset: function() {
    this.pointers = {};
  }
};


var Detection = Hammer.detection = {
  // contains all registred Hammer.gestures in the correct order
  gestures: [],

  // data of the current Hammer.gesture detection session
  current : null,

  // the previous Hammer.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped : false,


  /**
   * start Hammer.gesture detection
   * @param   {Hammer.Instance}   inst
   * @param   {Object}            eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a Hammer.gesture detection on an element
    if(this.current) {
      return;
    }

    this.stopped = false;

    this.current = {
      inst              : inst, // reference to HammerInstance we're working for
      startEvent        : Utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent         : false, // last eventData
      lastVelocityEvent : false, // last eventData for velocity.
      velocity          : false, // current velocity
      name              : '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },


  /**
   * Hammer.gesture detection
   * @param   {Object}    eventData
   */
  detect: function detect(eventData) {
    if(!this.current || this.stopped) {
      return;
    }

    // console.log("Detect.numtouches : ", eventData.touches.length );

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // instance options
    var inst_options = this.current.inst.options;

    // call Hammer.gesture handlers
    Utils.each(this.gestures, function(gesture) {
      // only when the instance options have enabled this gesture
      if(!this.stopped && inst_options[gesture.name] !== false) {
        // if a handler returns false, we stop with the detection
        if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
          this.stopDetect();
          return false;
        }
      }
    }, this);

    // store as previous event event
    if(this.current) {
      this.current.lastEvent = eventData;
    }

    // endevent, but not the last touch, so dont stop
    if(eventData.eventType == EVENT_END && !eventData.touches.length - 1) {
      this.stopDetect();
    }

    return eventData;
  },


  /**
   * clear the Hammer.gesture vars
   * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
   * to stop other Hammer.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Utils.extend({}, this.current);

    // reset the current
    this.current = null;

    // stopped!
    this.stopped = true;
  },


  /**
   * extend eventData for Hammer.gestures
   * @param   {Object}   ev
   * @returns {Object}   ev
   */
  extendEventData: function extendEventData(ev) {
    var cur = this.current
      , startEv = cur.startEvent;

    // if the touches change, set the new touches over the startEvent touches
    // this because touchevents don't have all the touches on touchstart, or the
    // user must place his fingers at the EXACT same time on the screen, which is not realistic
    // but, sometimes it happens that both fingers are touching at the EXACT same time
    if(ev.touches.length != startEv.touches.length || ev.touches === startEv.touches) {
      // extend 1 level deep to get the touchlist with the touch objects
      startEv.touches = [];
      Utils.each(ev.touches, function(touch) {
        startEv.touches.push(Utils.extend({}, touch));
      });
    }

    var delta_time = ev.timeStamp - startEv.timeStamp
      , delta_x = ev.center.pageX - startEv.center.pageX
      , delta_y = ev.center.pageY - startEv.center.pageY
      , interimAngle
      , interimDirection
      , velocityEv = cur.lastVelocityEvent
      , velocity = cur.velocity;

    // calculate velocity every x ms
    if (velocityEv && ev.timeStamp - velocityEv.timeStamp > Hammer.UPDATE_VELOCITY_INTERVAL) {
        velocity = Utils.getVelocity(ev.timeStamp - velocityEv.timeStamp,
                                            ev.center.pageX - velocityEv.center.pageX,
                                            ev.center.pageY - velocityEv.center.pageY);

        cur.lastVelocityEvent = ev;
        cur.velocity = velocity;
    }
    else if(!cur.velocity) {
        velocity = Utils.getVelocity(delta_time, delta_x, delta_y);

        cur.lastVelocityEvent = ev;
        cur.velocity = velocity;
    }

    // end events (e.g. dragend) don't have useful values for interimDirection & interimAngle
    // because the previous event has exactly the same coordinates
    // so for end events, take the previous values of interimDirection & interimAngle
    // instead of recalculating them and getting a spurious '0'
    if(ev.eventType == EVENT_END) {
      interimAngle = cur.lastEvent && cur.lastEvent.interimAngle;
      interimDirection = cur.lastEvent && cur.lastEvent.interimDirection;
    }
    else {
      interimAngle = cur.lastEvent &&
        Utils.getAngle(cur.lastEvent.center, ev.center);
      interimDirection = cur.lastEvent &&
        Utils.getDirection(cur.lastEvent.center, ev.center);
    }

    Utils.extend(ev, {
      deltaTime: delta_time,

      deltaX: delta_x,
      deltaY: delta_y,

      velocityX: velocity.x,
      velocityY: velocity.y,

      distance: Utils.getDistance(startEv.center, ev.center),

      angle: Utils.getAngle(startEv.center, ev.center),
      interimAngle: interimAngle,

      direction: Utils.getDirection(startEv.center, ev.center),
      interimDirection: interimDirection,

      scale: Utils.getScale(startEv.touches, ev.touches),
      rotation: Utils.getRotation(startEv.touches, ev.touches),

      startEvent: startEv
    });

    return ev;
  },


  /**
   * register new gesture
   * @param   {Object}    gesture object, see gestures.js for documentation
   * @returns {Array}     gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if(options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend Hammer default options with the Hammer.gesture options
    Utils.extend(Hammer.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add Hammer.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function(a, b) {
      if(a.index < b.index) { return -1; }
      if(a.index > b.index) { return 1; }
      return 0;
    });

    return this.gestures;
  }
};


/**
 * Drag
 * Move with x fingers (default 1) around on the page. Blocking the scrolling when
 * moving left and right is a good practice. When all the drag events are blocking
 * you disable scrolling on that area.
 * @events  drag, drapleft, dragright, dragup, dragdown
 */
Hammer.gestures.Drag = {
  name     : 'drag',
  index    : 50,
  defaults : {
    drag_min_distance            : 10,

    // Set correct_for_drag_min_distance to true to make the starting point of the drag
    // be calculated from where the drag was triggered, not from where the touch started.
    // Useful to avoid a jerk-starting drag, which can make fine-adjustments
    // through dragging difficult, and be visually unappealing.
    correct_for_drag_min_distance: true,

    // set 0 for unlimited, but this can conflict with transform
    drag_max_touches             : 1,

    // prevent default browser behavior when dragging occurs
    // be careful with it, it makes the element a blocking element
    // when you are using the drag gesture, it is a good practice to set this true
    drag_block_horizontal        : false,
    drag_block_vertical          : false,

    // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
    // It disallows vertical directions if the initial direction was horizontal, and vice versa.
    drag_lock_to_axis            : false,

    // drag lock only kicks in when distance > drag_lock_min_distance
    // This way, locking occurs only when the distance has become large enough to reliably determine the direction
    drag_lock_min_distance       : 25
  },

  triggered: false,
  handler  : function dragGesture(ev, inst) {
    // current gesture isnt drag, but dragged is true
    // this means an other gesture is busy. now call dragend
    if(Detection.current.name != this.name && this.triggered) {
      inst.trigger(this.name + 'end', ev);
      this.triggered = false;
      return;
    }

    // max touches
    if(inst.options.drag_max_touches > 0 &&
      ev.touches.length > inst.options.drag_max_touches) {
      return;
    }

    switch(ev.eventType) {
      case EVENT_START:
        this.triggered = false;
        break;

      case EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if(ev.distance < inst.options.drag_min_distance &&
          Detection.current.name != this.name) {
          return;
        }

        // we are dragging!
        if(Detection.current.name != this.name) {
          Detection.current.name = this.name;
          if(inst.options.correct_for_drag_min_distance && ev.distance > 0) {
            // When a drag is triggered, set the event center to drag_min_distance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at drag_min_distance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
            Detection.current.startEvent.center.pageX += ev.deltaX * factor;
            Detection.current.startEvent.center.pageY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if(Detection.current.lastEvent.drag_locked_to_axis ||
            ( inst.options.drag_lock_to_axis &&
              inst.options.drag_lock_min_distance <= ev.distance
            )) {
          ev.drag_locked_to_axis = true;
        }
        var last_direction = Detection.current.lastEvent.direction;
        if(ev.drag_locked_to_axis && last_direction !== ev.direction) {
          // keep direction on the axis that the drag gesture started on
          if(Utils.isVertical(last_direction)) {
            ev.direction = (ev.deltaY < 0) ? DIRECTION_UP : DIRECTION_DOWN;
          }
          else {
            ev.direction = (ev.deltaX < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if(!this.triggered) {
          inst.trigger(this.name + 'start', ev);
          this.triggered = true;
        }

        // trigger events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);

        var is_vertical = Utils.isVertical(ev.direction);

        // block the browser events
        if((inst.options.drag_block_vertical && is_vertical) ||
          (inst.options.drag_block_horizontal && !is_vertical)) {
          ev.preventDefault();
        }
        break;

      case EVENT_END:
        // trigger dragend
        if(this.triggered) {
          inst.trigger(this.name + 'end', ev);
        }

        this.triggered = false;
        break;
    }
  }
};

/**
 * Hold
 * Touch stays at the same place for x time
 * @events  hold
 */
Hammer.gestures.Hold = {
  name    : 'hold',
  index   : 10,
  defaults: {
    hold_timeout  : 500,
    hold_threshold: 1
  },
  timer   : null,

  handler : function holdGesture(ev, inst) {
    switch(ev.eventType) {
      case EVENT_START:
        // clear any running timers
        clearTimeout(this.timer);

        // set the gesture so we can check in the timeout if it still is
        Detection.current.name = this.name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        this.timer = setTimeout(function() {
          if(Detection.current.name == 'hold') {
            inst.trigger('hold', ev);
          }
        }, inst.options.hold_timeout);
        break;

      // when you move or end we clear the timer
      case EVENT_MOVE:
        if(ev.distance > inst.options.hold_threshold) {
          clearTimeout(this.timer);
        }
        break;

      case EVENT_END:
        clearTimeout(this.timer);
        break;
    }
  }
};

/**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 */
Hammer.gestures.Release = {
  name   : 'release',
  index  : Infinity,
  handler: function releaseGesture(ev, inst) {
    if(ev.eventType == EVENT_END) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * Swipe
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set prevent_default (on the drag gesture) to true
 * @events  swipe, swipeleft, swiperight, swipeup, swipedown
 */
Hammer.gestures.Swipe = {
  name    : 'swipe',
  index   : 40,
  defaults: {
    swipe_min_touches: 1,
    swipe_max_touches: 1,
    swipe_velocity   : 0.7
  },
  handler : function swipeGesture(ev, inst) {
    if(ev.eventType == EVENT_END) {
      // max touches
      if(ev.touches.length < inst.options.swipe_min_touches ||
        ev.touches.length > inst.options.swipe_max_touches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if(ev.velocityX > inst.options.swipe_velocity ||
        ev.velocityY > inst.options.swipe_velocity) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * Tap/DoubleTap
 * Quick touch at a place or double at the same place
 * @events  tap, doubletap
 */
Hammer.gestures.Tap = {
  name    : 'tap',
  index   : 100,
  defaults: {
    tap_max_touchtime : 250,
    tap_max_distance  : 10,
    tap_always        : true,
    doubletap_distance: 20,
    doubletap_interval: 300
  },

  has_moved: false,

  handler : function tapGesture(ev, inst) {
    var prev, since_prev, did_doubletap;

    // reset moved state
    if(ev.eventType == EVENT_START) {
      this.has_moved = false;
    }

    // Track the distance we've moved. If it's above the max ONCE, remember that (fixes #406).
    else if(ev.eventType == EVENT_MOVE && !this.moved) {
      this.has_moved = (ev.distance > inst.options.tap_max_distance);
    }

    else if(ev.eventType == EVENT_END &&
        ev.srcEvent.type != 'touchcancel' &&
        ev.deltaTime < inst.options.tap_max_touchtime && !this.has_moved) {

      // previous gesture, for the double tap since these are two different gesture detections
      prev = Detection.previous;
      since_prev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
      did_doubletap = false;

      // check if double tap
      if(prev && prev.name == 'tap' &&
          (since_prev && since_prev < inst.options.doubletap_interval) &&
          ev.distance < inst.options.doubletap_distance) {
        inst.trigger('doubletap', ev);
        did_doubletap = true;
      }

      // do a single tap
      if(!did_doubletap || inst.options.tap_always) {
        Detection.current.name = 'tap';
        inst.trigger(Detection.current.name, ev);
      }
    }
  }
};

/**
 * Touch
 * Called as first, tells the user has touched the screen
 * @events  touch
 */
Hammer.gestures.Touch = {
  name    : 'touch',
  index   : -Infinity,
  defaults: {
    // call preventDefault at touchstart, and makes the element blocking by
    // disabling the scrolling of the page, but it improves gestures like
    // transforming and dragging.
    // be careful with using this, it can be very annoying for users to be stuck
    // on the page
    prevent_default    : false,

    // disable mouse events, so only touch (or pen!) input triggers events
    prevent_mouseevents: false
  },
  handler : function touchGesture(ev, inst) {
    if(inst.options.prevent_mouseevents &&
        ev.pointerType == POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if(inst.options.prevent_default) {
      ev.preventDefault();
    }

    if(ev.eventType == EVENT_START) {
      inst.trigger(this.name, ev);
    }
  }
};


/**
 * Transform
 * User want to scale or rotate with 2 fingers
 * @events  transform, pinch, pinchin, pinchout, rotate
 */
Hammer.gestures.Transform = {
  name     : 'transform',
  index    : 45,
  defaults : {
    // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
    transform_min_scale      : 0.01,
    // rotation in degrees
    transform_min_rotation   : 1,
    // prevent default browser behavior when two touches are on the screen
    // but it makes the element a blocking element
    // when you are using the transform gesture, it is a good practice to set this true
    transform_always_block   : false,
    // ensures that all touches occurred within the instance element
    transform_within_instance: false
  },

  triggered: false,

  handler  : function transformGesture(ev, inst) {
    // current gesture isnt drag, but dragged is true
    // this means an other gesture is busy. now call dragend
    if(Detection.current.name != this.name && this.triggered) {
      inst.trigger(this.name + 'end', ev);
      this.triggered = false;
      return;
    }

    // at least multitouch
    if(ev.touches.length < 2) {
      return;
    }

    // prevent default when two fingers are on the screen
    if(inst.options.transform_always_block) {
      ev.preventDefault();
    }

    // check if all touches occurred within the instance element
    if(inst.options.transform_within_instance) {
      for(var i=-1; ev.touches[++i];) {
        if(!Utils.hasParent(ev.touches[i].target, inst.element)) {
          return;
        }
      }
    }

    switch(ev.eventType) {
      case EVENT_START:
        this.triggered = false;
        break;

      case EVENT_MOVE:
        var scale_threshold = Math.abs(1 - ev.scale);
        var rotation_threshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if(scale_threshold < inst.options.transform_min_scale &&
          rotation_threshold < inst.options.transform_min_rotation) {
          return;
        }

        // we are transforming!
        Detection.current.name = this.name;

        // first time, trigger dragstart event
        if(!this.triggered) {
          inst.trigger(this.name + 'start', ev);
          this.triggered = true;
        }

        inst.trigger(this.name, ev); // basic transform event

        // trigger rotate event
        if(rotation_threshold > inst.options.transform_min_rotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if(scale_threshold > inst.options.transform_min_scale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + (ev.scale<1 ? 'in' : 'out'), ev);
        }
        break;

      case EVENT_END:
        // trigger dragend
        if(this.triggered) {
          inst.trigger(this.name + 'end', ev);
        }

        this.triggered = false;
        break;
    }
  }
};

// AMD export
if(typeof define == 'function' && define.amd) {
  define(function(){
    return Hammer;
  });
}
// commonjs export
else if(typeof module == 'object' && module.exports) {
  module.exports = Hammer;
}
// browser export
else {
  window.Hammer = Hammer;
}

})(window);


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/lib/pxfvt.js: */

/**************************************************
PXF.js Folder Gather/Compiler

Built on Monday 05. May 14
This file is automatically generated from source bundle
Single and multi-line comments have been removed. 

Copyright 2011-2012 pixelfolders (PXF) 
Visit our website at www.pixelfolders.se for more projects
Or contact us at contact@pixelfolders.se 

LICENSE?
*************************************************/

/* SOURCE C:\Users\Meindbender\Documents\masterthesis\newrepos\pxfvt\src/VT.js: */

////////////////////////
// Global namespace VT
VT = {};

/////////////////////////
// Different cache modes, used in conf
VT.CACHE_MODES = {
	CUBE              : 0,
	FLAT              : 1,
	FLAT_WITH_PARENTS : 2,
	FLAT_MIPMAPPED    : 3
};

VT.CACHE_MODES_STRING = {
	"cube" : VT.CACHE_MODES.CUBE,
	"flat" : VT.CACHE_MODES.FLAT,
	"flat_with_parents" : VT.CACHE_MODES.FLAT_WITH_PARENTS,
	"flat_mipmapped" : VT.CACHE_MODES.FLAT_MIPMAPPED
},

VT.VirtualTexture = function( ctx, config ) {
	/////////////////////
	// VT
	this.ctx 	= ctx;
	this.gl 	= ctx.gl;
	this.frame 	= 0;

	//extend( config, config.scene );
	this.config 			= {};
	extend( this.config, this.defaultConfig );
	extend( this.config, config );

	if ( typeof(this.config.cache_mode) == "string" )
	{
		this.config.cache_mode = VT.CACHE_MODES_STRING[this.config.cache_mode];
	}

	this.config.pageAmount 	= this.config.textureSize / this.config.pageSize;
	this.config.mipmaps 	= Math.log(this.config.pageAmount) / Math.log(2) + 1;

	this.CheckCompability();

	this.__mipSizes   = [];
	this.__mipOffsets = [];

	var accum 	= 0;
	var saccum 	= 1;

	for (var i = 0; i < this.config.mipmaps; i++) {
		this.__mipSizes.unshift(saccum);
		saccum *= 2;
	};

	for (var i = 0; i < this.config.mipmaps+1; i++) {
		this.__mipOffsets[i] 	= accum;// + (this.__mipSizes[i] * this.__mipSizes[i]);
		this.totalAmountOfPages = accum;
		accum 				   += (this.__mipSizes[i] * this.__mipSizes[i]);
	};
	console.log("this.totalAmountOfPages:", this.totalAmountOfPages);

	this.prof_preframe = false;
	this.prof_debug = false;

	/////////////////////
	// Preframe function queue
	// keep track of preframe functions and frame allocations
	this.preframeQueue             = []; // { "func" : funccallback, "frameAlloc" : number, "frames" : number }
	this.cameraupdate 		       = true;

	this.pageDetermInterval        = 60;
	this.pageDetermIntervalCounter = this.pageDetermInterval;

	/////////////////////
	// VT web worker pool
	this.workerCount 	= this.config.workerCount;
	this.workers 		= {};
	this.pdWorker       = undefined;

	/////////////////////
	// Page Determination
	this.pageDeterminationTexture 	= undefined;
	this.pageDeterminationFBO 		= undefined;
	this.pageDeterminationShader 	= undefined;
	this.pdDirtyBuffer              = false;
	this.needPageDeterm = true;


	/////////////////////
	// Page Cache
	this.pageCacheTexture        = undefined;
	this.pageCacheWaitForParents = false;
	this.pageCacheAutoPurgeCPU   = false;

	/////////////////////
	// Indirection Table
	this.indirectTexture 	= undefined;
	this.indirectTable 	    = undefined;
	this.indirectTableDirty = false;
	this.indirectTableDirtyLevel = 0;

	// debug timing
	this.last_preframe = Date.now();

	/////////////////////
	// Pages needed by last frame check
	this.neededPages 		= [];
	this.neededPagesNow 	= [];
	//this.incomingPages = [];
	this.incomingPagesDict 	= {};
	this.finishedPages 		= [];
	this.analyzedPageList 	= false;
	this.receivedPages      = [];
	this.levelDiffLUT       = [];

	/////////////////////
	// Mipmap lookup texture
	this.mipmapLUTTexture 	= undefined;

	this.pageRenderWidth 	= this.config.pageSize * this.config.pageColumns,
	this.pageRenderHeight 	= this.config.pageSize * this.config.pageRows;

	this.Build();
}

///////////////////////
// Standard VT Settings
VT.VirtualTexture.prototype.defaultConfig = {
	pageSize 		 		: 128,
	pageDeterminationRatio 	: 1.0 / 8.0,
	pageCacheSizeX 	 		: 16,
	pageCacheSizeY 	 		: 16,
	shaderSourcePath 		: "./",
	blendFormat             : 6406, // gl.alpha 
	indirectTableLayout		: 1,
	requestPagesMax 		: 100,

	pageDetermMode 			: "dynamic", // "grid" || "dynamic"
	imageWorker 			: "worker", // "proxy" || "worker"

	//imagePath 		 		: "./",
	imageFormat 	 		: "dds",
	mipBias 		 		: 0.0, // constant adjust of mip level. if negative -> results in texture aliasing (underblur artifacts)
	blendSpeed 		 		: 0.01,
	numPageCaches			: 2,
	borderSize              : 0,
	pageColumns				: 1, 	// 2 for normal mapping
	pageRows 				: 1,
	workerCount 			: 7
}

VT.VirtualTexture.prototype.CheckCompability = function() {
	if ( !this.config ) return;

	var config = this.config;

	var widthSize 			= config.pageCacheSizeX * config.pageSize * config.pageColumns;
	var heightSize 			= config.pageCacheSizeY * config.pageSize * config.pageRows;

	var maxTextureSize;
	var maxSideSize 		= Math.max( widthSize,heightSize );

	if (this.config.cache_mode == VT.CACHE_MODES.CUBE)
	{
		// check max cubemap side size
		maxTextureSize = this.ctx.GetMaxCubeMapTextureSize();

	} else if ( this.config.cache_mode == VT.CACHE_MODES.FLAT ||
		this.config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS ||
		this.config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED ) {
		// check max texture size
		maxTextureSize = this.ctx.GetMaxTextureSize();

	} else {
		console.error("Unknown config.cache_mode used in VT.CheckCompability().");
		return;
	}

	if ( maxSideSize > maxTextureSize ) {
		config.pageCacheSizeX = (maxTextureSize / config.pageSize) / config.pageColumns;
		config.pageCacheSizeY = (maxTextureSize / config.pageSize) / config.pageRows;
	}

	// check DXT support
	if ( config.imageFormat == "dds" && !PXF.CheckDXTSupport() ) {
		config.imageFormat = "PNG";
	}

	// Safari fix
	if (BrowserDetect.browser == "Safari")
	{

		PXF.Texture.prototype._Upload = PXF.Texture.prototype.Upload;
		PXF.Texture.prototype.Upload = function(data, w, h, mipmap)
		{
			data = data != null ? data : w*h*this.bpp;

			if (this.dataType == gl.FLOAT)
			{
				return this._Upload(new Float32Array(data), w, h, mipmap);
			} else {
				return this._Upload(new Uint8Array(data), w, h, mipmap);
			}
		};

		PXF.Texture.prototype._UploadSub = PXF.Texture.prototype.UploadSub;
		PXF.Texture.prototype.UploadSub = function(data, x, y, w, h, mipmap)
		{
			data = data != null ? data : w*h*this.bpp
			if (this.dataType == gl.FLOAT)
			{
				return this._UploadSub(new Float32Array(data), x, y, w, h, mipmap);
			} else {
				return this._UploadSub(new Uint8Array(data), x, y, w, h, mipmap);
			}
		};
	}
}

VT.VirtualTexture.prototype.Resize = function() {
	// update page determ texture
	//////////////////////////////
	this.ResizePageDetermination();
};

VT.VirtualTexture.prototype.Destroy = function() {
	delete this.neededPages;
	delete this.neededPagesNow;
	delete this.incomingPagesDict;
	delete this.finishedPages;
	delete this.pageCacheList;
	delete this.pageCacheIndexArray;
	delete this.pageCacheCellPointer;
	delete this.replaceQueue;
	delete this.cpuCache;

	for (var i = 0; i < this.workers.length; i++) {
		this.workers[i].close && this.workers[i].close();
		this.workers[i].terminate && this.workers[i].terminate();
		this.workers[i] = undefined;
	};
}

VT.VirtualTexture.prototype.Build = function() {
	var gl = this.gl;

	// build sub-modules
	this.BuildPageDetermination();
	this.BuildPageCache();
	this.BuildIndirectionTable();

	// create mipmap look up table
	var params 				= { minFilter : gl.LINEAR_MIPMAP_LINEAR, 
								magFilter : gl.NEAREST,
								autoGenerateMipmaps : false };
	this.mipmapLUTTexture 	= (new PXF.Texture( this.ctx, null, params )).Upload( null, this.config.pageAmount, this.config.pageAmount );

	for ( var i=this.config.mipmaps-1; i >= 0; i--) {

		var size  = this.__mipSizes[i];    // Math.max(1, Math.floor(256.0 / (Math.pow(2,mm)) ));
		
		var pixelData = new Uint8Array(size*size*4);
		for (var p = 0; p < size * size * 4; p+=1)
		{
			pixelData[p] = i;
		}

		this.mipmapLUTTexture.Upload( pixelData, size, size, i );
	}

	// fill level diff lut
	for (var i = 0; i < this.totalAmountOfPages; i++) {
		this.levelDiffLUT.push(0);
		// this.levelDiffLUT[i] = 0;
	};

	// cant clone ext object to worker
	// todo: copy contents from s3 obj instead?
	var s3extObj = {
		COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
		COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
		COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
		COMPRESSED_RGB_S3TC_DXT1_EXT: 33776
	};

	// create web workers
	this.workerconf = {
			"pageSize" : this.config.pageSize,
			"pageColumns" : this.config.pageColumns,
			"pageRows" : this.config.pageRows,
			"__mipSizes" : this.__mipSizes, 
			"__mipOffsets" : this.__mipOffsets,
			"imagePath" : this.config.content,
			"s3ext" : s3extObj,
			"format" : this.config.imageFormat };

	for (var i = 0; i < this.workerCount; ++i)
	{
		var w;

		if ( this.config.imageWorker == "proxy" )
		{
			w 		= this.ProxyWorker();
		} else {
			w 		= new Worker("./static/js/vtworker.js");
		}

		w.vt 	= this;
		w.id 	= i;
		w.onerror = function (e) {
			console.log("Web Worker error: ", e);
			this.ready = true;
		};

		w.postMessage({"msgType" : "config", "data" : this.workerconf } );
		w.onmessage = function(e) { return this.vt.WorkerMessage(e, this); };

		this.workers[i] = w;
	};

	
	this.BuildPageDeterminationWorker();

	this._BuildVTShader();	

	this.preframeQueue = [];

	this.__awaitLockedPreload = [];

	// preload pages 
	if ( this.config.preload ) {
		for( var p in this.config.preload ) 
			this.PreloadPage.apply( this, this.config.preload[p] );
	}
}

VT.VirtualTexture.prototype.generatePageList = function( mip_lvl, force )
{
	for (var i = this.config.mipmaps-1; i >= mip_lvl; i--) {
		
		for (var y = 0; y < this.__mipSizes[i]; y++) {
			for (var x = 0; x < this.__mipSizes[i]; x++) {
				console.log("[ " + x + ", " + y + ", " + i + ", " + (force ? "true" : "false") + "],");
			};
		};
	};
};

VT.VirtualTexture.prototype.PreloadPage = function( x, y, mm, lock ) {
	// calculate index
	var index 				= this.__mipOffsets[mm] + y * this.__mipSizes[mm] + x;
	var newRequest 			= {};
		newRequest.hit 		= this.frame;
		newRequest.index 	= index;
		newRequest.miplvl 	= mm;
		newRequest.x 		= x;
		newRequest.y 		= y;
		newRequest.force    = true;
		if (lock)
			newRequest.lock = 1;
		newRequest.url 		= this.GetUrlFromPage( newRequest );

	// reqest page in worker
	if (!this.SendWorkerMessage( "pageRequest", [newRequest], true ))
	{
		console.error("Woah, could not send pre load page request!!");
	} else {
		//console.log("Beam: ", newRequest);
		this.incomingPagesDict[ newRequest.index ] = true;
	}
} 

VT.VirtualTexture.prototype.CheckIncoming = function( index )
{
	return !!this.incomingPagesDict[ index ];
}


VT.VirtualTexture.prototype.GenerateVirtualTextureShaderHeader = function() {


	var lines = [];
	lines.push("precision highp float;");

	if ( this.ctx.extensions["OES_standard_derivatives"] ) lines.push("#extension GL_OES_standard_derivatives : enable");

	lines.push("#define BORDER_SIZE " + ( this.config.borderSize ).toFixed(1) );
	lines.push("// page cache offset is used when sampling the blending texture");
	lines.push("#define CACHE_OFFSET " + ( this.config.pageCacheSizeY / (this.config.pageCacheSizeY * this.config.numPageCaches)).toFixed(12) );
	lines.push("// number of cache pages in x,y dim")
	lines.push("const vec2 phys_tex_dimension_pages = vec2(" + this.config.pageCacheSizeX.toFixed(1) + ", " + this.config.pageCacheSizeY.toFixed(1) + ");");
	lines.push("// size of one page in x,y dim")
	lines.push("const float page_dimension = " + this.config.pageSize.toFixed(1) + ";");
	lines.push("const float mipmaps = " + (this.config.mipmaps - 1).toFixed(1) + ";");
	lines.push("const float vt_dimension = " + this.config.textureSize.toFixed(1) + ";");
	lines.push("float inv_page_dimension = " + 1.0 / this.config.pageSize + ";");
	lines.push("float page_dimension_log2 = " + (Math.log(this.config.pageSize)/Math.log(2)).toFixed(1) + ";");
	// lines.push("const float mip_bias = " + this.config.mipBias.toFixed(1) + ";");
	lines.push("uniform float mip_bias;");
	lines.push("");

	if ( this.config.enable_trilinear_vt )
	{
		lines.push("#define ENABLE_TRILINEAR_VT 1");
	} else {
		lines.push("#define ENABLE_TRILINEAR_VT 0");
	}

	if ( this.indirectTableLayout == INDIRECT_LAYOUT_FLAT )
	{
		lines.push("#define INDIRECT_MODE 1");
		lines.push("float get_y_offset(int mm) {");
		lines.push("float indirect_y_offset_lut[" + this.__flatOffsets.length + "];");
		lines.push("float offset = 0.0;");

		for ( var k in this.__flatOffsets )
		{
			var offset = this.__flatOffsets[k];
			lines.push("indirect_y_offset_lut[" + k + "] = " + this.__flatOffsets[k].toFixed(1) +";");
		};

		for ( var mm=2;mm < this.__flatOffsets.length; mm++ )
		{
			if ( mm == 2 )
				lines.push("if ( mm == " + mm + ") return indirect_y_offset_lut[" + mm + "];");
			else lines.push("else if ( mm == " + mm + ") return indirect_y_offset_lut[" + mm + "];");
		}


		lines.push("return offset;");
		lines.push("}");
	} else lines.push("#define INDIRECT_MODE 0");

    lines.push("#define CACHE_MODE " + this.config.cache_mode);

	if (this.config.cache_mode == VT.CACHE_MODES.CUBE)
    {
    	lines.push("#define CACHE_COUNT " + this.pageCacheList.length);
        lines.push("uniform samplerCube pageCache;");

    } else if (this.config.cache_mode == VT.CACHE_MODES.FLAT || this.config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED) {
        
        // lines.push("#define CACHE_MODE 1");
        lines.push("#define CACHE_COUNT " + this.pageCacheList.length);

        for (var i = 0; i < this.pageCacheList.length; i++) {
            lines.push("uniform sampler2D pageCache_" + i + ";");
        };

    } else if (this.config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS) {
        
        // lines.push("#define CACHE_MODE 2");
        lines.push("#define CACHE_COUNT " + this.pageCacheList.length);

        for (var i = 0; i < this.pageCacheList.length; i++) {
            lines.push("uniform sampler2D pageCache_" + i + ";");
            lines.push("uniform sampler2D pageCache_parents_" + i + ";");
        };

    }

    if (this.config.use_blending_texture)
    {
    	lines.push("#define PACKED_BLENDING 0");
    } else {
    	lines.push("#define PACKED_BLENDING 1");
    }

    lines.push("");

	return lines.join("\n");
}

VT.VirtualTexture.prototype._BuildVTShader = function() {
	///////////////////
	// build VT shader
	var vsUrl 		= this.config.shaderSourcePath + "VT.VirtualTexture.vs";
	var fsUrl 		= this.config.shaderSourcePath + "VT.VirtualTexture.fs";

	var vsData 		= PXF.LoadRawFile( vsUrl );
	var fsData 		= this.GenerateVirtualTextureShaderHeader() + PXF.LoadRawFile( fsUrl );

	this.vtShader 	= new PXF.Shader( this.ctx, vsData, fsData );

	this.GeneratePageDeterminationShader();
	if ( this.config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS || this.config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED )
	{
		this.GenerateParentCacheShader();
	}
}

VT.VirtualTexture.prototype.Bind = function(aux) {
	this.vtShader.Bind();

	this.vtShader.SetUniform( "mip_bias", this.config.mipBias );

	var bind_unit_id = 0;
	this.indirectTexture.Bind(  this.vtShader, "indirectTable",    bind_unit_id++);
	if ( !this.config.disable_blending && this.config.use_blending_texture) {
		this.blendingTexture.Bind(  this.vtShader, "blendingTexture",  bind_unit_id++);
	}
	this.mipmapLUTTexture.Bind( this.vtShader, "mipmapLUTTexture", bind_unit_id++);

	if (this.config.cache_mode == VT.CACHE_MODES.CUBE)
	{
		this.cacheTexture.Bind( this.vtShader, "pageCache", bind_unit_id++);

	} else if (this.config.cache_mode == VT.CACHE_MODES.FLAT || this.config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED) {

		for (var i = 0; i < this.pageCacheList.length; i++) {
			this.pageCacheList[i].cacheTexture.Bind( this.vtShader, "pageCache_" + i, bind_unit_id++);
		};

	} else if (this.config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS) {

		for (var i = 0; i < this.pageCacheList.length; i++) {
			this.pageCacheList[i].cacheTexture.Bind( this.vtShader, "pageCache_" + i, bind_unit_id++);
			this.pageCacheList[i].cacheTextureParents.Bind( this.vtShader, "pageCache_parents_" + i, bind_unit_id++);
		};

	}

	/*
	if (!conf.disable_reflection)
	{
		reflection.materialLUTTexture.Bind(    this.vtShader, "materialLUTTexture",   4);
	}*/

	return this.vtShader;
}

VT.VirtualTexture.prototype.Unbind = function() {
	this.mipmapLUTTexture.Unbind();
	if ( !this.config.disable_blending && this.config.use_blending_texture) {
		this.blendingTexture.Unbind();
	}
	this.indirectTexture.Unbind();

	if (this.config.cache_mode == VT.CACHE_MODES.CUBE)
	{
		this.cacheTexture.Unbind();

	} else if (this.config.cache_mode == VT.CACHE_MODES.FLAT || this.config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED) {

		for (var i = 0; i < this.pageCacheList.length; i++) {
			this.pageCacheList[i].cacheTexture.Unbind();
		};

	} else if (this.config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS) {

		for (var i = 0; i < this.pageCacheList.length; i++) {
			this.pageCacheList[i].cacheTexture.Unbind();
			this.pageCacheList[i].cacheTextureParents.Unbind();
		};

	}

	this.vtShader.Unbind();
}

VT.VirtualTexture.prototype.PreFrame = function( scene, camera, cameraupdate ) {

	this.frame++;
	this.timestamp = Date.now();

	if (this.cacheCellUnderflow)
	{
		// decrease bias
		this.config.mipBias = this.config.mipBias + 0.1;
		console.log("lowering bias to:", this.config.mipBias);
		this.cacheCellUnderflow = false;

	}

	this.debugPageRequestReceived = 0;
	if (this.debugReceivedPage)
	{
		this.debugReceivedPage = false;
		return !(this.__awaitLockedPreload.length > 0);
	}
	this.debugReceivedPage = false;

	this.debugProcessReceivedTime = 0;
	if (this.receivedPages.length > 0)
	{
		var poop = Date.now();
		this._ProcessReceivedPages();
		//gl.finish();
		this.debugProcessReceivedTime = Date.now() - poop;
		// return !(this.__awaitLockedPreload.length > 0);
	}

	if (this.prof_preframe)
    {
        this.prof_timer = Date.now();
    }

	// DEBUG: count number of page requests in one second
	// if ( this.debugPageRequestTime == undefined || this.debugPageRequestTime <= this.timestamp)
	{
		// console.log("Page requests sent: " + this.debugPageRequestSent + ", received: " + this.debugPageRequestReceived + " (CPU received: " + this.debugPageRequestCPUReceive + ")");
		this.debugPageRequestSent = 0;
		this.debugPageRequestReceived = 0;
		this.debugPageRequestCPUReceive = 0;
		this.debugPageRequestTime = this.timestamp + 1000.0;
	}

	// keep track if the camera has moved/updated since last preframe
	if (cameraupdate != undefined)
		this.cameraupdate = cameraupdate;
	else
		this.cameraupdate = true;


	if (true || this.cameraupdate == true)
	{
		// camera has moved so we need better page determination
		//this.needPageDeterm = true; // moving this to worker signal (when sort is done etc)

		// reset the "cube map camera" queue since the camera has moved
		this.pageDeterminationState.cameraTodo = this.pageDeterminationState.cameraCube.slice();
	}

	// decrease page determination counter if we need the page determination
	if (this.needPageDeterm)
	{
		this.pageDetermIntervalCounter -= 1;
	}

	var valid_readout = this.DoPageDetermination(scene, camera);

	this.debugRenderPDTime = 0;
	this.debugReadOutTime = 0;

	var do_upload = true;
	if (this.pageDetermIntervalCounter <= 2)
	{

		if (this.pageDetermIntervalCounter == 2)
		{
			//console.log("render page determ");
			// var poop = Date.now();
			// this.DoPageDetermination(scene, camera)
			// //gl.finish();
			// this.debugRenderPDTime = Date.now() - poop;
			// if (this.prof_preframe)
			// {
			// 	console.log("DoPageDetermination: ", Date.now() - this.prof_timer);
			// 	this.prof_timer = Date.now();
			// }
		} else if (this.pageDetermIntervalCounter <= 0 && valid_readout) {
			//console.log("read out determ");
			// var poop = Date.now();
			this.ReadOutPageDetermination( true );
			//gl.finish();
			// this.debugReadOutTime = Date.now() - poop;
			// if (this.prof_preframe)
			// {
			// 	console.log("ReadOutPageDetermination: ", Date.now() - this.prof_timer);
			// 	this.prof_timer = Date.now();
			// }
			do_upload = false;
			//this.pageDeterminationTextureId = 0;
		}

		/*if (this.pdDirtyBuffer && this.pageDeterminationTextureId == 3)
		{
			this.ReadOutPageDetermination( true );
			this.pageDeterminationTextureId = 0;
			do_upload = false;
		} else {
			this.DoPageDetermination(scene, camera)
		}*/

		//this.Analyze();
		//return;
		//this.pageDetermIntervalCounter = this.pageDetermInterval;
		//this.needPageDeterm = false;
	}

	// return !(this.__awaitLockedPreload.length > 0);

	this.Analyze();
	if (this.prof_preframe)
	{
		console.log("Analyze: ", Date.now() - this.prof_timer);
		this.prof_timer = Date.now();
	}

	// Always try to request new pages and upload new cache data
	if (do_upload)
	{
		var poop = Date.now();
		this.PurgeCPUCache();
		this.debugPurgeCpuTime = Date.now() - poop;
		if (this.prof_preframe)
		{
			console.log("PurgeCPUCache: ", Date.now() - this.prof_timer);
			this.prof_timer = Date.now();
		}
		var poop = Date.now();
		this.RequestPages();
		this.debugRequestPagesTime = Date.now() - poop;
		if (this.prof_preframe)
		{
			console.log("RequestPages: ", Date.now() - this.prof_timer);
			this.prof_timer = Date.now();
		}
		var poop = Date.now();
		this.UploadData();
		//gl.finish();
		this.debugUploadTime = Date.now() - poop;
		

		if (this.prof_preframe)
		{
			console.log("UploadData: ", Date.now() - this.prof_timer);
			this.prof_timer = Date.now();
		}
	}

	// Update blending every frame
	var poop = Date.now();
	this.UpdateBlending();
	this.debugUpdateBlendingTime = Date.now() - poop;
	if (this.prof_preframe)
	{
		console.log("UpdateBlending: ", Date.now() - this.prof_timer);
		this.prof_timer = Date.now();
	}
	var poop = Date.now();
	this.UploadBlendingTexture();
	//gl.finish();
	this.debugUpdateBlendTextureTime = Date.now() - poop;
	if (this.prof_preframe)
	{
		console.log("UploadBlendingTexture: ", Date.now() - this.prof_timer);
		this.prof_timer = Date.now();
	}

	// frame counter, used in page analysis too see if pages was used recently
	/*this.frame++;

	// keep track if the camera has moved/updated since last preframe
	if (cameraupdate != undefined)
		this.cameraupdate = cameraupdate;
	else
		this.cameraupdate = true;

	if (this.cameraupdate == true)
	{
		// camera has moved so we need better page determination
		this.needPageDeterm = true;

		// reset the "cube map camera" queue since the camera has moved
		this.pageDeterminationState.cameraTodo = this.pageDeterminationState.cameraCube.slice();
	}

	// decrease page determination counter if we need the page determination
	if (this.needPageDeterm)
	{
		this.pageDetermIntervalCounter -= 1;
	}

	//this.CreateReplaceOrderQueue();
	// reset replace queue to an empty queue
	// -> a new queue will then be generated if a page needs a cell
	this.replaceQueue = [];

	
	if (this.pageDetermIntervalCounter <= 0 && this.DoPageDetermination(scene, camera))
	{
		this.Analyze();
		return;
		//this.pageDetermIntervalCounter = this.pageDetermInterval;
		//this.needPageDeterm = false;
	} else {

		// do default prepage queue functions
		var f = this.preframeQueue[0];
		if (f["frame"] < f["frameAlloc"])
		{
			// run callback
			if (f["func"].apply(this, [scene, camera]))
			{
				f["frame"] += 1;
			}
		} else {

			// shift to next preframe alloc
			var n = this.preframeQueue.shift();
			n["frame"] = 0;
			this.preframeQueue.push(n);

		}

	}

	//this.pageDetermIntervalCounter -= 1;

	// update blending every frame
	this.UpdateBlending();
	this.UploadBlendingTexture();*/

	// console.log("preframe: ", (Date.now() - this.last_preframe));
	// this.last_preframe = Date.now();

	return !(this.__awaitLockedPreload.length > 0);
}


VT.VirtualTexture.prototype.ReceivePage = function(page) {

	this.receivedPages.push(page);

};

VT.VirtualTexture.prototype._ProcessReceivedPages = function() {
	//console.log("got page with prio:", page.prio);

	var _receivepages = this.receivedPages.length;

	var len = Math.min( _receivepages, this.config.receivePagesMax || _receivepages );
	// var len = this.receivedPages.length;

	for ( var i = 0; i < len; i++ )
	{

		var page = this.receivedPages.shift();

		// Prepare page 
		this.incomingPagesDict[ page.index ] = false;

		if ( this.__awaitLockedPreload.length > 0 )
		{
			var __newlist = [];

			for(var p in this.__awaitLockedPreload)
			{
				if ( this.__awaitLockedPreload[p].index != page.index )
					__newlist.push( this.__awaitLockedPreload[p] );
				// else console.log("Filtered out locked page " + page.index);
			};

			this.__awaitLockedPreload = __newlist;
		};

		// add to local cache
		//console.log(page.lock);
		if (page.lock == undefined)
		{
			this.cpuCache.pages[page.index] = page;
		}


		// check if page is already in gpu cache...
		if ( this.pageCacheIndexArray[page.index] )
		{
			continue;
			// return;
		}


		//console.log(this.pageCacheIndexArray[parent_index]);

		//if (page.miplvl < 8 && (this.pageCacheIndexArray[parent_index] == undefined || (this.pageCacheIndexArray[parent_index].cell != undefined && this.pageCacheIndexArray[parent_index].cell.alpha >= 1.0) ))
		if (page.force == undefined && this.pageCacheWaitForParents)
		{

			// check if parent is in cache and finished blending
			var parent_index = this.GetParentPageForPage(page.x, page.y, page.miplvl);

			// don't upload page to gpu cache if parent isnt there yet
			if (this.pageCacheIndexArray[parent_index] == undefined)
			{
				// console.log("No parent in cache, bro:", parent_index);
				// console.log("Missing parent");

				if (this.incomingPagesDict[ parent_index ] || this.neededPagesDict[ parent_index ] )
				{
					continue;
					//return;
				}

			} else {

				// check if parent is already in GPU cache, but still blending
				if (this.pageCacheIndexArray[parent_index].cell != undefined && this.pageCacheIndexArray[parent_index].cell.alpha < 1.0)
				{
					// console.log("Parent in GPU cache, but blending.");
					// this.pageCacheIndexArray[parent_index].cell.speed = 2.0;
					continue;
					//return;
				}

				/*if (this.incomingPagesDict[ parent_index ] || this.neededPagesDict[ parent_index ])
				{
					return;
				}*/
			}

			
		}

		page.force = undefined;
		
		// early exit if we only want this page in the CPU cache
		// if (page.prio > 0)
		// {
		// 	page.prio = 0;
		// 	continue;
		// 	// return;
		// }


		// 1. get cache cell 
		// var cell = this.GetCacheCell()[2];
		var cell = this.GetCacheCell( );
		if (cell != undefined)
		{

			cell = cell[2];

			// 4.b reset cell-alpha
			cell.alpha = 0.0;
			cell.blendState = 1;


			// 2. update cache cell with new page
			this.UpdateCacheTable( cell, page );

			// 3a. remove old page ptr from indirect table
			this.IndirectTableRemovePage( cell.index, cell.x, cell.y, cell.miplvl, cell.cacheIndex ); // todo might not need this, should be done in GetCacheCell()

			// 3b. add updated page ptr
			this.IndirectTableInsertPage( page.index, page.x, page.y, page.miplvl, cell.pc_x, cell.pc_y, page.miplvl, cell.cacheIndex );

			// 4. add to intern list 
			this.finishedPages.push( [ cell, page ] );

			// 5. add to blending lists
			page.cell = cell;
			cell.page = page;
			this.pageCacheIndexArray[page.index] = cell;
			this.blendingList.push( cell );
		} else {
			this.cacheCellUnderflow = true;
		}
	}
}



VT.VirtualTexture.prototype.UploadData = function() {

	// if (this.CheckCacheValidity()) return true; // debug: uncomment this line to check indirect table <-> cache validity

	// 1. upload indirect data to indirect texture
	this.UploadIndirectionTexture();

	// 2. upload pending pages to page cache
	var uploadPageLength = this.finishedPages.length;
	// console.log(uploadPageLength);
	var modified_caches = {};
	for(var p = 0; p < uploadPageLength; p++) {
		var cell_page = this.finishedPages.shift();

		this.UpdatePageCacheTexture( cell_page[0], cell_page[1] );

		this.uploadedSomeData = true;

		modified_caches[cell_page[0].cacheIndex] = true;
	}

	if (this.forceParentUpdate)
	{
		modified_caches = {};
		for (var i in this.pageCacheList)
		{
			modified_caches[i] = true;
		}
	}
	this.forceParentUpdate = false;

	// <-- TODO, should handle cube caches also.. -->
	// for (var i = 0; i < this.pageCacheList.length; i++)
	if ( this.config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS || this.config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED )
	{
		for (var i in modified_caches)
		{
			// generate parent texture for each page cache texture
			this.UpdateParentCache(i);

			/*var tex = this.pageCacheList[i].cacheTexture;
			tex.Bind();
			gl.generateMipmap(gl.TEXTURE_2D);
			tex.Unbind();*/
		}
	}

	return true;
}

VT.VirtualTexture.prototype.WorkerMessage = function(event, worker) {

	// e.data = { "msgType" : ..., "data" : ... }
	var msg 	= event.data;
	var msgType = msg.msgType;
	var data 	= msg.data;

	worker.ready = true;
	this.workers[worker.id].ready = true;
	if (msgType == "error") {
		console.error("Web Worker " + worker.id + " error: " + msg.data);
		//console.log("Dids me sum stuff: ", this.workers[worker.id]);
		worker.terminate();
		var w 	= new Worker("./static/js/vtworker.js");
		w.vt 	= this;
		w.id 	= worker.id;
		w.onerror = function (e) {
			console.log("Web Worker error: ", e);
			this.ready = true;
		};
		

		w.postMessage({"msgType" : "config", "data" : this.workerconf } );
		w.onmessage = function(e) { return this.vt.WorkerMessage(e, this); };
		//w.ready = true;

		this.workers[worker.id] = w;

		return;

	} else if (msgType == "log") {
		console.log("Web Worker " + worker.id + " says: " + msg.data);

 	} else if (msgType == "ready") {
		//console.log("Web Worker " + worker.id + " says: " + msg.data);

	} else if (msgType == "list") {
		this.dirtyPixels 		= true;
		this.convertBusy 		= false;
		//this.analyzedPageList 	= false;
		this.neededPages 		= data;
		//console.log("got new list: ", data.length);
		this.thrashStop         = 2;

		this.needPageDeterm = true;
		//this.Analyze();
		//console.log("got new list, size: ", data.length);

		// return, since worker aint ready to take more messages yet
		// (-> busy with page determination)
		//return;

		//console.log("New request list from: " + worker.id);
	} else if ( msgType == "requestComplete" ) {
		this.ReceivePage(data);
		this.debugReceivedPage = true;
		this.debugPageRequestReceived += 1;
	} else {
		console.info("unknown response from webworker");
	}
	
	//worker.ready = true;

	this.workers[worker.id].ready = true;
	//console.log("Are you true? ", this.workers[worker.id].ready)
;};

VT.VirtualTexture.prototype.GetWorker = function( force ) {

	//for (var w in this.workers) {
	for (var w = 0; w < this.workerCount; w++) {
		if (this.workers[w].ready) {
			this.workers[w].ready = false;
			return this.workers[w];
		}
	}

	if (force)
	{
		this.workers[0].ready = false;
		return this.workers[0];
	}
	return false;
}

VT.VirtualTexture.prototype.GetUrlFromPage = function(page) {
	var mm = "mm" + page.miplvl;
    return [this.config.pageSize,"/",
    		this.config.imageFormat,"/",
    		mm,"/",page.x,"_",page.y,"_",mm,".",
    		this.config.imageFormat].join("");
}

VT.VirtualTexture.prototype.SendWorkerMessage = function( msgType, data_list, force ) {
	var w = this.GetWorker( force );
	if (w)
	{
		for (var d in data_list)
		{
			w.postMessage({"msgType" : msgType, "data" : data_list[d] });
		}
		return true;
	} else {
		return false;
	}
	//this.GetWorker().webkitPostMessage({"msgType" : msgType, "data" : data }, transArray);
}



VT.VirtualTexture.prototype.CheckCacheValidity = function() {
	
	// var pcount = 0;
	var failed = false;
	for (var i in this.pageCacheIndexArray)
	{
		// console.log(typeof(i));
		// if (typeof(i) == "string")
		if (i != "undefined" && typeof(this.pageCacheIndexArray[i]) != "undefined")
		{
			// pcount++;
			// check indirect table
			// console.log(i);
			var c_i       = this.pageCacheIndexArray[i].index;
			var c_x       = this.pageCacheIndexArray[i].x;
			var c_y       = this.pageCacheIndexArray[i].y;
			var c_mip     = this.pageCacheIndexArray[i].miplvl;
			var c_cx      = this.pageCacheIndexArray[i].cell.pc_x;
			var c_cy      = this.pageCacheIndexArray[i].cell.pc_y;
			var c_cacheid = this.pageCacheIndexArray[i].cell.cacheIndex;

			var it_cx      = this.indirectTable[i*4];
			var it_cy      = this.indirectTable[i*4+1];
			var it_packed  = this.indirectTable[i*4+2];
			var it_mip     = Math.floor( (it_packed / 255.0) * 16.0 ); // floor(pageTableEntry.b * 16.0);
			var it_cacheid = Math.floor( (((it_packed / 255.0) * 16.0) - it_mip) * 16.0); // floor(fract(pageTableEntry.b * 16.0) * 16.0);


			if (c_cx != it_cx ||
				c_cy != it_cy ||
				c_mip != it_mip ||
				c_cacheid != it_cacheid )
			{
				console.log("Entry not valid!")
				console.log("index:", i, "x:", c_x, "y:", c_y);
				console.log("Cache and cell info:", "cx:",  c_cx, "cy:",   c_cy, "mip:",   c_mip, "cacheid:", c_cacheid );
				console.log("Indirect table info:", "cx:", it_cx , "cy:", it_cy , "mip:", it_mip , "cacheid:", it_cacheid );
				run = false;
				failed = true;
			}
		}
	}

	return failed;

	// console.log(pcount);

};


/* SOURCE C:\Users\Meindbender\Documents\masterthesis\newrepos\pxfvt\src/VT.PageDetermination.js: */

// DEPENDENCIES: /VT.js

VT.VirtualTexture.prototype.BuildPageDetermination = function()
{
	// We need to keep track of a page determination state
	// the state holds the current "cube map direction" to render
	// and a "cube map camera" direction queue
	this.pageDeterminationState = {
		cameraCube : ["F", "L", "R", "U", "D", "B"], // front, left, right, back, up, down
		cameraTodo : [],
		worker : 0,
	};
	
	if ( this.config.pageDetermMode == "grid" )
		 this.BuildPageDeterminationGrid();
	else this.BuildPageDeterminationDynamic();
}


/* SOURCE C:\Users\Meindbender\Documents\masterthesis\newrepos\pxfvt\src/VT.PageDeterminationGrid.js: */

// DEPENDENCIES: /VT.js

var __intersect

VT.VirtualTexture.prototype.BuildPageDeterminationGrid = function() {
	console.log("[/VT.PageDeterminationGrid.js:6] Building page determination shader in GRID mode");

	if ( typeof this.config.pageDetermGridData == "string" )
	{
		console.log("[/VT.PageDeterminationGrid.js:10] Loading external grid data");

		var type = getExtension(this.config.pageDetermGridData);
		var finalizeFunction = function(json) {
			console.log("[/VT.PageDeterminationGrid.js:14] Grid data loaded..", json);
			this.pageDetermGridData = json;

			var data       = this.pageDetermGridData;
		    var cells      = data.cells;
		    var resolution = data.resolution;
		    var origin     = data.origin;
		    var size       = data.size;

			this.gridCellSize = [];

			this.gridCellSize[0] = size[0] /resolution[0];
			this.gridCellSize[1] = size[1] /resolution[1];
			this.gridCellSize[2] = size[2] /resolution[2];

			this.gridCellHalfSize    = [];
			this.gridCellHalfSize[0] = this.gridCellSize[0] / 2;
			this.gridCellHalfSize[1] = this.gridCellSize[1] / 2;
			this.gridCellHalfSize[2] = this.gridCellSize[2] / 2;

			var halfVec = vec3.create( size );
	    	vec3.scale( halfVec, 0.5, halfVec );

	    	var min = vec3.create(origin);
	    	vec3.subtract( min,halfVec,min );

	    	var max = vec3.create(origin);
	    	vec3.add( max,halfVec,max );

	    	this.pageDetermGridBox = {};
	    	this.pageDetermGridBox.min = min;
	    	this.pageDetermGridBox.max = max;

		};

		if ( type == "json" )
		{
			console.log("[/VT.PageDeterminationGrid.js:51] Loading external grid data in JSON format");
			PXF.LoadJson( this.config.pageDetermGridData, finalizeFunction.bind(this));
		}

		if ( type == "bin" )
		{
			console.log("[/VT.PageDeterminationGrid.js:57] Loading external grid data in BINARY format");
			PXF.LoadBuffer( this.config.pageDetermGridData, function( buffer, args ) {
				var dv       = new DataView( buffer );
				var dvUint32 = new Uint32Array( buffer );
				var finalize = args[0].bind( this );

				console.log("Finished loading binary grid data..", buffer, buffer.byteLength );

				var json = {};
				var le   = littleEndian;
				var byteoffset = 0;

				////////////////////
				// read header
				json.origin     = vec3.create( [dv.getFloat32( 0, le ),dv.getFloat32( 4, le ),dv.getFloat32( 8, le )] );
				json.size       = vec3.create( [dv.getFloat32( 12, le ),dv.getFloat32( 16, le ),dv.getFloat32( 20, le )] );
				json.resolution = vec3.create( [dv.getUint32( 24, le ),dv.getUint32( 28, le ),dv.getUint32( 32, le )] );
				byteoffset     += 36;

				console.log("Grid Header:");
				console.log("Origin", json.origin );
				console.log("size", json.size );
				console.log("resolution", json.resolution );
				

				var sx = json.resolution[0],
					sy = json.resolution[1],
					sz = json.resolution[2];

				json.cells = [];

				// många nivåer blir det...
				for ( var x=0; x < sx; x++ )
				{
					json.cells[x] = [];

					for ( var y=0; y < sy; y++ )
					{
						json.cells[x][y] = [];
						for ( var z=0; z < sz; z++ )
						{
							json.cells[x][y][z] = [];
							for ( var s=0; s < 6; s++ )
							{

								var items  = dv.getUint32( byteoffset, le );
								byteoffset += 4; //( 1 + items ) * 4;

								var bufferstart = byteoffset / 4;
								var bufferend = bufferstart + items;
								json.cells[x][y][z][s] = dvUint32.subarray( bufferstart,bufferend );

								byteoffset += 4*items;

								// console.log( "Cell",x,y,z,s,items,bufferstart,bufferend );
							};
						}
					}
				}

				finalize( json );

			}.bind(this), [ finalizeFunction ]);
		}
	};

	this.page_determ_camera              = mat4.identity();
	this.GeneratePageDeterminationShader = this.GeneratePageDeterminationShaderGrid;
	this.DoPageDetermination 			 = this.DoPageDeterminationGrid;
	this.ResizePageDetermination 		 = function(){};
	this.BuildPageDeterminationWorker  	 = function(){};
	this.ReadOutPageDetermination 		 = function(){};
};

VT.VirtualTexture.prototype.GeneratePageDeterminationShaderGrid = function()
{

};

VT.VirtualTexture.prototype.CalculateBoxCenterFrom = function( cell, cx,cy,cz )
{
	var x = this.pageDetermGridBox.min[0] + cx * this.gridCellSize[0] + this.gridCellHalfSize[0];
	var y = this.pageDetermGridBox.min[1] + cy * this.gridCellSize[1] + this.gridCellHalfSize[1];
	var z = this.pageDetermGridBox.min[2] + cz * this.gridCellSize[2] + this.gridCellHalfSize[2];

	cell.center = vec3.create([x,y,z]);
	cell.min 	= vec3.create([ cell.center[0] - this.gridCellHalfSize[0], cell.center[1] - this.gridCellHalfSize[1],cell.center[2] - this.gridCellHalfSize[2] ]);
	cell.max 	= vec3.create([ cell.center[0] + this.gridCellHalfSize[0], cell.center[1] + this.gridCellHalfSize[1],cell.center[2] + this.gridCellHalfSize[2] ]);
	cell.index = [cx,cy,cz];
}

VT.VirtualTexture.prototype.GetGridNeighboursFrom = function( cx,cy,cz )
{
	var neighbours = [];
	var cells = this.pageDetermGridData.cells;

	var x = cx,y=cy,z=cz;

	if( cells[x] && cells[x][y] && cells[x][y][z] ) //&& ( x != 0 && y != 0 && z != 0 ) )
	{
		if (!cells[x][y][z].center)
		{
			cells[x][y][z] = {data : cells[x][y][z]}

			this.CalculateBoxCenterFrom( cells[x][y][z],x,y,z);
		}

		neighbours.push( cells[x][y][z] );
	}

	/*
	for( var x= cx-1; x<=cx+1; x++ )
	for( var y= cy-1; y<=cy+1; y++ )
	for( var z= cz-1; z<=cz+1; z++ )
	{
		if( cells[x] && cells[x][y] && cells[x][y][z] ) //&& ( x != 0 && y != 0 && z != 0 ) )
		{
			if (!cells[x][y][z].center)
			{
				cells[x][y][z] = {data : cells[x][y][z]}

				this.CalculateBoxCenterFrom( cells[x][y][z],x,y,z);
			}

			neighbours.push( cells[x][y][z] );
		}
	}; */

	return neighbours;
}


VT.VirtualTexture.prototype.CheckCacheRecidencyFromGridCell = function( x,y,z ) 
{
	var cell_neighbours = this.GetGridNeighboursFrom(x,y,z);

	var recidency_count = 0;
	var recidency_max = 0;

	var unique_indices = {};
	var total_count = this.CellPageCount();

	if( cell_neighbours.length > 0 )
	{
		var sides = cell_neighbours[0].data;

		for ( var s in sides )
		{
			for ( var i in sides[s] )
			{
				unique_indices[ sides[s][i] ] = true;
			}
		}
	};

	for( var i in unique_indices )
	{
		if ( this.pageCacheIndexArray[i] )
		{
			recidency_count++;
		};

		recidency_max++;
	}

	console.log("Cache recidency @",x,y,z);
	console.log("  Total unique pages in cell", recidency_max);
	console.log("  Cache recidency count", recidency_count );
	console.log("  Recidency factor", recidency_count / recidency_max );
	console.log("  Redudancy count", total_count - recidency_max );
}

VT.VirtualTexture.prototype.CheckCacheRecidency = function()
{
	this.CheckCacheRecidencyFromGridCell( this.cell.index[0], this.cell.index[1], this.cell.index[2] );	
}

VT.VirtualTexture.prototype.PipeCleaner = function( x,y,z,flush )
{
	if ( flush )
	{
		this.pipeCleanerQueue = null;
		return;
	}

	if( !this.pipeCleanerQueue  )
	{
		var cell_neighbours = this.GetGridNeighboursFrom( x, y, z );
		var pages = cell_neighbours[0].data;

		this.pipeCleanerQueue = [];
		for( var p in pages )
		{
			this.pipeCleanerQueue.push(pages[p]);
		}
	}

	var index = this.pipeCleanerQueue.shift();

	if ( index )
	{
		var page_data = this.GetXYMFromIndex(index);

		console.log("PipeCleaner: loading index " + index + " (x,y,m)",page_data[0],page_data[1],page_data[2]);

		this.PreloadPage(page_data[0],page_data[1],page_data[2]);

	} else {
		console.log("Queue is empty!");
	}
}

VT.VirtualTexture.prototype.GetPlaneFromCell = function( cell, sideId )
{
	if ( this.lastCalculatedPlaneFromCellPtr == cell ) return this.lastCalculatedPlaneFromCellLut[sideId];

	this.lastCalculatedPlaneFromCellLut = [];

	var center = cell.center;
	var hw     = this.gridCellHalfSize;

	this.lastCalculatedPlaneFromCellLut[0] = [vec3.create(center),[ 1,0,0]]; this.lastCalculatedPlaneFromCellLut[0][0][0] += hw[0];
	this.lastCalculatedPlaneFromCellLut[1] = [vec3.create(center),[-1,0,0]]; this.lastCalculatedPlaneFromCellLut[1][0][0] -= hw[0];

	this.lastCalculatedPlaneFromCellLut[2] = [vec3.create(center),[0,0, 1]]; this.lastCalculatedPlaneFromCellLut[2][0][1] += hw[1];
	this.lastCalculatedPlaneFromCellLut[3] = [vec3.create(center),[0,0,-1]]; this.lastCalculatedPlaneFromCellLut[3][0][1] -= hw[1];

	this.lastCalculatedPlaneFromCellLut[4] = [vec3.create(center),[0, 1,0]]; this.lastCalculatedPlaneFromCellLut[4][0][2] += hw[2];
	this.lastCalculatedPlaneFromCellLut[5] = [vec3.create(center),[0,-1,0]]; this.lastCalculatedPlaneFromCellLut[5][0][2] -= hw[2];

	this.lastCalculatedPlaneFromCellPtr = cell;

	return this.lastCalculatedPlaneFromCellLut[sideId];
}

VT.VirtualTexture.prototype.CalculateFrustumDirVectors = function( camera )
{
	console.log("Calculating frustum view directions");

	var nw = vec3.create([ -1,  1, 1 ]);
	var sw = vec3.create([ -1, -1, 1 ]);
	var ne = vec3.create([  1,  1, 1 ]);
	var se = vec3.create([  1, -1, 1 ]);

	var invproj = mat4.create( camera.pMatrix );
	mat4.inverse(invproj);

	mat4.multiplyVec3( invproj, nw ); vec3.normalize( nw );
	mat4.multiplyVec3( invproj, sw ); vec3.normalize( sw );
	mat4.multiplyVec3( invproj, ne ); vec3.normalize( ne );
	mat4.multiplyVec3( invproj, se ); vec3.normalize( se );

	this.cameraFrustumDirVectors = [ nw, sw, ne, se ];
	this.cameraFrustumDirFov = camera.fov;
	this.cameraFrustumDirFar = camera.far;
	this.cameraFrustumDirNear = camera.near;
}

VT.VirtualTexture.prototype.ToggleCameraToCell = function( camera )
{
	if(!this.toggleCameraToCellState )
		this.toggleCameraToCellState = { axis : 0, cell : this.cell };

	var s = this.toggleCameraToCellState;

	camera.Identity();

	switch( s.axis ) 
	{
		case(0): camera.yaw = 0;          camera.pitch = 0; break;
		case(1): camera.yaw =  Math.PI;   camera.pitch = 0; break;
		case(2): camera.yaw =  Math.PI/2; camera.pitch = 0; break;
		case(3): camera.yaw = -Math.PI/2; camera.pitch = 0; break;
		case(4): camera.yaw = 0;          camera.pitch = Math.PI/2; break;
		case(5): camera.yaw = 0;          camera.pitch = -Math.PI/2; break;
	};


	s.axis++;

	this.SetCameraToCell( camera );

	camera.Update(1.0);

	if ( s.axis > 5 ) this.toggleCameraToCellState = null;
}

VT.VirtualTexture.prototype.SetCameraToCell = function( camera )
{
	var cell = this.cell;
	camera.position = vec3.create(cell.center);
}


VT.VirtualTexture.prototype.CellPageCount = function()
{
	if (!this.cell) return 0;

	var sum = 0;

	this.cell.data.forEach( function(a){ if(a.length !== undefined) sum += a.length; } );

	return sum;
}


VT.VirtualTexture.prototype.DoPageDeterminationGrid = function( scene, camera )
{
	if(!this.pageDetermGridData) return;

	///////////////////////////////////////////////
	// Make sure that we have valid frustum vectors
	if(!this.cameraFrustumDirVectors || 
		this.cameraFrustumDirFov  != camera.fov || 
		this.cameraFrustumDirFar  != camera.far || 
		this.cameraFrustumDirNear != camera.near ) 
		this.CalculateFrustumDirVectors(camera);

	var data       = this.pageDetermGridData;
    var cells      = data.cells;
    var resolution = data.resolution;
    var origin     = data.origin;
    var size       = data.size;

    if(!PXF.PointInAABB( this.pageDetermGridBox, camera.position ) )
    {
    	// console.warn("Missed the box.. TODO");
    	return;
    };

    var cameraDirection = vec3.create([0,0,-1]);
    mat4.multiplyVec3( camera.normaltransform, cameraDirection, cameraDirection );
    vec3.normalize(cameraDirection);

    /////////////////////////////////////////
    // Calculate grid cell by camera position
    var cell_x = Math.floor( (camera.position[0] - this.pageDetermGridBox.min[0]) / (size[0] / resolution[0]) );
    var cell_y = Math.floor( (camera.position[1] - this.pageDetermGridBox.min[1]) / (size[1] / resolution[1]) );
    var cell_z = Math.floor( (camera.position[2] - this.pageDetermGridBox.min[2]) / (size[2] / resolution[2]) );

    var cell_neighbours = this.GetGridNeighboursFrom( cell_x, cell_y, cell_z );
    var cell_hidden     = 0
    var cell_best_len 	= camera.far;
    var cell_best 		= -1;
    var cell_best_pages = [];
    var cell_this 		= cell_neighbours[0];
    var cell_axis_data  = cell_this.data;

    //////////////////////////////////////////////////
    // transform frustum vectors by camera orientation
    /*
    var cameraFrustumNWDir = this.cameraFrustumDirVectors[0]; mat4.multiplyVec3(camera.normaltransform,cameraFrustumNWDir);
    var cameraFrustumSWDir = this.cameraFrustumDirVectors[1]; mat4.multiplyVec3(camera.normaltransform,cameraFrustumSWDir);
    var cameraFrustumNEDir = this.cameraFrustumDirVectors[2]; mat4.multiplyVec3(camera.normaltransform,cameraFrustumNEDir);
    var cameraFrustumSEDir = this.cameraFrustumDirVectors[3]; mat4.multiplyVec3(camera.normaltransform,cameraFrustumSEDir);
    */

    cell_this.sidesTouched = cell_this.sidesTouched || [];
    var frame_new_touched  = [];

    for ( var s=0;s<6;s++)
	{
		var sidePlane = this.GetPlaneFromCell( cell_neighbours[0], s );
		var sidePlanePos = sidePlane[0];
		var sidePlaneDir = sidePlane[1];

		// if ( vec3.dot( sidePlaneDir, cameraDirection ) > 0 )
		{
			if ( !cell_this.sidesTouched[s] ) 
			{
				frame_new_touched.push(s);
			};

			cell_this.sidesTouched[s] = true;
		}
    }



    ////////////////////////////////
    // "force" update on all sides
    if ( this.setDirtySidesOnce ) 
    {
    	this.setDirtySidesOnce = false;
    	frame_new_touched = [0,1,2,3,4,5];
    }

    ///////////////////////////////
    // are we entering a new cell?
	if ( !this.cell || this.cell && (this.cell.index[0] != cell_x || this.cell.index[1] != cell_y || this.cell.index[2] != cell_z) )
	{
		// reset side lut for "outgoing" cell
		if ( this.cell )
		{
			this.cell.sidesTouched = null;
		};
	}

	var neededPages = [];
	var dirtyPixels = false;
	var touchedPages = {};

	for ( var s in frame_new_touched ) 
	{
		var s_axis = frame_new_touched[s];

		for ( var i in cell_this.data[s_axis] )
		{
			var  page_xym = this.GetXYMFromIndex( cell_this.data[s_axis][i] );

			if ( page_xym )
			{
				var index = cell_this.data[s_axis][i];

				// if ( !this.pageCacheIndexArray[index] )
				if ( !touchedPages[index] )
				{
					dirtyPixels = true;
					neededPages.push({
						x      : page_xym[0],
						y      : page_xym[1],
						miplvl : page_xym[2],
						index  : index
					});	

					touchedPages[index] = true;
				}
			}
		}
	}

	vt.neededPages = neededPages;
	vt.dirtyPixels = dirtyPixels;

    this.cell          = cell_this;
    this.cell_best     = cell_best;
    this.cell_best_len = cell_best_len;
    this.pageDetermIntervalCounter  = 3;
};


/* SOURCE C:\Users\Meindbender\Documents\masterthesis\newrepos\pxfvt\src/VT.Util.js: */

// DEPENDENCIES: /VT.js


var __debugOverlayShaderVertexSource = " \
	precision mediump float; \
	attribute vec3 position; \
	attribute vec2 uv0;  \
	uniform mat4 uPMatrix; \
	uniform mat4 uMVMatrix; \
	uniform mat4 uMVMatrix2; \
	varying vec2 uv_0; \
	void main(void) { \
		uv_0 = uv0; \
		gl_Position = uPMatrix * uMVMatrix * uMVMatrix2 * vec4(position,1.0); \
	}";

var __debugOverlayFragmentSource = "\
	precision mediump float; \
	uniform sampler2D tex0; \
	varying vec2 uv_0; \
	void main(void) { \
		vec4 sample = texture2D( tex0, uv_0 ); \
		gl_FragColor = vec4( sample.rgb, 1.0 ); \
	}";

var __overlayDiv 		 = undefined;
var __overlayText 		 = undefined;
var __overlayColor 		 = undefined;
var __debugOverlayShader = undefined;

function DebugOverlay(ctx) {
	var gl = ctx.gl;
	this.ctx = ctx;

	if(!__debugOverlayShader) {
		__debugOverlayShader = new PXF.Shader( ctx, __debugOverlayShaderVertexSource,__debugOverlayFragmentSource, false);
	}

	if(!__overlayDiv) {
		__overlayDiv = document.getElementById("overlayColorBox");
		__overlayText = document.getElementById("overlayColorBoxText");
		__overlayColor = document.getElementById("overlayColorBoxColor");
	}


	this.minimizedDrawSize = 0.15;
	this.overlays = [];
	this.camera = new PXF.Camera("Debug Overlay Camera");
	this.camera.Ortho(0, 1, 1, 0, 0, 100);

	// add fullscreen quad
	this.maximizedQuad = new PXF.QuadBatch( ctx );
	this.maximizedQuad.Reset();
	this.maximizedQuad.AddTopLeft(0,0,1,1);
	this.maximizedQuad.End();

	// state
	this.isMaximized = false;

	this.Add = function( tex, shader, uniforms ) {
		var overlay = {};
		overlay.texture = tex;

		overlay.shader = shader ? shader : __debugOverlayShader;
		overlay.uniforms = uniforms;

		overlay.zoom = 1.0;

		overlay.quad = new PXF.QuadBatch( ctx );
		overlay.quad.Reset();
		overlay.quad.AddTopLeft(0,0,this.minimizedDrawSize,this.minimizedDrawSize);
		overlay.quad.End();

		this.overlays.push(overlay);

		return this;
	}		

	this.Draw = function() {
		var m_x = this.ctx._inputState.mousePos[0] / ctx.ctxWidth;
		var m_y = this.ctx._inputState.mousePos[1] / ctx.ctxHeight;

		//__debugOverlayShader.Bind();
		//__debugOverlayShader.SetUniform("pMatrix",this.camera.pMatrix);	

		var bindBuffers = {
			"position" : true,
			"uv0" : true,
			"normal" : false
		};

		// draw a fs quad if an overlay is pressed
		if( this.isMaximized ) {

			this.isMaximized.shader.Bind();
			this.isMaximized.shader.SetUniform( "uPMatrix", this.camera.pMatrix );
			this.isMaximized.shader.SetUniform( "uMVMatrix", mat4.identity() );

			if (this.isMaximized.uniforms != undefined)
			{				
				for (var uni in this.isMaximized.uniforms)
				{
					this.isMaximized.shader.SetUniform( uni, this.isMaximized.uniforms[uni] );
				}
			}

			var zoom = this.ctx._inputState.mouseWheelDelta;
			this.ctx._inputState.mouseWheelDelta = 0.0;

			if (zoom > 0.0) {
				this.isMaximized.zoom *= 2;
			} else if (zoom < 0.0) {
				this.isMaximized.zoom *= 0.5;
			}
			/*var zoom_step = Math.abs( zoom ) * 0.00001;

			zoom = 1 + zoom * zoom_step;
			zoom = zoom > 0 ? zoom : 0.01;
			*/
			var multiplier 	= 1 / this.minimizedDrawSize * this.isMaximized.zoom;

			if( !this.ctx._inputState.mouseDown && this.ctx._inputState.mouseButton == this.ctx._inputState.mouseButtonEnum.LEFT) {
				if( !this.mouseReleased ) {
					this.mouseReleased = true;
				}
			} else {
				if( this.mouseReleased && this.ctx._inputState.mouseButton == this.ctx._inputState.mouseButtonEnum.LEFT) {
					__overlayDiv.style.display = "none";
					this.isMaximized = false;
					return;
				} 
			}	

			if (  this.ctx._inputState.mouseDown && 
				 this.ctx._inputState.mouseButton == this.ctx._inputState.mouseButtonEnum.RIGHT &&
				 this.ctx._inputState.mousePos[0] != this.prevMousePos[0] &&
				 this.ctx._inputState.mousePos[1] != this.prevMousePos[1]) {

				this.offsetX += this.ctx._inputState.mouseDelta[0] * 1/ ctx.ctxWidth;
				this.offsetY += this.ctx._inputState.mouseDelta[1] * 1/ ctx.ctxHeight;
			} 

			gl.clear(gl.COLOR_BUFFER_BIT);

			var transform 	= mat4.identity();

			var w = this.isMaximized.texture.width / ctx.ctxWidth;  
			var h = this.isMaximized.texture.height / ctx.ctxHeight; 

			var x = 0.5 - w * 0.5 * this.isMaximized.zoom + this.offsetX * this.isMaximized.zoom;
			var y = 0.5 - h * 0.5 * this.isMaximized.zoom + this.offsetY * this.isMaximized.zoom;
			//x = Math.floor(x);
			//y = Math.floor(y);

			var _minFilter = this.isMaximized.texture.minFilter;
			var _magFilter = this.isMaximized.texture.magFilter;

			//this.isMaximized.texture.minFilter = gl.NEAREST;
			//this.isMaximized.texture.magFilter = gl.NEAREST;

			//this.isMaximized.texture.SetTextureParameters();

			mat4.translate( transform, [x,y,0]);
			mat4.scale( transform, [ w* multiplier,h* multiplier,1]);

			this.isMaximized.texture.Bind(this.isMaximized.shader, "tex0", 0);
			this.isMaximized.shader.SetUniform( "uMVMatrix2", transform );
			this.isMaximized.quad.Draw(this.isMaximized.shader,bindBuffers);

			// fetch pixel data
			var pixels = new Uint8Array(4);
			gl.readPixels(this.ctx._inputState.mousePos[0],ctx.ctxHeight - this.ctx._inputState.mousePos[1],1,1,gl.RGBA, gl.UNSIGNED_BYTE, pixels);

			this.isMaximized.texture.minFilter = _minFilter;
			this.isMaximized.texture.magFilter = _magFilter;

			//this.isMaximized.texture.SetTextureParameters();

			// set debug div text/color
			__overlayDiv.style.display = "block";
			__overlayDiv.style.left = this.ctx._inputState.mousePos[0] + 10;
			__overlayDiv.style.top = this.ctx._inputState.mousePos[1] + 5;

			var colorString = "(" + pixels[0] + "," + pixels[1] + "," + pixels[2] + "," + pixels[3] + ")";

			__overlayText.innerHTML = colorString;
			__overlayColor.style.backgroundColor = "rgba"+"(" + pixels[0] + "," + pixels[1] + "," + pixels[2] + "," + pixels[3] + ")";

			this.prevMousePos = this.ctx._inputState.mousePos;

			this.isMaximized.shader.Unbind();

		} else {

			// draw all overlays
			for ( var k = 0; k < this.overlays.length; k++ ) {

				var overlay 	= this.overlays[k];
				var transform 	= mat4.identity();

				var drawpos_y = this.minimizedDrawSize * k;
				var drawpos_x = 0;

				overlay.shader.Bind();
				overlay.shader.SetUniform( "uPMatrix", this.camera.pMatrix );
				overlay.shader.SetUniform( "uMVMatrix", mat4.identity() );

				if (overlay.uniforms != undefined)
				{				
					for (var uni in overlay.uniforms)
					{
						overlay.shader.SetUniform( uni, overlay.uniforms[uni] );
					}
				}

				// hijack input
				if ( m_x >= drawpos_x && m_x <= drawpos_x + this.minimizedDrawSize &&
					 m_y >= drawpos_y && m_y <= drawpos_y + this.minimizedDrawSize ) {

					if ( !this.mousePressed && this.ctx._inputState.mouseDown )
						this.mousePressed = true;

					if ( this.mousePressed && !this.ctx._inputState.mouseDown) {
						this.isMaximized = overlay;
						this.mouseReleased = false;
						this.offsetY = 0;
						this.offsetX = 0;
						this.mousePressed = false;

						break;
					}
				} 

				// move and set overlay pos
				mat4.translate(transform,[drawpos_x, drawpos_y, 0]);
				mat4.scale(transform,[ctx.ctxHeight / ctx.ctxWidth , 1, 0]);

				overlay.shader.SetUniform( "uMVMatrix2",transform );

				// bind texture and draw overlay
				overlay.texture.Bind( overlay.shader, "tex0", 0 );

				overlay.quad.Draw( overlay.shader, bindBuffers );

				overlay.shader.Unbind();
			}
		}

		//__debugOverlayShader.Unbind();

	}

	return this;
}

VT.VirtualTexture.prototype.GetIndexFromXYMip = function(x, y, mip)
{
	return (this.__mipOffsets[mip] + y * this.__mipSizes[mip] + x);
}

VT.VirtualTexture.prototype.GetXYMFromIndex = function(index)
{
	if ( index > this.indirectTable.length / 4 )
	{
		console.error("VT.GetXYMFromIndex: index " + index + " out of range..");
	}

	var mm = 0;
	var x=0,y=0;

	for ( var s=this.__mipOffsets.length-2; s >= 0 ; s-- )
	{
		if ( index >= this.__mipOffsets[s] )
		{
			mm = s;

			var relative = index - this.__mipOffsets[s];

			x = Math.floor( relative % this.__mipSizes[mm] );
			y = Math.floor( relative / this.__mipSizes[mm] );

			if ( x > this.__mipSizes[s] || y > this.__mipSizes[s] )
			{
				console.error("VT.GetXYMFromIndex: index " + index + " yields incorrect x or y - (" + x + "," + y + ") at mipmap " + mm );
				return;
			}

			// console.log( index,relative,mm,this.__mipSizes[mm] );

			break;
		};
	};

	return [x,y,mm];
}



/*
 * Non-WebWorker pixels to list conversion
 */
function hit_and_prio_sort(a,b) {

    if (a.prio == b.prio) {

        if(a.hit > b.hit) {
            return -1;
        } else if(a.hit < b.hit) {
            return 1;
        } else {
            return 0;
        }

    } else if (a.prio > b.prio) {
        return 1;
    } else {
        return -1;
    }

}
function hitsort(a,b) {
   if(a.hit > b.hit) {
       return -1;
   }else if(a.hit < b.hit) {
       return 1;
   } else {
       return 0;
   }
}
function levelsort(a,b) {
   if(a.miplvl < b.miplvl) {
       return -1;
   } else if(a.miplvl > b.miplvl) {
       return 1;
   } else {
       return 0;
   }
}

var touched_pages = {};
function ____listConvert(bufsize, pixels, getlist, prio, config)
{
    // Reset touched pages
    //var touched_pages = {};
    //console.log(inpixels);
    //var pixels = inpixels;//new Uint8Array(inpixels);

    // Loop all pixels in the page determination texture
    for (var i = 0; i < bufsize; i+=4) {

        if (pixels[i+3] < 50.0)
           continue;

        /*if (pixels[i+3] < 200.0)
            console.log("SUP!!");*/

        var indx_mip = Math.floor(pixels[i]);         // R
        var indx_x = pixels[i+1] / 255.0; // G
        var indx_y = pixels[i+2] / 255.0; // B
                                          // A = unused
        if( !((indx_x >= 0 && indx_x < 256) && (indx_y >= 0 && indx_y < 256)) ) {
            continue;
        }

        //console.log(indx_y);

        indx_x = Math.floor(indx_x * config.__mipSizes[indx_mip]);
        indx_y = Math.floor(indx_y * config.__mipSizes[indx_mip]);


        // Only use pixels that have an alpha equal to 1.0
        
        if (pixels[i] < 9)
        {
            // calculate tile index from pixel data...
            var index = config.__mipOffsets[indx_mip] // offsets up until current mip level start
                        + indx_y * config.__mipSizes[indx_mip] + indx_x;

            if (touched_pages[index] != undefined)
                touched_pages[index].hit += 1;
            else
            {
                if (indx_mip == 0 && indx_x == 1) {
                    //console.log(this.pixels[i+1] / 256,this.pixels[i+2] / 256);
                }

                touched_pages[index] = {};
                touched_pages[index].hit = 1;
                touched_pages[index].index = index;
                touched_pages[index].miplvl = indx_mip;
                touched_pages[index].x = indx_x;
                touched_pages[index].y = indx_y;
                touched_pages[index].prio = prio;
				/*
				if (pixels[i+3] < 200.0)
					touched_pages[index].in_cache = true;
				else
					touched_pages[index].in_cache = false;
				*/
            }
            
        }
    }

    // only send current list back if sender has requested it
    if (getlist)
    {
        //var pages = [];
        pagelist = [];

        //var i = 0;
        //var max = 50;
        for(var k in touched_pages)  {
            //if (i > max)
            //    break;
            //i++;
            pagelist.push(touched_pages[k]);
        }
        //pagelist = pagelist.sort(hitsort);
        //pagelist.sort(levelsort);
        //pagelist.sort(hitsort);
        pagelist.sort( hit_and_prio_sort );

        //console.log("get with prio " + prio);


        //postMessage( { "msgType" : "list", "data" : pagelist } );
        return pagelist;
    }

    return;
    //return pages.sort(levelsort);
}


/* SOURCE C:\Users\Meindbender\Documents\masterthesis\newrepos\pxfvt\src/VT.PageDeterminationDynamic.js: */

// DEPENDENCIES: /VT.js

VT.VirtualTexture.prototype.BuildPageDeterminationDynamic = function() {
	//////////////////////////////
	// Create Page determ texture
	var pdWidth 	= Math.round(this.ctx.ctxWidth * this.config.pageDeterminationRatio);
	var pdHeight 	= Math.round(this.ctx.ctxHeight * this.config.pageDeterminationRatio);
	var params 		= { minFilter : this.gl.LINEAR, magFilter : this.gl.LINEAR };

	this.pdWidth     = pdWidth;
	this.pdHeight    = pdHeight;
	this.dirtyPixels = false; // keep track if pixelbuffer is analyzed or not
	this.convertBusy = false; // keep track if pixelbuffer is analyzed or not
	this.pageDetermParts = 1;

	this.page_determ_camera = mat4.identity();

	//////////////////////////////
	// Create buffer to store pixels
	this.pageDeterminationBufsize = pdWidth*pdHeight*4; // w * h * c (c = 4 because readPixels only allow RGBA)
	//this.pageDeterminationPixels = new Uint8Array(this.pageDeterminationBufsize);//bufsize);

	// this.pageDeterminationTexture = (new PXF.Texture( this.gl, null, params )).CreateFromEmpty(pdWidth,pdHeight);
	//this.pageDeterminationTexture = (new PXF.Texture( this.gl, null, params )).Upload(null, pdWidth,pdHeight);
	this.pageDeterminationTextureId 	= 0;
	this.pageDeterminationTexture 		= {};
	this.pageDeterminationTexture[0] 	= (new PXF.Texture( this.ctx, null, params )).Upload(null, pdWidth, pdHeight);
	// this.pageDeterminationTexture[1] = (new PXF.Texture( this.gl, null, params )).Upload(null, pdWidth, pdHeight);
	// this.pageDeterminationTexture[2] = (new PXF.Texture( this.gl, null, params )).Upload(null, pdWidth, pdHeight);

	// hack, textures MUST have some kind of filter...
	//gl.bindTexture(gl.TEXTURE_2D, this.pageDeterminationTexture.texture);
	//this.pageDeterminationTexture.SetTextureParameters();
	//gl.bindTexture(gl.TEXTURE_2D, null);

	//////////////////
	// Page determ FBO
	this.pageDeterminationFBO = new PXF.Framebuffer( this.ctx, this.pageDeterminationTexture[0], undefined, false, true );

	this.GeneratePageDeterminationShader = this.GeneratePageDeterminationShaderDynamic;
	this.DoPageDetermination 			 = this.DoPageDeterminationDynamic;
	this.ReadOutPageDetermination 		 = this.ReadOutPageDeterminationDynamic;
	this.ResizePageDetermination 		 = this.ResizePageDeterminationDynamic;
	this.BuildPageDeterminationWorker  	 = this.BuildPageDeterminationWorkerDynamic;
}

VT.VirtualTexture.prototype.BuildPageDeterminationWorkerDynamic = function() {
	if ( this.config.imageWorker == "proxy" )
	{
		this.pdWorker = this.ProxyWorker();
	} else this.pdWorker = new Worker("./static/js/vtworker.js");

	this.pdWorker.vt = this;
	this.pdWorker.id = this.workerCount;
	this.pdWorker.onerror = function (e) {
		console.log("Page Determ Web Worker error: ", e);
		this.ready = true;
	};

	this.pdWorker.postMessage( {"msgType" : "config", "data" : this.workerconf } );
	this.pdWorker.onmessage = function(e) { return this.vt.WorkerMessage(e, this); };

	this.workers[this.workerCount] = this.pdWorker;
}

VT.VirtualTexture.prototype.ResizePageDeterminationDynamic = function() {
	this.pdWidth 					= Math.round(this.ctx.ctxWidth * this.config.pageDeterminationRatio);
	this.pdHeight 					= Math.round(this.ctx.ctxHeight * this.config.pageDeterminationRatio);
	this.page_determ_camera 		= mat4.identity();
	this.pageDeterminationBufsize 	= this.pdWidth*this.pdHeight*4;
	this.pageDeterminationTexture[0].Resize( this.pdWidth, this.pdHeight );
	this.pageDeterminationFBO.Rebuild( this.pageDeterminationTexture[0] );
}

VT.VirtualTexture.prototype.GeneratePageDeterminationShaderDynamic = function() {
	// build page determination shader
	var fsPath 	 = this.config.shaderSourcePath + "VT.PageDetermination.fs";
	var fsSource = PXF.LoadRawFile(fsPath);

	fsSource = this.GeneratePageDeterminationShaderHeaderDynamic() + fsSource;
	this.pageDeterminationShader = new PXF.Shader( this.ctx, PXF.Shaderlib.forward.vsRaw, fsSource );
}

VT.VirtualTexture.prototype.GeneratePageDeterminationShaderHeaderDynamic = function() {

	var adjusted_mip_bias = this.config.mipBias - Math.log(1.0 / this.config.pageDeterminationRatio) / Math.log(2) - 0.5;

	var lines = [];
	lines.push("precision highp float;");
	if ( this.ctx.extensions["OES_standard_derivatives"] ) 
		lines.push("#extension GL_OES_standard_derivatives : enable");
	lines.push("const float vt_dimension_pages = " + this.config.pageSize.toFixed(1) + ";");
	lines.push("const float vt_dimension = " + this.config.textureSize.toFixed(1) + ";");
	// lines.push("const float mip_bias = " + adjusted_mip_bias.toFixed(1) + ";");
	lines.push("uniform float mip_bias;");
	lines.push("const float mipmaps = " + (this.config.mipmaps - 1).toFixed(1) + ";");
	lines.push("float page_dimension_log2 = " + (Math.log(this.config.pageSize)/Math.log(2)).toFixed(1) + ";");
	lines.push("// page cache offset is used when sampling the blending texture");
	lines.push("#define CACHE_OFFSET " + ( this.config.pageCacheSizeY / (this.config.pageCacheSizeY * this.config.numPageCaches)).toFixed(12) );
	lines.push("const vec2 phys_tex_dimension_pages = vec2(" + this.config.pageCacheSizeX.toFixed(1) + ", " + this.config.pageCacheSizeY.toFixed(1) + ");");

	if (this.config.use_blending_texture)
    {
    	lines.push("#define PACKED_BLENDING 0");
    } else {
    	lines.push("#define PACKED_BLENDING 1");
    }

	lines.push("\n");

	if ( this.indirectTableLayout == INDIRECT_LAYOUT_FLAT )
	{
		lines.push("#define INDIRECT_MODE 1");
		lines.push("");
		lines.push("float get_y_offset(int mm) {");
		lines.push("float indirect_y_offset_lut[" + this.__flatOffsets.length + "];");
		lines.push("float offset = 0.0;");

		for ( var k in this.__flatOffsets )
		{
			var offset = this.__flatOffsets[k];
			lines.push("indirect_y_offset_lut[" + k + "] = " + this.__flatOffsets[k].toFixed(1) +";");
		};

		for ( var mm=2;mm < this.__flatOffsets.length; mm++ )
		{
			if ( mm == 2 )
				lines.push("if ( mm == " + mm + ") return indirect_y_offset_lut[" + mm + "];");
			else lines.push("else if ( mm == " + mm + ") return indirect_y_offset_lut[" + mm + "];");
		}

		lines.push("return offset;");
		lines.push("}");
	} else {
		lines.push("#define INDIRECT_MODE 0");
	}

	lines.push("");


	return lines.join("\n");
}

VT.VirtualTexture.prototype.DoPageDeterminationDynamic = function ( scene, camera ) {

	//if (!this.needNewPageDeterm)
	//	return true;

	/*if (this.convertBusy) {
		return false;
	}*/

	var gl = this.gl;

	this.gl.viewport( 0, 0, this.pdWidth, this.pdHeight );
	var shader = this.pageDeterminationShader;
	var bindBuffers = { normal : false };

	this.pageDeterminationFBO.Bind();
	this.pageDeterminationFBO.AttachColorTexture(this.pageDeterminationTexture[this.pageDeterminationTextureId], 1);
	

	this.gl.disable( gl.BLEND );
	this.gl.enable( gl.DEPTH_TEST );
	this.gl.enable( gl.CULL_FACE );
	this.gl.cullFace( gl.BACK );
	this.gl.clearColor( 0, 0, 0, 0 ); // Clear alpha channel to 1 = no page (in vtworker.js)

	// only clear buffer when we have previously rendered all parts
	if (this.pageDetermCurrentPart === undefined || this.pageDetermCurrentPart >= this.pageDetermParts - 1 )
	{
		this.pageDetermCurrentPart = 0;
		this.gl.clear( gl.COLOR_BUFFER_BIT + gl.DEPTH_BUFFER_BIT );
	} else {
		this.pageDetermCurrentPart++;
	}
		// this.pageDetermCurrentPart, this.pageDetermParts

	// store "current camera state"
	var oldfov       = camera.fov;
	var oldaspect    = camera.aspect;
	var oldtransform = mat4.create(camera.transform);
	var oldpmatrix   = mat4.create(camera.pMatrix);

	// get the current "cube map camera"

	// fixme: should we release this worker when we are done,
	// or keep it dedicated
	if (this.pageDeterminationState.worker == 0)
	{
		//this.pageDeterminationState.worker = this.GetWorker();
	}

	// setup current page determ camera
	var curcam = this.pageDeterminationState.cameraTodo.shift();
	this.determPrio    = 0;
	var determreadout = false;
	curcam = "F";

	switch (curcam)
	{
		case "L":
			this.determPrio = 1;
			camera.Rotate(-Math.PI / 2.0, 0.0, 1.0, 0.0);
			break;
			
		case "R":
			this.determPrio = 1;
			camera.Rotate( Math.PI / 2.0, 0.0, 1.0, 0.0);
			break;
			
		case "B":
			this.determPrio = 3;
			camera.Rotate( Math.PI, 0.0, 1.0, 0.0);
			break;
			
		case "U":
			this.determPrio = 2;
			camera.Rotate( Math.PI / 2.0, 1.0, 0.0, 0.0);
			break;
		case "D":
			this.determPrio = 2;
			getlist = true;
			this.needPageDeterm = false;
			//this.pageDetermIntervalCounter = this.pageDetermInterval;
			camera.Rotate(-Math.PI / 2.0, 1.0, 0.0, 0.0);
			break;
		case "F":
		default:
			//this.needPageDeterm = false;
			//this.pageDetermIntervalCounter = this.pageDetermInterval;
			this.determPrio = 0;
			getlist    = true;
			//this.pageDeterminationState.worker.postMessage( { "msgType" : "clearlist" } );
			// TODO clear list in some way
			touched_pages = {};
			break;
	}
	//camera.fov = 90;
	camera.Perspective(camera.fov, this.pdWidth / this.pdHeight, camera.near, camera.far);
	// camera.Perspective(camera.fov, this.pdWidth / this.pdHeight, 0.1, 10000.0);
	//camera.Update();

	
	mat4.multiply(camera.pMatrix, camera.invworldtransform, this.page_determ_camera);

	// reset page determination cube map "TODO list"
	//this.pageDeterminationState.cameraTodo = this.pageDeterminationState.cameraCube.slice();

	// camera.fov = 70;
	// camera.Perspective(camera.fov, this.pdWidth / this.pdHeight, 0.1, 100.0);
	// camera.Update(1.0);

	//////////////////////////////////////////////////////////
	// fixme: similar to render scene in ctx, replace or clean up to increase readability?
	shader.Bind();
	var _res_bias = - Math.log(1.0 / this.config.pageDeterminationRatio) / Math.log(2.0);
	shader.SetUniform( "mip_bias", this.config.mipBias + _res_bias - 0.5 ); // -0.5 hack to request "half a miplevel" better pages than we render/shade with -> better miplevel gradient
	// page determ pass is subsampled so we can miss pixels requiring better mip levels

	shader.SetUniform( "uPMatrix", camera.pMatrix );
	this.mipmapLUTTexture.Bind( shader, "mipmapLUTTexture", 0);
	this.indirectTexture.Bind( shader, "indirectTableTexture", 1);
	if ( !this.config.disable_blending && this.config.use_blending_texture)
	{
		this.blendingTexture.Bind( shader, "blendingTexture",  2);
	}

	this.vtdrawcalls = 0;

	var thisvt = this;

	scene.Walk( function ( name, node, depth )
    {

        // only render objects with geometry
        if (node.type == "mesh" || node.type == "lodmesh") {

            // update bounding volume if missing
            if ( node.type == "mesh" && !node.boundingVolume )
            {
                node.UpdateBoundingVolume();
            }

            // only render if object passes visibility test
            if ( !node.IsVisible || node.IsVisible( camera ) ) 
            {
                
                if (!thisvt.config.disable_objtransform)
                {
                    var transform = mat4.create();
			        mat4.multiply(camera.invworldtransform, node.worldtransform, transform);

			        // object to world matrix
			        shader.SetUniform( "uMVMatrix", transform );
                }

                // update object specific uniforms
                var uv_offset = node.uv_offset;
				if (uv_offset == undefined)
					uv_offset = [0,0,1,1];
				shader.SetUniform( "uUVOffset", uv_offset );

                // render object
                var geo = node.geometry;

		        if ( node.type =="lodmesh" ) {
	                node.Draw( camera, shader, bindBuffers ); // TODO how to solve with subdraw??
	                this.vtdrawcalls++;
	            } else if ( geo && geo.BindBuffers ) {
	                geo.BindBuffers( shader, bindBuffers );
	                // geo.SubDraw( shader, thisvt.pageDetermCurrentPart, thisvt.pageDetermParts, bindBuffers );
	                geo.DrawBuffers();
	                geo.UnbindBuffers( shader, bindBuffers );

	                this.vtdrawcalls++;
	            }
            }
        }

    } );

    //this.indirectTexture.Unbind();
    this.mipmapLUTTexture.Unbind();
    shader.Unbind();
    //////////////////////////////////////////////////////////

    //this.gl.enable( gl.DEPTH_TEST );

    ///////////////////////////////////////////////////////
    // read pixel data since we allready have the FBO bound
    //this.ReadOutPageDetermination( determprio, getlist );

	this.pageDeterminationFBO.Unbind();

	// reset camera state
	camera.fov = oldfov;
	camera.aspect = oldaspect;
	camera.transform = oldtransform;
	camera.pMatrix = oldpmatrix;
	//camera.Update();

	// pixels needs to be read out next frame
	this.pdDirtyBuffer = true;
	//this.pageDeterminationTextureId++;
	//this.pageDeterminationTextureId = 3;

	//this.needNewPageDeterm = false;

	//console.log("did pd render");

	if (this.pageDetermCurrentPart >= this.pageDetermParts - 1)
		return true;
	else
		return false;

}

VT.VirtualTexture.prototype.ReadOutPageDeterminationDynamic = function( getlist ) {

	/*var w = this.GetWorker();
	if (!w)
		return;*/

	var w = this.pdWorker;
	if (!w.ready)
		return;

	this.pageDeterminationFBO.Bind();
	this.pageDeterminationFBO.AttachColorTexture(this.pageDeterminationTexture[0], 1);

	var gl = this.gl;
	var tpixels = new Uint8Array(this.pageDeterminationBufsize);
	this.readOutPixels = true;
    gl.readPixels( 0, 0, this.pdWidth, this.pdHeight, gl.RGBA, gl.UNSIGNED_BYTE, tpixels);//this.pageDeterminationPixels);

	this.pageDeterminationFBO.Unbind();

    ///////////////////////////////////////////////////////
    // send pixel data to worker
    
    //var w = this.pageDeterminationState.worker;

    this.convertBusy = true;

    w.postMessage( { "msgType" : "pixels", "data" : { "bufsize" : this.pageDeterminationBufsize,
    												  "pixels"  : tpixels,
    												  "getlist" : getlist,
    												  "prio"    : this.determPrio
    												}
    } );

	this.dirtyPixels 		= true;
	//this.convertBusy 		= false;

	//this.analyzedPageList 	= false;
	//this.neededPages 		= _listConvert(this.pageDeterminationBufsize, tpixels, getlist, prio, this.workerconf);
	this.thrashStop         = 2;

	this.pdDirtyBuffer = false;

	this.pageDetermIntervalCounter = this.pageDetermInterval;
}


/* SOURCE C:\Users\Meindbender\Documents\masterthesis\newrepos\pxfvt\src/VT.PageCache.js: */

// DEPENDENCIES: /VT.js

VT.VirtualTexture.prototype.BuildPageCache = function() {
	var gl              = this.gl;
	var config          = this.config;
	var internalFormat;
	var cacheSize_w		= this.config.pageCacheSizeX * this.config.pageSize * this.config.pageColumns;
	var cacheSize_h		= this.config.pageCacheSizeY * this.config.pageSize * this.config.pageRows;
	var numCaches 		= this.config.numPageCaches; // get from config
	var isjpg 			= this.config.imageFormat == "jpg" || this.config.imageFormat == "jpeg";

	var settings = {
		minFilter 		: this.gl.LINEAR,
		// minFilter 		: this.gl.LINEAR,
		// minFilter 		: this.gl.LINEAR,
		magFilter 		: this.gl.LINEAR,
		// target          : this.gl.TEXTURE_CUBE_MAP,
		format 			: isjpg ? this.gl.RGB : this.gl.RGBA,
		internalFormat  : isjpg ? this.gl.RGB : this.gl.RGBA,
		compressed 		: this.config.imageFormat == "dds" ? "dxt1" : false,
		autoGenerateMipmaps : false
	};

	this.pageCacheTextureSettings = settings;

	if (config.cache_mode == VT.CACHE_MODES.CUBE)
	{
		settings.target = this.gl.TEXTURE_CUBE_MAP;

		this.config.numPageCaches = 6;
		numCaches = 6;

		this.cacheCubeFaces = [
			this.gl.TEXTURE_CUBE_MAP_POSITIVE_X,
			this.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
			this.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
			this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
			this.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
			this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
		];

		this.cacheTexture  = new PXF.Texture( this.ctx, null, settings ); //.Upload( null, cacheSize_w,cacheSize_h );	
		console.log("creating cube texture");

	} else if (config.cache_mode == VT.CACHE_MODES.FLAT) {
		settings.target = this.gl.TEXTURE_2D;

	} else if (config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS || config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED) {
		settings.target = this.gl.TEXTURE_2D;
		this.parentCacheFBO = new PXF.Framebuffer( this.ctx, undefined, undefined, false, false );
		this.parentCacheQuad = new PXF.QuadBatch( this.ctx );
		this.parentCacheQuad.Reset();
		this.parentCacheQuad.AddCentered(0,0,2,2);
		this.parentCacheQuad.End();

	} else {
		console.error("Unknown config.cache_mode used in VT.BuildPageCache().");
		return;
	}


	this.pageCacheList = [];

	
	
	// empty buffer to upload to each cache/side
	var dummy_buffer = new Uint8Array( cacheSize_w * cacheSize_h * 4);
	for (var i = 0; i < cacheSize_w * cacheSize_h; i++)
	{
		dummy_buffer[i*4] = 255.0;
		dummy_buffer[i*4+1] = 0.0;
		dummy_buffer[i*4+2] = 0.0;
		dummy_buffer[i*4+3] = 255.0;
	}


	if (config.cache_mode == VT.CACHE_MODES.CUBE)
	{

		// build x cubemap side caches
		for(var i = 0; i < 6; i++) {
			if (i < numCaches)
			{
				var cache = {};
				console.log("cubemap cache side:", cacheSize_w, cacheSize_h);
				this.cacheTexture.UploadFace( this.cacheCubeFaces[i], dummy_buffer, cacheSize_w, cacheSize_h );
				cache.cacheCells 	= {};
				cache.wrapX         = 0; // used to easily skip locked pages inside the cache
				cache.wrapY         = 0;

				for ( var y =0; y < this.config.pageCacheSizeY; y++ ) cache.cacheCells[y] = {};

				this.pageCacheList.push( cache );

			} else {

				this.cacheTexture.UploadFace( this.cacheCubeFaces[i], null, 2, 2 );

			}
		}

		this.cacheTexture.width = cacheSize_w;
		this.cacheTexture.height = cacheSize_h;

	} else if (config.cache_mode == VT.CACHE_MODES.FLAT) {

		for(var i = 0; i < numCaches; i++) {
			
			var cache = {};
			console.log("flat cache:", cacheSize_w, cacheSize_h);
			cache.cacheTexture = ( new PXF.Texture( this.ctx, null, settings) ).Upload( dummy_buffer, cacheSize_w, cacheSize_h );
			cache.cacheTexture.width = cacheSize_w;
			cache.cacheTexture.height = cacheSize_h;
			cache.cacheCells 	= {};
			cache.wrapX         = 0; // used to easily skip locked pages inside the cache
			cache.wrapY         = 0;

			for ( var y =0; y < this.config.pageCacheSizeY; y++ ) cache.cacheCells[y] = {};

			this.pageCacheList.push( cache );

		}

	} else if (config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS || config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED) {

		var parentCacheSize_w = cacheSize_w / 2.0;
		var parentCacheSize_h = cacheSize_h / 2.0;
		var parent_dummy_buffer = new Uint8Array( parentCacheSize_w * parentCacheSize_h * 4);
		for (var i = 0; i < parentCacheSize_w * parentCacheSize_h; i++)
		{
			parent_dummy_buffer[i*4] = 255.0;
			parent_dummy_buffer[i*4+1] = 0.0;
			parent_dummy_buffer[i*4+2] = 0.0;
			parent_dummy_buffer[i*4+3] = 255.0;
		}


		for(var i = 0; i < numCaches; i++) {
			
			var cache = {};
			console.log("FLAT_WITH_PARENTS cache:", cacheSize_w, cacheSize_h);
			cache.cacheTexture = ( new PXF.Texture( this.ctx, null, settings) ).Upload( dummy_buffer, cacheSize_w, cacheSize_h );


			cache.cacheTexture.minFilter = this.gl.LINEAR_MIPMAP_LINEAR;
			if ( config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED )
			{
				cache.cacheTexture.Bind();
				cache.cacheTexture.autoGenerateMipmaps = true;
				cache.cacheTexture.SetTextureParameters();
				// this.gl.generateMipmap(this.gl.TEXTURE_2D);
				cache.cacheTexture.autoGenerateMipmaps = false;
				cache.cacheTexture.Unbind();
			}


			cache.cacheTexture.width = cacheSize_w;
			cache.cacheTexture.height = cacheSize_h;

			cache.cacheTextureParents = ( new PXF.Texture( this.ctx, null, settings) ).Upload( parent_dummy_buffer, parentCacheSize_w, parentCacheSize_h );
			cache.cacheTextureParents.width = parentCacheSize_w;
			cache.cacheTextureParents.height = parentCacheSize_h;

			cache.cacheCells 	= {};
			cache.wrapX         = 0; // used to easily skip locked pages inside the cache
			cache.wrapY         = 0;

			for ( var y =0; y < this.config.pageCacheSizeY; y++ ) cache.cacheCells[y] = {};

			this.pageCacheList.push( cache );

		}

	}

		
	this.pageCacheIndexArray 	= {};
	this.pageCacheCellPointer 	= -1;

	this.replaceQueue           = [];

	//
	//  CPU side cache
	//
	this.cpuCache = {
		pages : {}
	};

	// Generate initial replacement queue, needed by preload pages
	// (if queue is empty when they are loaded, there will be no "free"
	//  cell available and they wont be added to neither CPU or GPU)
	this.CreateReplaceOrderQueue();
}

VT.VirtualTexture.prototype.GetParentPageForPage = function(x, y, mip)
{
	if (mip < this.config.mipmaps - 1)
	{
		x = Math.floor(x / 2.0);
		y = Math.floor(y / 2.0);
		mip += 1.0;
	}

	return this.GetIndexFromXYMip(x, y, mip);
}

function remove_if_dub( list, entry )
{
	for (var c = list.length; c >= 0; c--)
	{
		if (list[c] != undefined && list[c].index == entry.index)
		{
			//list[c] = undefined;
			list.splice(c, 1);
		}
	}
}

function check_if_dub( list, index )
{
	for (var c = list.length-1; c >= 0; c--)
	{
		if (list[c] != undefined && list[c].index == index)
		{
			//list[c] = undefined;
			return true;
		}
	}

	return false;
}

function find_dubs( list )
{
	var dubs = {};
	for (var c = list.length-1; c >= 0; c--)
	{
		if (list[c] != undefined)
		{
			if (list[c].index != undefined)
			{
				if (dubs[list[c].index] != undefined)
				{
					console.log("Found dub!");
				}
				dubs[list[c].index] = true;

			} else {
				console.log(list[c]);
			}
			//list[c] = undefined;
		} else {
			console.log("list has one undefined");
		}

	}

}

VT.VirtualTexture.prototype._CheckParents = function(in_list, clean_list, page)
{

	////////////////////////////////
	// check if page parent needs to be loaded
	var parent_index = this.GetParentPageForPage(page.x, page.y, page.miplvl);
	if (!this.SetUsed(parent_index, true) && !this.CheckIncoming(parent_index))
	{


		// parent needs to be loaded first!
		var tx = Math.floor(page.x / 2.0);
		var ty = Math.floor(page.y / 2.0);
		var i  = page.miplvl+1;

		if ( i >= this.config.mipmaps - 1)
		{
			//console.error("WAAAAAAAAAAAAAT");
			return true;
		}

		var parent_page = {}
		parent_page.miplvl  = i;
		parent_page.x 		= tx;
		parent_page.y 		= ty;
		parent_page.index 	= parent_index;
		parent_page.prio 	= 0;
		parent_page.speed   = 1.0;
		//parent_page.force   = false;

		this.levelDiffLUT[parent_page.index] = 0;


		// check if parent is already in any of the two "needed" lists
		if ( !(check_if_dub(in_list, parent_index) || check_if_dub(clean_list, parent_index)) )
		{
			this.neededPagesDict[parent_index] = true;
			clean_list.push(parent_page);
		}
		/*if ( this._CheckParents(in_list, clean_list, parent_page) ) // Check recursively
		{
			//parent_page.force = true;
			//remove_if_dub(in_list, parent_page);
			//remove_if_dub(clean_list, parent_page);
		}*/


	}
};

/* - make sure there is room in receive queue
 */
VT.VirtualTexture.prototype.Analyze = function() {
	
	/*if (!this.needNewPageDeterm)
	{
		this.dirtyPixels = false;
		this.analyzedPageList = true;
		return true;
	}*/
	

	// 1. start analyze if we have new pixels
	if (this.dirtyPixels) // && !this.analyzedPageList)
	{
		this.analyzed_frame = this.frame;

		//console.log("ANALUZEQ!!");
		var clean_list = [];
		this.neededPagesDict = {};
		for (var p in this.neededPages)
		{
			var page = this.neededPages[p];
			if (page != undefined)
			{

				

				//if (!this.SetUsed(page.index, page.prio == 0) && !this.CheckIncoming(page.index))

				// update level diff lut entry for this page
				// used later on when sorting replacement queue
				this.levelDiffLUT[page.index] = page.level_diff;
				
				if (!this.SetUsed(page.index, true) && !this.CheckIncoming(page.index))
				{
					this.neededPagesDict[page.index] = true;
					clean_list.push(page);


					////////////////////////////////
					// check if page parent needs to be loaded
					/*var parent_index = this.GetParentPageForPage(page.x, page.y, page.miplvl);
					if (!this.SetUsed(parent_index, true) && !this.CheckIncoming(parent_index))
					{
						// parent needs to be loaded first!
						var tx = Math.floor(page.x / 2.0);
						var ty = Math.floor(page.y / 2.0);
						var i  = page.miplvl+1;

						if ( i > vt.mipmaps)
						{
							console.error("WAAAAAAAAAAAAAT");
							return;
						}

						var parent_page = {}
						parent_page.miplvl  = i;
						parent_page.x 		= tx;
						parent_page.y 		= ty;
						parent_page.index 	= parent_index;
						parent_page.prio 	= 0;

						clean_list.push(parent_page);

						console.log("needed parent!");

					} else {
						clean_list.push(page);
					}
					*/
				}

				if (this.pageCacheWaitForParents)
				{
					this._CheckParents(this.neededPages, clean_list, page);
				}

			} else {
				console.log("one page was undefined");
			}
		}

		//console.log(clean_list.length);
		this.neededPagesNow = clean_list;

		// find_dubs( this.neededPagesNow );



		/*
		//  check if everyones parent is in the cache first
		
		clean_list = [];
		var dubcheck = {};
		for (var p in this.neededPagesNow)
		{
			var page = this.neededPagesNow[p];
			var has_parent = false;

			var parent_index = this.GetParentPageForPage(page.x, page.y, page.miplvl);
			if (parent_index in this.pageCacheIndexArray)
			{
				has_parent = true;
				if (!(page.index in dubcheck))
					clean_list.push(page);
				dubcheck[page.index] = true;
			} else {

				var tx = Math.floor(page.x / 2.0);
				var ty = Math.floor(page.y / 2.0);
				var i  = page.miplvl+1;

				var parent_page = {}
					parent_page.miplvl  = i;
					parent_page.x 		= tx;
					parent_page.y 		= ty;
					parent_page.index 	= parent_index;
					parent_page.frame 	= this.frame;

				if (!(parent_page.index in dubcheck) && !this.CheckIncoming(parent_page.index))
				{
					clean_list.push(parent_page);
					dubcheck[parent_page.index] = true;
				}
			}



			/*if (!has_parent)
			{
				// calculate first parent data
				var tx = Math.floor(page.x / 2.0);
				var ty = Math.floor(page.y / 2.0);
				var i  = page.miplvl+1;
				var parent_index = this.GetIndexFromXYMip( tx, ty, i );

				var parent_page = {}
					parent_page.miplvl  = i;
					parent_page.x 		= tx;
					parent_page.y 		= ty;
					parent_page.index 	= parent_index;
					parent_page.frame 	= this.frame;

				var prev_parent = parent_page;

				for (i+=1; i < this.config.mipmaps; i++) {
					tx = Math.floor(tx / 2.0);
					ty = Math.floor(ty / 2.0);

					//var parent_index = this.GetParentPageForPage(tx, ty, i);
					var parent_index = this.GetIndexFromXYMip( tx, ty, i );

					//console.log("looking for parent");
					if (parent_index in this.pageCacheIndexArray && this.pageCacheIndexArray[parent_index] != undefined)
					{
						//console.log("found a cool parent");
						if (dubcheck[prev_parent.index] != undefined)
						{
							clean_list.push(prev_parent);
							dubcheck[prev_parent.index] = true;
						} else {
							//console.log("allready found :(");
						}
						break;
					}

					parent_page.miplvl  = i;
					parent_page.x 		= tx;
					parent_page.y 		= ty;
					parent_page.index 	= parent_index;
					parent_page.frame 	= this.frame;

					prev_parent = parent_page;

				};
			} 

		};


		// analyze done!
		this.neededPagesNow = clean_list;*/

		this.dirtyPixels = false;
		//this.analyzedPageList = true;

		//this.pageDetermIntervalCounter = this.pageDetermInterval;

		// generate a new replacement queue that is valid for the new view (and frame id)
		this.CreateReplaceOrderQueue();

		return true;
	}

	return false;
}

VT.VirtualTexture.prototype.CheckCacheDubs = function() {
	var prev = {};
	var double_trouble = 0;

	// for ( var cacheId in this.pageCacheList ) {
	for ( var cacheId = 0; cacheId < this.pageCacheList.length; cacheId++ ) {
		var cache = this.pageCacheList[cacheId];
		var cacheCells = cache.cacheCells;

		for (var y in cacheCells)
		{
			for (var x in cacheCells[y])
			{
				var cell = cacheCells[y][x];

				if (cell != undefined && cell.index != undefined)
				{

					if (cell.index in prev)
					{
						//console.log("Found dub: ", cell.index, cacheId);
						prev[cell.index] += 1;

						double_trouble++;

					} else {
						prev[cell.index] = 1;
					}

				}
			}
		}
	}

	return double_trouble;
}

function _replace_queue_sort(a, b)
{
	// [0] = x, [1] = y, [2] = celldata

	// sort order:
	// best to worst candidates

	// a.frame < b.frame
	// a.miplvl.a < b.miplvl

   /*if(a.frame < b.frame) {
       return -1;
   } else if(a.frame > b.frame) {
       return 1;
   } else {
       return 0;
   }*/

	if (a[2].index == b[2].index) // both are undefined
	{
		//var i = a[1] * 8 + a[0];
		//var j = a[1] * 8 + a[0];
		return 0;
	} else if (a[2].index == undefined) {
		return -1;
	} else if (b[2].index == undefined) {
		return 1;
	}


	if (a[2].frame < b[2].frame)
	{
		return -1;
	} else if (a[2].frame > b[2].frame) {
		return 1;
	} else {
		return 0;
	}

	// create a level diff LUT, updated each time we do a read out... 
	// we don't want to swap out a page with currently higher level diff for a page with lower level diff
	// if we find two pages with the same level diff -> use page index as sorting (we just need any fixed sorting order)
	// (cell index does not work -> same cell will then possibly thrash)

	// if (vt.levelDiffLUT[a[2].index] > vt.levelDiffLUT[b[2].index])
	// {
	// 	return -1;
	// } else if (vt.levelDiffLUT[a[2].index] < vt.levelDiffLUT[b[2].index]) {
	// 	return 1;
	// }

	// if (a[2].index < b[2].index)
	// {
	// 	return -1;
	// } else if (a[2].index > b[2].index) {
	// 	return 1;
	// }

	return 0; // should not happen :-)

}

VT.VirtualTexture.prototype.CreateReplaceOrderQueue = function()
{
	var new_replace_queue = [];

	var cell = 0;

	// for ( var cacheId in this.pageCacheList ) {
	for ( var cacheId = 0; cacheId < this.pageCacheList.length; cacheId++ ) {

		var cache = this.pageCacheList[cacheId];

		for (var y = cache.wrapY; y < this.config.pageCacheSizeY; y++)
		{
			for (var x = 0; x < this.config.pageCacheSizeX; x++)
			{
				cell = cache.cacheCells[y][x];

				// cell = this.pageCacheCells[y][x];

				if (cell !== undefined && cell.lock != undefined)
				{
					// cache.wrapY = y;
					// console.log("Moved wrapY to " + y + ", cacheid: " + cacheId);
				}

				if ( cell 		== undefined ||
					 cell.index == undefined ||
					 (cell.lock == undefined && !(this.incomingPagesDict[cell.index]) && !(this.neededPagesDict[cell.index]))
				   )
					// todo check new request queue ?
				{

					if (cell == undefined)
					{
						cell = { "pc_x" : x, "pc_y" : y, cacheIndex : cacheId };
						cache.cacheCells[y][x] = cell;
						//console.log("creating cell");
					}

					if (cell.index == undefined || ( cell.frame < this.analyzed_frame ))
						new_replace_queue.push([x, y, cell]);
				}
			}
		}
	}


	
	// disabled for now
	// create a queue even if we could not find any free cells
	if (false && new_replace_queue.length <= 0)
	{
		//console.log("Replacing random page");

		// for ( var cacheId in this.pageCacheList ) {
		for ( var cacheId = 0; cacheId < this.pageCacheList.length; cacheId++ ) {

			var cache = this.pageCacheList[cacheId];

			for (var y = cache.wrapY; y < this.config.pageCacheSizeY; y++)
			{
				for (var x = 0; x < this.config.pageCacheSizeX; x++)
				{
					cell = cache.cacheCells[y][x];

					if ( (cell.lock == undefined && !(this.incomingPagesDict[cell.index]))
					   )
						// todo check new request queue ?
					{
						new_replace_queue.push([x, y, cell]);
					}
				}
			}
		}

		/*for ( var cacheId in this.pageCacheList ) {

			var cache = this.pageCacheList[cacheId];

			for (var y = 0; y < this.config.pageCacheSize; y++)
			{
				for (var x = 0; x < this.config.pageCacheSize; x++)
				{
					cell = cache.cacheCells[y][x];

					if (cell.lock == undefined)
					{
						new_replace_queue.push([x, y, cell]);

						//return;
					}
				}
			}

		}

		//console.log("doing random selection");
		new_replace_queue.sort(Math.random);
		new_replace_queue = [new_replace_queue.shift()];
		*/


	}// else {
		// sort queue
		new_replace_queue.sort(_replace_queue_sort);
	//}

	// done!
	this.replaceQueue = new_replace_queue;
}

VT.VirtualTexture.prototype.GetCacheCell = function(  ) {

	var cell = this.replaceQueue.shift();

	if (cell == undefined)
	{
		return undefined;

		//console.log("No more replace candidates!");
		this.CreateReplaceOrderQueue();
		cell = this.GetCacheCell();
		if (cell == undefined)
			return undefined;
	}
	
	if (cell[2].index != undefined)
	{
		this.IndirectTableRemovePage( cell[2].index, cell[2].x, cell[2].y, cell[2].miplvl, cell[2].cacheIndex );

		// if(cell[2].level_diff > max_level_diff)
		// {
		// 	return undefined;
		// }
		
	}

	this.pageCacheIndexArray[cell[2].index] = undefined;
	return cell;

	/*var numCells = this.config.pageCacheSize * this.config.pageCacheSize;
	var cell;

	var startcell = this.pageCacheCellPointer;
	for(var i = (this.pageCacheCellPointer + 1) % numCellsTotal; i != startcell; i++) {
		i = i % numCellsTotal;

		var cacheIndex 	= Math.floor(i / numCellsPerCache);
		var cellIndex 	= i - numCellsPerCache*cacheIndex;
		var pc_x 		= Math.floor(cellIndex % this.config.pageCacheSize);
		var pc_y 		= Math.floor(cellIndex / this.config.pageCacheSize);
		var cacheCells 	= this.pageCacheList[cacheIndex].cacheCells;

		// console.log( i, cacheIndex, pc_y, pc_x);

		var tcell		= cacheCells[pc_y][pc_x];

		if (tcell != undefined && tcell.lock)	
		{
			continue;
		}

		cell = tcell;
		this.pageCacheCellPointer = i;
		
		// create new cell 
		if( cell == undefined ) {
			cell = { "pc_x" : pc_x, "pc_y" : pc_y, cacheIndex : cacheIndex };

			cacheCells[pc_y][pc_x] = cell;

			return cell;

		}	else if ( cell.frame != this.frame ) {

			break;
		}
	}

	this.IndirectTableRemovePage( cell.index, cell.x, cell.y, cell.miplvl, cell.cacheIndex );
	this.pageCacheIndexArray[cell.index] = undefined; 


/*	var startcell = this.pageCacheCellPointer;
	for(var i = (this.pageCacheCellPointer + 1) % numCells; i != startcell; i++) {
		i = i % numCells;

		//console.log(i, this.pageCacheCellPointer);
		var cellIndex 	= i;
		var pc_x 		= Math.floor(cellIndex % this.config.pageCacheSize);
		var pc_y 		= Math.floor(cellIndex / this.config.pageCacheSize);

		var tcell 		= this.pageCacheCells[pc_y][pc_x];	

		if (tcell != undefined && tcell.lock)	
		{
			//console.log("Found page in page cache that is locked, cant replace!");
			continue;
		}
		cell = tcell;
		this.pageCacheCellPointer = cellIndex;

		if( cell == undefined ) {
			cell = { "pc_x" : pc_x, "pc_y" : pc_y };
			this.pageCacheCells[pc_y][pc_x] = cell;
			this.pageCacheIndexArray[cellIndex] = undefined;
			return cell;

		} else if ( cell.frame != this.frame ) {

			// page_id, x, y, mip
			
			break;
		}
	}

	this.IndirectTableRemovePage( cell.index, cell.x, cell.y, cell.miplvl );
	this.pageCacheIndexArray[cell.index] = undefined;*/
	// return cell;

}

VT.VirtualTexture.prototype.UpdateCacheTable = function( cell, page ) {
	cell.miplvl 		= page.miplvl;
	cell.x 				= page.x;
	cell.y 				= page.y;
	cell.index 			= page.index;
	cell.frame 			= this.frame;
	cell.lock 			= page.lock;
	// cell.cacheIndex 	= page.cacheIndex;

	this.pageCacheIndexArray[cell.index] = cell;
}

VT.VirtualTexture.prototype.SetUsed = function(index, update) {
	if(this.pageCacheIndexArray[index]) {
		if (update)
		{
			this.pageCacheIndexArray[index].frame = this.frame;
			this.pageCacheIndexArray[index].timestamp = this.timestamp;
		}
		return true;
	}

	return false;
}


VT.VirtualTexture.prototype.UpdatePageCacheTexture = function(cell,page) {
	var gl 		= this.gl;

	var draw_x 	= cell.pc_x * this.pageRenderWidth; 	//this.config.pageSize * this.config.pageColumns;
	var draw_y 	= cell.pc_y * this.pageRenderHeight;	//config.pageSize * this.config.pageRows;

	if (this.config.cache_mode == VT.CACHE_MODES.CUBE)
	{
		//var texture = this.pageCacheList[cell.cacheIndex].cacheTexture;
		var texture  = this.cacheTexture;
		var cubeFace = this.cacheCubeFaces[cell.cacheIndex];
		draw_y 		 = texture.height - this.pageRenderHeight - draw_y; // start from top-left

		//texture.UploadSub( 
		texture.UploadCubeSub( cubeFace,
			page.image, draw_x, draw_y, this.pageRenderWidth, this.pageRenderHeight );


	} else if (this.config.cache_mode == VT.CACHE_MODES.FLAT ||
		this.config.cache_mode == VT.CACHE_MODES.FLAT_WITH_PARENTS ||
		this.config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED ) {

		var texture = this.pageCacheList[cell.cacheIndex].cacheTexture;
		draw_y 		= texture.height - this.pageRenderHeight - draw_y; // start from top-left

		texture.UploadSub( page.image, draw_x, draw_y, this.pageRenderWidth, this.pageRenderHeight );

	}

	// this.pageCacheTexture.UploadSub( page.image, draw_x, draw_y, this.config.pageSize, this.config.pageSize );	
}

VT.VirtualTexture.prototype.GenerateParentCacheShader = function( ) {

	this.parentCacheShader = new PXF.Shader( this.gl,
		this.config.shaderSourcePath + "VT.ParentCache.vs",
		this.config.shaderSourcePath + "VT.ParentCache.fs", true );

};

VT.VirtualTexture.prototype.UpdateParentCache = function( id ) {

		var gl = this.gl;

		// attach parent texture and bind fbo
		this.parentCacheFBO.Rebuild( this.pageCacheList[id].cacheTextureParents );
		this.parentCacheFBO.Bind();
		this.gl.disable( gl.DEPTH_TEST );
		this.gl.disable( gl.CULL_FACE );
		this.gl.viewport( 0, 0, this.pageCacheList[id].cacheTextureParents.width, this.pageCacheList[id].cacheTextureParents.height );

		// bind cache parent shader..
		this.parentCacheShader.Bind();

		// bind cache texture
		this.pageCacheList[id].cacheTexture.Bind( this.parentCacheShader, "cache_texture", 0 );

		// bind shader and set uniforms
		// this.parentCacheShader.SetUniform( "f", "asd", 0.0 );

		// draw fullscreen quad
		this.parentCacheQuad.Draw( this.parentCacheShader, { position: true, uv0: true, normal: false } );

		// unbind everything
		this.parentCacheShader.Unbind()
		this.parentCacheFBO.Unbind();


		if ( this.config.cache_mode == VT.CACHE_MODES.FLAT_MIPMAPPED )
		{
			this.parentCacheFBO.Bind();
			this.gl.activeTexture( this.gl.TEXTURE0 );
			this.gl.bindTexture( this.gl.TEXTURE_2D, this.pageCacheList[id].cacheTexture.texture );
			this.gl.copyTexSubImage2D( this.gl.TEXTURE_2D, 1, 0, 0, 0, 0, this.pageCacheList[id].cacheTextureParents.width, this.pageCacheList[id].cacheTextureParents.height);
			this.gl.bindTexture( this.gl.TEXTURE_2D, null );
			this.parentCacheFBO.Unbind();
		}


};

VT.VirtualTexture.prototype.PurgeCPUCache = function( purge ) {

	if (!this.pageCacheAutoPurgeCPU)
		return;

	var max_cpu_cache = 256;
	var cpu_cache_count = 0;
	for (var i in this.cpuCache.pages)
	{
		if (this.cpuCache.pages[i] != undefined)
		{
			cpu_cache_count++;
			if ( purge || cpu_cache_count > max_cpu_cache)
			{
				// this.cpuCache.pages[i] = undefined;
				delete this.cpuCache.pages[i];
			}
		}
	}
};


/* - signal streaming on intermediate pages 
 */
VT.VirtualTexture.prototype.RequestPages = function() {
	// 1. can we start streaming?
	//if(!this.analyzedPageList)
	//	return true;

	var has_worker_ready = false;
	for (var w in this.workers) {
		if (this.workers[w].ready) {
			has_worker_ready = true;
			break;
		}
	}

	if (!has_worker_ready)
	{
		return false;
	}

	// console.log("can sent request");


	if (this.neededPagesNow.length <= 0)
	{
		/*
		this.analyzedPageList = false;
		this.dirtyPixels = true;
		this.Analyze();
		*/
		/*
		this.dirtyPixels = true;
		if (this.thrashStop > 0)
		{
			this.thrashStop -= 1;
			this.Analyze();
		}
		*/
		return true;
	}

	
	// 2. go through all needed pages and create page requests
	var neededPageLength = this.neededPagesNow.length;
	//for (var i = 0; i < neededPageLength; i++)
	var pages_per_worker = 1;
	for (var i = 0; i < Math.min(neededPageLength, this.config.requestPagesMax); )
	{

		var pages = [];

		for (var j = 0; j < pages_per_worker; j++)
		{
			var page 	= this.neededPagesNow.shift();
			if (page != undefined)
			{
				// upload from CPU ?
				if (this.cpuCache.pages[ page.index ] != undefined)
				{
					// load page from cpu cache instead
					this.ReceivePage( this.cpuCache.pages[ page.index ] );
					this.debugPageRequestCPUReceive += 1;
					this.neededPagesDict[ page.index ] = undefined;
					//this.ReceivePage( page );
					//console.log("Loaded locally cached page " + page.index);
					//this.RequestPages();
					//i-=1;

				} else {
					var url 	= this.GetUrlFromPage(page);
					page.url 	= url;
					pages.push(page);

				}

			} else {
				if (pages.length == 0)
				{
					return;
				}
			}

		}

		if (pages.length > 0)
		{
			if (this.SendWorkerMessage( "pageRequest", pages ))
			{
				// console.log("sent a cool request");
				for (var j in pages)
				{
					this.incomingPagesDict[ pages[j].index ] = true;
					this.neededPagesDict[ pages[j].index ] = undefined;
				}
				this.debugPageRequestSent += pages.length;
				
			} else {
				// console.log("unable to send :(");
				for (var j in pages)
				{
					this.neededPagesNow.unshift(pages[j]);
				}
				
				break;
			}
		}

		
			i += pages.length;




		/*var page 	= this.neededPagesNow.shift();

		if (page != undefined)
		{
			var pages = [page1];
			var url 	= this.GetUrlFromPage(page1);
			page1.url 	= url;
			if (page2 != undefined)
			{
				var url 	= this.GetUrlFromPage(page2);
				page2.url 	= url;

				pages.unshift(page2);

			}
			if (this.cpuCache.pages[ page.index ] != undefined)
			{
				// load page from cpu cache instead
				this.ReceivePage( this.cpuCache.pages[ page.index ] );
				this.debugPageRequestCPUReceive += 1;
				//this.ReceivePage( page );
				//console.log("Loaded locally cached page " + page.index);
				//this.RequestPages();
				i-=1;

			} else {
				

				// 2.b 
				if (this.SendWorkerMessage( "pageRequest", pages ))
				{
					//this.incomingPages.push( page.index );
					this.incomingPagesDict[ page1.index ] = true;

					if (page2 != undefined)
					{
						this.incomingPagesDict[ page2.index ] = true;
					}

					this.debugPageRequestSent += 2;
					
				} else {
					this.neededPagesNow.unshift(page);
					break;
				}
			//}
		}*/
	}
	

	return true;
}


/* SOURCE C:\Users\Meindbender\Documents\masterthesis\newrepos\pxfvt\src/VT.ProxyWorker.js: */

// DEPENDENCIES: /VT.js

VT.VirtualTexture.prototype.ProxyWorker = function()
{
	var worker = {};

	worker.ready = true;


	worker.log = function(msg){
		console.log("Worker " + this.id + ": " + msg);
	};

	worker.warn = function(msg){
		console.warn("Worker " + this.id + ": " + msg);
	};

	worker.postMessage = function(msg)
	{
	    var msg = msg;
	    var msgType = msg.msgType;
	    var data = msg.data;
	    
	    if(msgType == "config") {
	        // update VT settings in worker
	        this.config = data;
	        this.log( "Worker " + this.id + ": Config updated" );
	        
	    } else if(msgType == "clearlist") {

	        //pagelist = [];
	        this.touched_pages = {};
	        
	        return;

	    } else if(msgType == "makeready") {

	        this.onmessage( { "msgType" : "ready" } );
	        
	        return;
	    
	    } else if(msgType == "pixels") {

		if (data.prio == undefined)
            data.prio = 0;

        this.listConvert(data.bufsize, data.pixels, data.getlist, data.prio);

	    }  else if ( msgType == "pageRequest" ) {
	        var url = this.config.imagePath + data.url;

	        // this.log("Loading image " + url);
	        this.loadImage( url, data );

	    } else {
	        this.log("Unknown message type: " + msgType);
	    }
	}

	worker.hitsort = function(a,b) {
	   if(a.hit > b.hit) {
	       return -1;
	   }else if(a.hit < b.hit) {
	       return 1;
	   } else {
	       return 0;
	   }
	}

	worker.listConvert = function(bufsize, inpixels, getlist, prio) {
	    // Reset touched pages
	    this.touched_pages = {};
	    this.pixels = inpixels;

	    // console.log("Doing list convert..");

	    // Loop all pixels in the page determination texture
	    for (var i = 0; i < bufsize; i+=4) {

	        var indx_mip = Math.floor( this.pixels[i]); // R
	        var indx_x = this.pixels[i+1];// / 255.0;     // G
	        var indx_y = this.pixels[i+2];// / 255.0;     // B
	                                              // A = unused

	        if (indx_x == undefined || indx_y == undefined)
	        {
	            this.log("undefined with indx_mip: " + indx_mip);
	        }


	        if (indx_x != undefined && indx_y != undefined) //(pixels[i] < 9)
	        {
	            // calculate tile index from pixel data...
	            var index = this.config.__mipOffsets[indx_mip] // offsets up until current mip level start
	                        + indx_y * this.config.__mipSizes[indx_mip] + indx_x;

	            var level_diff = Math.max(0, Math.floor(this.pixels[i+3] / 16.0) - indx_mip);
	            var diffprio = level_diff;
	            // var diffprio = Math.pow(2.0, (pixels[i+3] * 2.0)) - 1.0;
	            

	            if (this.touched_pages[index] != undefined)
	                this.touched_pages[index].hit += diffprio;
	            else
	            {
	                //if (indx_mip == 0 && indx_x == 1) {
	                    //console.log(this.pixels[i+1] / 256,this.pixels[i+2] / 256);
	                //}

	                this.touched_pages[index] = {};
	                this.touched_pages[index].hit = diffprio;
	                this.touched_pages[index].index = index;
	                this.touched_pages[index].miplvl = indx_mip;
	                this.touched_pages[index].x = indx_x;
	                this.touched_pages[index].y = indx_y;
	                this.touched_pages[index].prio = prio;

	                this.touched_pages[index].pixel_x = this.pixels[i+1];
	                this.touched_pages[index].pixel_y = this.pixels[i+2];
	            }
	            
	        }
	    }

	    // only send current list back if sender has requested it
	    if (getlist)
	    {
	        //var pages = [];
	        this.pagelist = [];

	        //var i = 0;
	        //var max = 50;
	        for(var k in this.touched_pages)  {
	            //if (i > max)
	            //    break;
	            //i++;
	            this.pagelist.push(this.touched_pages[k]);
	        }

	        this.pagelist.sort(this.hitsort);

	        this.onmessage( { data : { "msgType" : "list", "data" : this.pagelist } });
	    }

	    return;
	}

	worker.loadImage = function(url,data) {

	    var format = this.config.format.toLowerCase()

	    if ( format == "dds") {
	    	this.warn("DDS texture loading for proxy workers is not implemented...");
	    } else {

	    	var img = new Image();

	    	img.data = data;
	    	img.worker = this;
	    	img.onload = function(evt)
	    	{
	    		this.data.image = this;
	    		this.worker.onmessage( { data : { msgType :"requestComplete", data : this.data }} );
	    	};

	    	img.src = url;
	    };
	}

	return worker;
};


/*
importScripts("zlib.js", "png.js", "dds.js", "jpg.js");

console = {
    log: function(msg) { postMessage({ "msgType" : "log", "data" : msg});},
    error: function(msg) { postMessage({"msgType": "error", "data" : msg})}
 };

// var __mipSizes, __mipOffsets;
//var awaitingRawData = false;
//var rawBufferLength = 0;

var config = {};

var pagelist = [];
var touched_pages = {};

onmessage = function(e) {
    
    //data_holder = e.data.data_holder;

    var msg = e.data;
    var msgType = msg.msgType;
    var data = msg.data;
    
    if(msgType == "config") {
        // update VT settings in worker
        config = data;
        console.log( "Config updated" );
        
    } else if(msgType == "clearlist") {

        //pagelist = [];
        touched_pages = {};
        
        return;

    } else if(msgType == "makeready") {

        postMessage( { "msgType" : "ready" } );
        
        return;
    
    } else if(msgType == "pixels") {

        //awaitingRawData = true;
        //rawBufferLength = ;
        if (data.prio == undefined)
            data.prio = 0;

        listConvert(data.bufsize, data.pixels, data.getlist, data.prio);
        //return;


        //var touchedPages = listConvert(e.data.__mipSizes, e.data.__mipOffsets, e.data.pixels);
        //postMessage({t:"list", msg:touchedPages});

        //console.log("Message type not implemented yet!");
    }  else if ( msgType == "pageRequest" ) {
        var url = config.imagePath + data.url;
        loadImage( url, data );

    } else {
        console.log("Unknown message type: " + msgType);
    }
}

function hit_and_prio_sort(a,b) {

    if (a.prio == b.prio) {

        if(a.hit > b.hit) {
            return -1;
        } else if(a.hit < b.hit) {
            return 1;
        } else {
            return 0;
        }

    } else if (a.prio > b.prio) {
        return 1;
    } else {
        return -1;
    }

}
function hit_and_level_sort(a,b) {

    if (a.prio == b.prio) {

        if(a.miplvl > b.miplvl) {
            return -1;
        } else if(a.miplvl < b.miplvl) {
            return 1;
        } else {
            return 0;
        }

    } else if (a.prio > b.prio) {
        return 1;
    } else {
        return -1;
    }

}
function hitsort(a,b) {
   if(a.hit > b.hit) {
       return -1;
   }else if(a.hit < b.hit) {
       return 1;
   } else {
       return 0;
   }
}
function levelsort(a,b) {
   if(a.miplvl < b.miplvl) {
       return -1;
   } else if(a.miplvl > b.miplvl) {
       return 1;
   } else {
       return 0;
   }
}

// fill 
var backup_image_data = new Uint8Array(128 * 256 * 4);
for (var p = 0; p < 128 * 256; p++)
{
    backup_image_data[p*4]   = 0;
    backup_image_data[p*4+1] = 0;
    backup_image_data[p*4+2] = 255;
    backup_image_data[p*4+3] = 255;
}
*/


/* SOURCE C:\Users\Meindbender\Documents\masterthesis\newrepos\pxfvt\src/VT.IndirectionTable.js: */

// DEPENDENCIES: /VT.js
INDIRECT_LAYOUT_FLAT   = 0;
INDIRECT_LAYOUT_MIPMAP = 1;

VT.VirtualTexture.prototype.BuildIndirectionTable = function() {
	
	var gl = this.gl;

	/*
	 * Build blending Texture
	 */
	this.BLENDING_OUT 	= -1;
	this.BLENDING_IN 	=  1;
	if ( !this.config.disable_blending && this.config.use_blending_texture)
	{

		var numPages       = this.config.pageCacheSizeX * this.config.pageCacheSizeY * this.config.numPageCaches;
		var blendingFormat = this.config.blendFormat;
		var blendingCmps   = numPages;
		var numCmps       = 1;

		if ( blendingFormat == gl.RGBA )
		{
			blendingCmps *= 4;
			numCmps      *= 4;
		}

		this.blendingData 	= new Uint8Array( blendingCmps );

		/* Initialize blending data w/ zeroes 
		for(var i = 0; i < blendingCmps; i++) {
			this.blendingData[i] = 0.0;
		}*/

		var blendingParams = {
			minFilter 		: gl.NEAREST,
			magFilter 		: gl.NEAREST,
			format 			: blendingFormat,
			internalFormat 	: blendingFormat
		};

		this.blendingTexture 	= (new PXF.Texture(this.ctx, null, blendingParams)).Upload( this.blendingData, this.config.pageCacheSizeX, this.config.pageCacheSizeY * this.config.numPageCaches );

	} else {

		// Store blending in indirect table
		// TODO

	}
	this.blendingList 		= [];

	this.indirectTableLayout = this.config.indirectTableLayout; //this.GetIndirectionTableLayout();

	if ( this.indirectTableLayout == INDIRECT_LAYOUT_MIPMAP )
	{
		/*
		 * Build Indirect Texture
		 */
		var params = { minFilter : gl.NEAREST_MIPMAP_NEAREST,
		               magFilter : gl.NEAREST,
		               autoGenerateMipmaps : false
		             }; // autoGenerateMipmaps is false since we dont have any data in the texture yet.
		this.indirectTexture = (new PXF.Texture( this.ctx, null, params )).Upload(null, this.config.pageAmount, this.config.pageAmount);
	} else {
		/*
		 * Build Indirect Texture
		 */
		var params = { minFilter : gl.NEAREST,
		               magFilter : gl.NEAREST
		             }; // autoGenerateMipmaps is false since we dont have any data in the texture yet.
		this.indirectTexture = (new PXF.Texture( this.ctx, null, params )).Upload(null, this.config.pageAmount * 2, this.config.pageAmount);
	};

	// generate pixel buffer
	var i, _mipSize, _tableSize = 0;
	for(i = 0; i < this.config.mipmaps; i++) {
		_mipSize = this.__mipSizes[i];
		_tableSize += _mipSize * _mipSize;
	}
	_tableSize *= 4; // 4 channels, RGBA
	
	/*
	 * Build Indirect Table (ie pixel buffer)
	 */
	this.indirectTable = new Uint8Array(_tableSize);

	// reset data
	for(i=0; i < _tableSize; i+=4) {
		this.indirectTable[i]   = 0;                     // x
		this.indirectTable[i+1] = 0;                     // y
		this.indirectTable[i+2] = this.config.mipmaps-1; // mip
		this.indirectTable[i+3] = 0.0;                   // blendingvalue
	};

	/*
	 * Update texture with table data
	 */

	/*
	var _offsets 		= this.__mipOffsets;
	var _mipmapLevels 	= this.config.mipmaps;

	for(var i=0; i < _mipmapLevels; i++) {
		var size = this.__mipSizes[i];  // Math.max(1, Math.floor(256.0 / (Math.pow(2,mm)) ));

		var start = _offsets[i]   * 4;		
		var end   = _offsets[i+1] * 4;
		var pixelData = this.indirectTable.subarray(start,end);	

		this.indirectTexture.Upload( pixelData, size, size, i );
	}*/

	/*
	 * Build flat offsets once (for mipmap updates.)
	 */

	this.__flatOffsets = [0];
	var y_offset = 0;

	for( var mm=1; mm < this.config.mipmaps; mm++ )
	{
		this.__flatOffsets[mm] = y_offset;
		y_offset = y_offset + Math.pow(2, (this.config.mipmaps-1) - mm);
	};

	this.indirectTableDirtyLevel = this.config.mipmaps-1;
	this.indirectTableDirty = true;
	this.UploadIndirectionTexture();
}

VT.VirtualTexture.prototype.UpdateBlending = function() {
	if(this.config.disable_blending) return;

	var pagecountX = this.config.pageCacheSizeX;
	var pagecountY = this.config.pageCacheSizeY;

	function clamp( v, min_v, max_v ) {
		return Math.max( Math.min( max_v, v ), min_v );
	}
	
	// check for dublicates in blendinglist
	//var dubs = {};
	/*for ( var c = 0; c < this.blendingList.length-1; c++ ) {
		for ( var b = c; b < this.blendingList.length; c++ ) {

		}
	}*/

	//var cell;
	//while( true )
	//{
		//console.log("updated " + cell);

	var tlist = [];
	for ( var c = 0; c < this.blendingList.length; c++ ) {

		//var cell 			= this.blendingList.shift();
		var cell 			= this.blendingList[c];
		var speed           = this.config.blendSpeed;

		if (cell.page.speed != undefined)
		{
			speed *= cell.page.speed;
		}

		var dv 				= cell.blendState * speed;
		cell.alpha 		   += dv;
		var blendingDone 	= ( cell.blendState == this.BLENDING_IN && cell.alpha >= 1 ) || ( cell.blendState == this.BLENDING_OUT && cell.alpha <= 0 );

		cell.alpha 			= clamp( cell.alpha, 0, 1 );

		// use separate blending texture
		if (this.config.use_blending_texture)
		{

			// update pixel changes
			var x = cell.pc_x;
			var y = pagecountY * ( this.config.numPageCaches - cell.cacheIndex) - 1 - cell.pc_y;

			if ( this.blendingTexture.format == this.gl.RGBA ){
				var offset = (y*pagecountX + x) * 4;
				var a = cell.alpha * 255.0;
				this.blendingData.set( [a,a,a,a], offset );
			}
			else this.blendingData[ y*pagecountX + x] = cell.alpha * 255.0;

		} else {

			// update indirect table/texture pixels

			// console.log(cell);
			// run=false;
			this.IndirectTableInsertPage(cell.index, cell.x, cell.y, cell.miplvl, cell.pc_x, cell.pc_y, cell.miplvl, cell.cacheIndex, cell.alpha * 255.0) // ( page_id, x, y, mip, pc_x, pc_y, new_mip, pc_ix )

			// todo update whole mip hierarchy
		}

		if ( blendingDone ) {
			var done_str = cell.blendState == this.BLENDING_IN ? "IN" : "OUT";

			cell.alpha = 1.0;

			// console.log("Blending " + done_str + " done on page " + cell.index);
		} else {
			//this.blendingList.push(cell);
			tlist.push(cell);
		}

	}

	this.blendingList = tlist;





/*	for ( var p = 0; p < this.blendingList.length; p++ ) {
		var page 		= this.blendingList.shift();
		var addValue 	= page.blendState * this.config.blendSpeed;

		if ( page.alpha == undefined ) 
			page.alpha 	= page.blendState == this.BLENDING_IN ? 0 : 1;

		page.alpha += addValue;
		page.alpha  = page.alpha > 1 ? 1 : (page.alpha < 0 ? 0 : page.alpha);

		// update pixel changes
		var x = page.pc_x;
		var y = pagecount * ( this.config.numPageCaches - page.cacheIndex) - 1 - page.pc_y;
		
		this.blendingData[ y*pagecount + x] = page.alpha * 255.0;
			
		// if ( page.alpha >= 1 && page.blendState == this.BLENDING_OUT ) {
		if ( page.blendState == this.BLENDING_OUT ) {

			if ( page.alpha > 0 )
				this.blendingList.push(page);
			else {
				console.log("Blend out done, should read in " + page.blendIndex );

				var newPage = this.cpuCache.pages[ page.blendIndex ];

				// var newPage = this.pageCacheIndexArray[ page.blendIndex ];

				// page not in yet, keep blend
				if ( newPage == undefined ) {
					console.log("New page not loaded yet",page.blendIndex);
					this.blendingList.push(page);
				} else {
					newPage.forceToCPU = false;
					this.ReceivePage( newPage );
				}
			}

		} else if ( page.blendState == this.BLENDING_IN ) {

			var newPage = this.cpuCache.pages[ page.blendIndex ];

			if ( page.alpha < 1 ) 
				this.blendingList.push(page);
			else if ( newPage && newPage.blendIndex != undefined ) {
				console.log("Blending in done, should read in", page.blendIndex );
				newPage.forceToCPU = false;
				this.ReceivePage( newPage );
			}

		} else {
			console.log("Wut");
		}
	}*/ 
}

VT.VirtualTexture.prototype.UploadBlendingTexture = function() {
	var gl 	= this.gl;
	var tex = this.blendingTexture;

	if ( !this.config.disable_blending &&  this.config.use_blending_texture)
	{
		this.blendingTexture.Upload( this.blendingData );
	}

	// gl.bindTexture(gl.TEXTURE_2D, tex.texture);
	// gl.texImage2D(gl.TEXTURE_2D, 0,  tex.internalFormat, tex.width, tex.height, 0, tex.format, tex.dataType, this.blendingData);	
}


VT.VirtualTexture.prototype.UploadIndirectionTexture = function() {

	if (!this.indirectTableDirty) {
		return;
	}

	var gl            = this.gl;
	var _offsets      = this.__mipOffsets;
	var _mipmapLevels = this.config.mipmaps;

	// update dirty mipmaps
	// for ( var i=this.config.mipmaps-1; i >= 0; i--) {
	for ( var i=this.indirectTableDirtyLevel; i >= 0; i--) {

		//var mm    = _mipmapLevels - i - 1; // opengl uses increasing mipmap index
		var size  = this.__mipSizes[i];    // Math.max(1, Math.floor(256.0 / (Math.pow(2,mm)) ));
		var start = _offsets[i]   * 4;
		var end   = _offsets[i+1] * 4;

		var pixelData = this.indirectTable.subarray(start,end);	

		if ( this.indirectTableLayout == INDIRECT_LAYOUT_MIPMAP )
			this.indirectTexture.Upload( pixelData, size, size, i );
		else {
			var x=0,y=0;

			if ( i != 0 ){
				x += this.config.pageAmount;
				y = this.__flatOffsets[i];
			}

			this.indirectTexture.UploadSub( pixelData, x, y, size, size );
		}
	}


	this.indirectTableDirtyLevel = 0;
	this.indirectTableDirty = false;
}


// update entry it_index in indirecttable with pagecache index pc_index
VT.VirtualTexture.prototype.IndirectTableInsertPage = function( page_id, x, y, mip, pc_x, pc_y, new_mip, pc_ix, alpha ) {

	var start_index = 4 * page_id;

	if (alpha == undefined)
		alpha = 1;
	if (new_mip == undefined)
		new_mip = mip;

	// need these to check lower levels if they also point to these cell x/y
	var old_pc_x = this.indirectTable[start_index];
	var old_pc_y = this.indirectTable[start_index+1];

	var it_packed  = this.indirectTable[start_index+2];
	var old_pc_mip = Math.floor( (it_packed / 255.0) * 16.0 ); // floor(pageTableEntry.b * 16.0);
	var old_pc_cid = Math.floor( (((it_packed / 255.0) * 16.0) - old_pc_mip) * 16.0);

	// update start pixel
	this.indirectTable[start_index]     = pc_x; // R
	this.indirectTable[start_index + 1] = pc_y; // G

	var packed_mip_cache_id;
	if (this.config.use_blending_texture)
	{
		this.indirectTable[start_index + 2] = new_mip;  // B
		this.indirectTable[start_index + 3] = pc_ix;  // A
	} else {

		// pack mip and cache index [mip, cacheid] in blue channel
		packed_mip_cache_id = (new_mip << 4) | (pc_ix);
		this.indirectTable[start_index + 2] = packed_mip_cache_id;

		// store blending value in alpha channel
		this.indirectTable[start_index + 3] = alpha;
	}


	// this mip level has to be updated
	this.indirectTableDirty = true;
	if (this.indirectTableDirtyLevel < mip) {
		this.indirectTableDirtyLevel = mip;
	}

	// update all entries above this one, if they used the same old cell x/y
	var pixel_count = 1;
	for (var i = mip-1; i >= 0; --i) {
		
		// correct indirect table x/y
		y *= 2;
		x *= 2;

		// pixel count doubles each new mip map level
		pixel_count *= 2;

		for(var c = 0; c < pixel_count * pixel_count; c++) {
			var px = c % pixel_count;
			var py = Math.floor(c / pixel_count);
				
			var sub_index = 4 * (this.__mipOffsets[i] + (y+py) * this.__mipSizes[i] + (x+px));

			var it_packed  = this.indirectTable[sub_index+2];
			var _pc_mip = Math.floor( (it_packed / 255.0) * 16.0 ); // floor(pageTableEntry.b * 16.0);
			var _cid = Math.floor( (((it_packed / 255.0) * 16.0) - _pc_mip) * 16.0);

			if (old_pc_x == this.indirectTable[sub_index] && old_pc_y == this.indirectTable[sub_index+1] && old_pc_mip == _pc_mip && old_pc_cid == _cid)
			{
				this.indirectTable[sub_index]     = pc_x; // R
				this.indirectTable[sub_index + 1] = pc_y; // G

				if (this.config.use_blending_texture)
				{
					this.indirectTable[sub_index + 2] = new_mip; // B
					this.indirectTable[sub_index + 3] = pc_ix;   // A
					
				} else {

					// pack mip and cache index [mip, cacheid] in blue channel
					this.indirectTable[sub_index + 2] = packed_mip_cache_id;

					// store blending value in alpha channel
					this.indirectTable[sub_index + 3] = alpha;
				}

			}
		}

	}
}

VT.VirtualTexture.prototype.IndirectTableRemovePage = function(page_id, x, y, mip, pc_ix) { //, new_mip) {

	// look for page above to propagate
	var x_b = Math.floor(x / 2);
	var y_b = Math.floor(y / 2);
	var m_b = mip + 1;
	if (m_b > this.config.mipmaps-1)
	{
		m_b = this.config.mipmaps-1;
	}
	var index_b =  4 * (this.__mipOffsets[m_b] + (y_b) * this.__mipSizes[m_b] + (x_b));

	var old_mip;
	var old_cache_index;
	if (this.config.use_blending_texture)
	{
		old_mip = this.indirectTable[index_b + 2]; // B
		old_cache_index = this.indirectTable[index_b + 3];   // A
		
	} else {

		// pack mip and cache index [mip, cacheid] in blue channel
		old_mip = (this.indirectTable[index_b + 2] & 0xF0) >> 4;
		old_cache_index = (this.indirectTable[index_b + 2] & 0x0F);
	}

	/*
	var _newBlendingList = [];
	for (var i = 0; i < this.blendingList.length; i++) {
		if( this.blendingList[i].index != old_cache_index)
		{
			_newBlendingList.push(this.blendingList[i]);
		}
	};
	this.blendingList = _newBlendingList;
	*/

	this.IndirectTableInsertPage(
		page_id, x, y, mip, 
		this.indirectTable[index_b], this.indirectTable[index_b+1], old_mip, old_cache_index, 255.0 );

}



/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/core/utils.js: */

/* http://stackoverflow.com/questions/950087/how-to-include-a-javascript-file-in-another-javascript-file */
load_external_script = function(path,cb)
{
    var ele   = document.createElement("script");
    ele.type  = "text/javascript";
    ele.src   = path;
    ele.onreadystatechange = cb;
    ele.onload = cb;

    var head = document.getElementsByTagName("head")[0];
    head.appendChild(ele);
};

// 
NOT_WORKING_load_external_script_sync = function(path)
{
    var ele   = document.createElement("script");
    ele.type  = "text/javascript";
    ele.src   = path;
    ele.asyc  = false;

    var head = document.getElementsByTagName("head")[0];
    head.appendChild(ele);
};


/* string.format(format_str)
 * usage: "{0}.{1}".format("cool","beans")
 * result: "cool.beans"
 * from: http://stackoverflow.com/questions/1038746/equivalent-of-string-format-in-jquery
 */
String.prototype.format = String.prototype.f = function() {
    var s = this,
        i = arguments.length;

    while (i--) {
        s = s.replace(new RegExp('\\{' + i + '\\}', 'gm'), arguments[i]);
    }
    return s;
};

var args_to_list = function(args) { return Array.prototype.slice.call(args, 0); };

// todo: already exists in PXF.js BRO
var extend = function (obj1, obj2) {
    for (var i in obj2) {
        if (!obj2.hasOwnProperty(i)) continue;
        obj1[i] = obj2[i];
    }

    return obj1;
};


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/core/timeline.js: */

porcupine.timeline = function( instance )
{
	this.groups   = {};
	this.instance = instance;

	var count  = function()	{ return this.samples.length; };
	var length = function() { return this.end - this.begin; };

	this.get = function(id)
	{
		return this.groups[id];
	}

	this.touch = function(id)
	{
		if(!this.groups[id])
		{
			this.groups[id]         = {};
			this.groups[id].samples = [];
			this.groups[id].begin   = this.instance.get_tick_count_seconds();
			this.groups[id].count   = count.bind(this.groups[id]);
			this.groups[id].length  = length.bind(this.groups[id]);
		};

		var now       = this.instance.get_tick_count_seconds();
		var newsample = { timestamp : now };

		this.groups[id].samples.push( newsample );
		this.groups[id].end = now;

		return this.groups[id];
	};
}


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/lib/base64.js: */

/* 
	Taken from stackoverflow somewhere...
*/
function base64ArrayBuffer( bytes ) {
  var base64    = ''
  var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

  var byteLength    = bytes.byteLength
  var byteRemainder = byteLength % 3
  var mainLength    = byteLength - byteRemainder

  var a, b, c, d
  var chunk

  // Main loop deals with bytes in chunks of 3
  for (var i = 0; i < mainLength; i = i + 3) {
    // Combine the three bytes into a single integer
    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

    // Use bitmasks to extract 6-bit segments from the triplet
    a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
    b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
    c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
    d = chunk & 63               // 63       = 2^6 - 1

    // Convert the raw binary segments to the appropriate ASCII encoding
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
  }

  // Deal with the remaining bytes and padding
  if (byteRemainder == 1) {
    chunk = bytes[mainLength]

    a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

    // Set the 4 least significant bits to zero
    b = (chunk & 3)   << 4 // 3   = 2^2 - 1

    base64 += encodings[a] + encodings[b] + '=='
  } else if (byteRemainder == 2) {
    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

    a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
    b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

    // Set the 2 least significant bits to zero
    c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

    base64 += encodings[a] + encodings[b] + encodings[c] + '='
  }

  return base64
}

/* 
	Taken from stackoverflow somewhere...
*/
decodeBase64 = function(s) {
    var e={},i,b=0,c,x,l=0,a,r='',w=String.fromCharCode,L=s.length;
    var A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(i=0;i<64;i++){e[A.charAt(i)]=i;}
    for(x=0;x<L;x++){
        c=e[s.charAt(x)];b=(b<<6)+c;l+=6;
        while(l>=8){((a=(b>>>(l-=8))&0xff)||(x<(L-2)))&&(r+=w(a));}
    }
    return r;
};

decodeBase64_array = function(s) {
    var out_array = [];
    var e={},i,b=0,c,x,l=0,a,r='',w=String.fromCharCode,L=s.length;
    var A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(i=0;i<64;i++){e[A.charAt(i)]=i;}
    for(x=0;x<L;x++){
        c=e[s.charAt(x)];b=(b<<6)+c;l+=6;
        while(l>=8){((a=(b>>>(l-=8))&0xff)||(x<(L-2)))&&(out_array.push(a));}
    }
    return out_array;
};


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/porcupine.js: */

/// Porcupine.js 
/// 
/// 
porcupine.instance_stack = [];

porcupine.instance = function( canvas, config, unsupport_callback )
{
	extend(this,config);

	this.mode     = this.debug && "debug" || "release";
	this.id       = porcupine.instance_stack.length;
	this.canvas   = canvas;
	this.settings = {};
	this._unloaded_resources = {};
	this.resources = {};


	/***************************************	
	*	internal
	*	--------
	*	initializes engine once
	*
	****************************************/
	this.initialize = function()
	{
		if(!this.canvas) this.warn("Instance " + this.id + " has no canvas object..");

		/* add timeline for engine timing */
		this.timeline = new porcupine.timeline( this );
		this.timeline.touch("boot");

		this.canvas.screencanvas = false;

		porcupine._apply_instance_callbacks();

		this.screenmanager = new porcupine.screenmanager( this );
		this.push_screen( this.bootscreen() );

		// rendering context
		this.ctx = new PXF.Instance( this.settings.width, this.settings.height, this.canvas,  true, true, true, true, true );

		// verify webgl support
		if (!this.ctx.gl)
		{
			if (unsupport_callback)
			{
				unsupport_callback(this);
			} else {
				var error_div = document.createElement("div");
				error_div.innerHTML = this.canvas.innerHTML;

				// copy styles
				for (var s in this.canvas.style)
				{
					var v = this.canvas.style[s];
					error_div.style[s] = v;
				}

				var parent = this.canvas.parentNode;
				// console.log(parent);
				// console.log(this.canvas);
				parent.replaceChild(error_div, this.canvas);
				// this.canvas.parentNode.appendChild(error_div);
			}


			return;
		}

		this.set_canvas_scale( this.settings.scale || 1 );

		// enable gesturing
		this.ctx.SetGesture( null, this.canvas );

		// "finish" boot timing
		this.timeline.touch("boot");

		this.debug("Engine bootup took " + this.timeline.get("boot").length() + " seconds.");
	};

	// BOY?

	this.set_canvas_scale = function(scale)
	{
		if( this.settings.scale == scale ) return;

		this.settings.scale = scale;
		this.resize( this );
	}

	/***************************************	
	*	public
	*	--------
	*	resizes the canvas based on
	*   engine scale factors..
	*
	****************************************/
	this.resize = function()
	{
		var engine_width = this.settings.scale * this.canvas.clientWidth;
		var engine_height = this.settings.scale * this.canvas.clientHeight;

		this.canvas.width  = engine_width;
		this.canvas.height = engine_height;

		this.settings.width = engine_width;
		this.settings.height = engine_height;

		this.settings.aspect = engine_width / engine_height;

		if ( this.ctx )
		{
			this.ctx.ctxWidth = engine_width;
			this.ctx.ctxHeight = engine_height;
		};

		this.debug("Resizing engine to ({0},{1})".format(engine_width,engine_height));

		this.screenmanager.resize( engine_width, engine_height );
	};

	this.destroy = function()
	{
		this.debug("Engine shutting down.. good bye");
		this.ctx.CleanUp();
	};

	/***************************************	
	*	internal
	*	--------
	*	bookkeeping for frame meta data
	*
	****************************************/
	this.framecontrol = { 
		tickrate         : 60,
		skipticks        : 1000 / 60,
		maxframeskip     : 5,
		nexttick         : 0,
		instancestart    : Date.now(),
		updateiterations : 0,
		last_sampled     : 0,
		accumulator      : 0,
		fps              : 0,
		frames           : 0,
		framecounter     : 0,
		frametimer       : Date.now()
	};


	/***************************************	
	*	internal
	*	--------
	*	set number of game state updates / s
	*   is not related to the actual frames 
	*   that are rendered each second
	*   
	****************************************/
	this.set_tickrate = function(tr) { 
		this.framecontrol.tickrate = tr;
		this.framecontrol.skipticks = 1000/tr;
	};

	this.get_tick_count_seconds = function()
	{
		return (Date.now() - this.framecontrol.instancestart)/1000;	
	}

	this.get_tick_count = function()
	{
	    return Date.now() - this.framecontrol.instancestart;
	}

	/***************************************	
	*	public
	*	--------
	*	console log wrappers, calls to 
	*   "instance.log(msg)" pretty prints
	*   w/ time prefix
	*
	****************************************/
	this.log = function() { 
		porcupine.log_instance( this, console.log, arguments );
	};

	this.debug = function() {
		if ( this.mode == "debug" )
			porcupine.log_instance( this, console.debug, arguments );
	};

	this.warn = function() { 
		porcupine.log_instance( this, console.warn, arguments );
	};

	this.error = function() { 
		porcupine.log_instance( this, console.error, arguments );
	};

	/***************************************	
	*	public
	*	--------
	*	set engine "run" state
	*   e.g "running", "stopped", "paused" ..
	*
	****************************************/
	this.set_state = function(st)
	{
		this.state = st;
		this.debug( "Instance set to state : {0}".format( porcupine.STATE_TO_STRING[this.state] ) );
	};

	/***************************************	
	*	public
	*	--------
	*	compiles frame meta data such as fps
	*
	****************************************/
	this.postframe = function()
	{
		var now = Date.now();
		var dt  = now - this.framecontrol.frametimer;

		this.framecontrol.frames++;
		this.framecontrol.framecounter += dt/1000;
		this.framecontrol.frametimer = now;

		if ( this.framecontrol.framecounter >= 1 )
		{
			this.framecontrol.fps = this.framecontrol.frames;
			this.framecontrol.framecounter = 0;
			this.framecontrol.frames = 0;
			this.framecontrol.updateiterations = 0;
		};
	}

	this.__defaultengineloop = function() {
		// update
		var iterationsdone   = 0;
		var time_now         = this.get_tick_count();
		var time_dt          = (time_now - this.framecontrol.last_sampled)/1000;

		if ( time_dt > 0.25 )
			time_dt = 0.25;

		this.framecontrol.last_sampled = time_now;
		this.framecontrol.accumulator += time_dt;

		if ( this.state == porcupine.STATE.RUNNING )
		{
			// reset PXF frame state (drawcalls etc.)
			this.ctx.FrameBegin();

			// update PXF Input state
			this.ctx.UpdateInput();

			this.screenmanager.update( time_dt );

			/*
			// make sure we are running at non-framerate-bounded update
			while( time_now > this.framecontrol.nexttick && iterationsdone < this.framecontrol.maxframeskip )
			{
				this.framecontrol.nexttick += this.framecontrol.skipticks;
				iterationsdone++;

				// update all screens
				this.screenmanager.update( this.framecontrol.tickrate / 1000 );
			};
			*/

			// reset PXF Input state
			this.ctx.ResetInput();

			this.framecontrol.updateiterations += iterationsdone;

			// render
			this.screenmanager.render();

			// post-frame screenshot
			if ( this.__awaitingScreenshot )
			{
				var _screenshotdata = this.ctx.Screenshot( this.__awaitingScreenshotOpenInWindow );
				this.__awaitingScreenshotCb && this.__awaitingScreenshotCb( _screenshotdata );

				delete this.__awaitingScreenshot;
				delete this.__awaitingScreenshotOpenInWindow;
				delete this.__awaitingScreenshotCb;
			};
		};

		// update frame info etc..
		this.postframe();
	};

	this.set_renderloop = function(fn)
	{
		this.debug("Setting new renderloop");
		this.__engineloop = fn;
	};
 
	/***************************************	
	*	public
	*	--------
	*	"main" function for engine
	*   performs successive calls to 
	*   rendering function and updates the 
	*   engine state etc.
	*
	****************************************/
	this.run = function() {
		this.set_state( porcupine.STATE.RUNNING );

		if(!this.__engineloop) this.set_renderloop(this.__defaultengineloop);

		var __wrappedloop = function()
		{	
			this.__engineloop();

			requestAnimationFrame( __wrappedloop );
		}.bind(this);

		// start rendering
		__wrappedloop();
	};

	/***************************************	
	*	public
	*	--------
	*   deduce which device this is running on
	*   ie, desktop/mobile and os/browser etc
	*
	****************************************/
	this.get_device = function()
	{
		if ( this.device ) return this.device;

		this.device = {};
		this.device.family = "desktop";

		// todo: parse userstring?
		if ( PXF.IsIOSContext() || PXF.IsAndroidContext() )
		{
			this.device.family = "mobile";

			if ( PXF.IsIOSContext() )
			{
				this.device.platform = "iOS";
			} else if ( PXF.IsAndroidContext() ) {
				this.device.platform = "android";
			}
		} 

		return this.device;
	};

	this.screenshot = function( openInWindow,cb )
	{
		this.__awaitingScreenshot   = true;
		this.__awaitingScreenshotCb = cb;
		this.__awaitingScreenshotOpenInWindow = openInWindow;
	}

	this.set_screenshot_button = function(btn,cb)
	{

		this.ctx.RegisterKeyCallback( btn, function(state, c) {
			if ( state == "up")
				this.screenshot( cb );
		}.bind( this ));

		// this.screenmanager.old_render = this.screenmanager.render;
		// this.screenmanager.render = function()
		// {
		// 	this.screenmanager.old_render.apply( this.screenmanager, arguments );

		// 	if ( this.__awaitingScreenshot )
		// 	{
		// 		this.ctx.Screenshot();
		// 		this.onscreenshot && this.onscreenshot();
		// 		delete this.__awaitingScreenshot;
		// 	};


		// }.bind(this);
	};

	porcupine.instance_stack.push(this);

	this.initialize();
};

/***************************************	
*	public
*	--------
*	engine state enums
*
****************************************/
porcupine.STATE = { RUNNING : 2, PAUSED : 1, STOPPED : 0 };
porcupine.STATE_TO_STRING = ["STOPPED","PAUSED","RUNNING"];

/***************************************	
*	internal
*	--------
*   Porcupine engine callbacks for resize
*   and destroy events.  
*
****************************************/
porcupine._resizeHandler = function() 
{
	for ( var i in porcupine.instance_stack )
	{
		porcupine.instance_stack[i].resize();
	};
};

porcupine._unloadHandler = function() 
{
	for ( var i in porcupine.instance_stack )
	{
		porcupine.instance_stack[i].destroy();
	};
};

porcupine._apply_instance_callbacks = function()
{
	if(!document.body) this.warn("engine does not have a document.body to attach bindings to..");

	document.body.onresize = porcupine._resizeHandler;
	window.onbeforeunload  = porcupine._unloadHandler;
};


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/lib/png.js: */

// DEPENDENCIES: /lib/zlib.js

//(function() {
  /*
  # MIT LICENSE
  # Copyright (c) 2011 Devon Govett
  # 
  # Permission is hereby granted, free of charge, to any person obtaining a copy of this 
  # software and associated documentation files (the "Software"), to deal in the Software 
  # without restriction, including without limitation the rights to use, copy, modify, merge, 
  # publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons 
  # to whom the Software is furnished to do so, subject to the following conditions:
  # 
  # The above copyright notice and this permission notice shall be included in all copies or 
  # substantial portions of the Software.
  # 
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING 
  # BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
  # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
  # DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */  var PNG;
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
  PNG = (function() {
    var APNG_BLEND_OP_OVER, APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_NONE, APNG_DISPOSE_OP_PREVIOUS, makeImage, scratchCanvas, scratchCtx;
    PNG.load = function(indata, canvas, callback) { /*url, canvas, callback) {*/
      url = indata.url;
      try {
        var xhr;
        if (typeof canvas === 'function') {
          callback = canvas;
        }
        xhr = new XMLHttpRequest;
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        xhr.onerror = function(e) {
            console.log("something went wrong while onerror: " + url + ", " + xhr.status + ", " + this.readyState);
            callback(indata.index);
         };
        xhr.onreadystatechange = function() {
            // in case of network errors this might not give reliable results
            if(this.readyState == 4)// this.DONE)
            {
              if (xhr.status != 200)
              {

                console.log("something went wrong while onreadystatechange: " + url + " , " + xhr.status);
                callback(indata.index);
              //returnStatus(this.status);
              } else {

                var data, png;
                data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
                png = new PNG(data,indata.index);
                callback(png);

              }

              // console.log("im done");
            }
          };
        xhr.onload = __bind(function() {
          // if (this.readyState != 4 || xhr.status != 200)
          //   console.log("woah dude");
          // var data, png;
          // data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
          // png = new PNG(data,indata.index);
          // if (typeof (canvas != null ? canvas.getContext : void 0) === 'function') {
          //   png.render(canvas);
          // }
          // return typeof callback === "function" ? callback(png) : void 0;
        }, this);
        return xhr.send(null);
      } catch (e) {
        console.error("WebWorker catched an error: " + e.message);
      }
    };
	PNG.parse = function(data, index) {
		var png;
		png = new PNG(data,index);
		return png;
	};
    APNG_DISPOSE_OP_NONE = 0;
    APNG_DISPOSE_OP_BACKGROUND = 1;
    APNG_DISPOSE_OP_PREVIOUS = 2;
    APNG_BLEND_OP_SOURCE = 0;
    APNG_BLEND_OP_OVER = 1;
    function PNG(data,index) {
      var chunkSize, colors, delayDen, delayNum, frame, i, section, short, _ref;
      this.index = index;
      this.data = data;
      this.pos = 8;
      this.palette = [];
      this.imgData = [];
      this.transparency = {};
      this.animation = null;
      frame = null;
      while (true) {
        chunkSize = this.readUInt32();
        section = ((function() {
          var _results;
          _results = [];
          for (i = 0; i < 4; i++) {
            _results.push(String.fromCharCode(this.data[this.pos++]));
          }
          return _results;
        }).call(this)).join('');
        switch (section) {
          case 'IHDR':
            this.width = this.readUInt32();
            this.height = this.readUInt32();
            this.bits = this.data[this.pos++];
            this.colorType = this.data[this.pos++];
            this.compressionMethod = this.data[this.pos++];
            this.filterMethod = this.data[this.pos++];
            this.interlaceMethod = this.data[this.pos++];
            break;
          case 'acTL':
            this.animation = {
              numFrames: this.readUInt32(),
              numPlays: this.readUInt32() || Infinity,
              frames: []
            };
            break;
          case 'PLTE':
            this.palette = this.read(chunkSize);
            break;
          case 'fcTL':
            if (frame) {
              this.animation.frames.push(frame);
            }
            this.pos += 4;
            frame = {
              width: this.readUInt32(),
              height: this.readUInt32(),
              xOffset: this.readUInt32(),
              yOffset: this.readUInt32()
            };
            delayNum = this.readUInt16();
            delayDen = this.readUInt16() || 100;
            frame.delay = 1000 * delayNum / delayDen;
            frame.disposeOp = this.data[this.pos++];
            frame.blendOp = this.data[this.pos++];
            frame.data = [];
            break;
          case 'IDAT':
          case 'fdAT':
            if (section === 'fdAT') {
              this.pos += 4;
              chunkSize -= 4;
            }
            data = (frame != null ? frame.data : void 0) || this.imgData;
            for (i = 0; 0 <= chunkSize ? i < chunkSize : i > chunkSize; 0 <= chunkSize ? i++ : i--) {
              data.push(this.data[this.pos++]);
            }
            break;
          case 'tRNS':
            this.transparency = {};
            switch (this.colorType) {
              case 3:
                this.transparency.indexed = this.read(chunkSize);
                short = 255 - this.transparency.indexed.length;
                if (short > 0) {
                  for (i = 0; 0 <= short ? i < short : i > short; 0 <= short ? i++ : i--) {
                    this.transparency.indexed.push(255);
                  }
                }
                break;
              case 0:
                this.transparency.grayscale = this.read(chunkSize)[0];
                break;
              case 2:
                this.transparency.rgb = this.read(chunkSize);
            }
            break;
          case 'IEND':
            if (frame) {
              this.animation.frames.push(frame);
            }
            this.colors = (function() {
              switch (this.colorType) {
                case 0:
                case 3:
                case 4:
                  return 1;
                case 2:
                case 6:
                  return 3;
              }
            }).call(this);
            this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
            colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
            this.pixelBitlength = this.bits * colors;
            this.colorSpace = (function() {
              switch (this.colors) {
                case 1:
                  return 'DeviceGray';
                case 3:
                  return 'DeviceRGB';
              }
            }).call(this);
            this.imgData = new Uint8Array(this.imgData);
            return;
          default:
            this.pos += chunkSize;
        }
        this.pos += 4;
      }
      return;
    }
    PNG.prototype.read = function(bytes) {
      var i, _results;
      _results = [];
      for (i = 0; 0 <= bytes ? i < bytes : i > bytes; 0 <= bytes ? i++ : i--) {
        _results.push(this.data[this.pos++]);
      }
      return _results;
    };
    PNG.prototype.readUInt32 = function() {
      var b1, b2, b3, b4;
      b1 = this.data[this.pos++] << 24;
      b2 = this.data[this.pos++] << 16;
      b3 = this.data[this.pos++] << 8;
      b4 = this.data[this.pos++];
      return b1 | b2 | b3 | b4;
    };
    PNG.prototype.readUInt16 = function() {
      var b1, b2;
      b1 = this.data[this.pos++] << 8;
      b2 = this.data[this.pos++];
      return b1 | b2;
    };
    PNG.prototype.decodePixels = function(data) {
      var byte, col, filter, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, rowData, s, scanlineLength, upper, upperLeft, _ref, _step;
      if (data == null) {
        data = this.imgData;
      }
      if (data.length === 0) {
        return [];
      }
      data = new FlateStream(data);
      data = data.getBytes();
      pixelBytes = this.pixelBitlength / 8;
      scanlineLength = pixelBytes * this.width;
      row = 0;
      pixels = [];
      length = data.length;
      pos = 0;
      while (pos < length) {
        filter = data[pos++];
        i = 0;
        rowData = [];
        switch (filter) {
          case 0:
            while (i < scanlineLength) {
              rowData[i++] = data[pos++];
            }
            break;
          case 1:
            while (i < scanlineLength) {
              byte = data[pos++];
              left = i < pixelBytes ? 0 : rowData[i - pixelBytes];
              rowData[i++] = (byte + left) % 256;
            }
            break;
          case 2:
            while (i < scanlineLength) {
              byte = data[pos++];
              col = (i - (i % pixelBytes)) / pixelBytes;
              upper = row === 0 ? 0 : pixels[row - 1][col][i % pixelBytes];
              rowData[i++] = (upper + byte) % 256;
            }
            break;
          case 3:
            while (i < scanlineLength) {
              byte = data[pos++];
              col = (i - (i % pixelBytes)) / pixelBytes;
              left = i < pixelBytes ? 0 : rowData[i - pixelBytes];
              upper = row === 0 ? 0 : pixels[row - 1][col][i % pixelBytes];
              rowData[i++] = (byte + Math.floor((left + upper) / 2)) % 256;
            }
            break;
          case 4:
            while (i < scanlineLength) {
              byte = data[pos++];
              col = (i - (i % pixelBytes)) / pixelBytes;
              left = i < pixelBytes ? 0 : rowData[i - pixelBytes];
              if (row === 0) {
                upper = upperLeft = 0;
              } else {
                upper = pixels[row - 1][col][i % pixelBytes];
                upperLeft = col === 0 ? 0 : pixels[row - 1][col - 1][i % pixelBytes];
              }
              p = left + upper - upperLeft;
              pa = Math.abs(p - left);
              pb = Math.abs(p - upper);
              pc = Math.abs(p - upperLeft);
              if (pa <= pb && pa <= pc) {
                paeth = left;
              } else if (pb <= pc) {
                paeth = upper;
              } else {
                paeth = upperLeft;
              }
              rowData[i++] = (byte + paeth) % 256;
            }
            break;
          default:
            throw new Error("Invalid filter algorithm: " + filter);
        }
        s = [];
        for (i = 0, _ref = rowData.length, _step = pixelBytes; 0 <= _ref ? i < _ref : i > _ref; i += _step) {
          s.push(rowData.slice(i, i + pixelBytes));
        }
        pixels.push(s);
        row += 1;
      }
      return pixels;
    };
    PNG.prototype.decodePalette = function() {
      var alpha, decodingMap, i, index, palette, pixel, transparency, _ref, _ref2, _ref3, _step;
      palette = this.palette;
      transparency = (_ref = this.transparency.indexed) != null ? _ref : [];
      decodingMap = [];
      index = 0;
      for (i = 0, _ref2 = palette.length, _step = 3; 0 <= _ref2 ? i < _ref2 : i > _ref2; i += _step) {
        alpha = (_ref3 = transparency[index++]) != null ? _ref3 : 255;
        pixel = palette.slice(i, i + 3).concat(alpha);
        decodingMap.push(pixel);
      }
      return decodingMap;
    };
    PNG.prototype.copyToImageData = function(imageData, pixels) {
      var alpha, byte, colors, data, i, palette, pixel, row, v, _i, _j, _k, _len, _len2, _len3, _ref;
      colors = this.colors;
      palette = null;
      alpha = this.hasAlphaChannel;
      if (this.palette.length) {
        palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
        colors = 4;
        alpha = true;
      }
      data = imageData.data;
      i = 0;
      for (_i = 0, _len = pixels.length; _i < _len; _i++) {
        row = pixels[_i];
        for (_j = 0, _len2 = row.length; _j < _len2; _j++) {
          pixel = row[_j];
          if (palette) {
            pixel = palette[pixel];
          }
          if (colors === 1) {
            v = pixel[0];
            data[i++] = v;
            data[i++] = v;
            data[i++] = v;
            data[i++] = pixel[1] || 255;
          } else {
            for (_k = 0, _len3 = pixel.length; _k < _len3; _k++) {
              byte = pixel[_k];
              data[i++] = byte;
            }
            if (!alpha) {
              data[i++] = 255;
            }
          }
        }
      }
    };
    /*scratchCanvas = document.createElement('canvas');
    scratchCtx = scratchCanvas.getContext('2d');
    makeImage = function(imageData) {
      var img;
      scratchCtx.width = imageData.width;
      scratchCtx.height = imageData.height;
      scratchCtx.clearRect(0, 0, imageData.width, imageData.height);
      scratchCtx.putImageData(imageData, 0, 0);
      img = new Image;
      img.src = scratchCanvas.toDataURL();
      return img;
    };*/
    /*PNG.prototype.decodeFrames = function(ctx) {
      var frame, i, imageData, pixels, _len, _ref, _results;
      if (!this.animation) {
        return;
      }
      _ref = this.animation.frames;
      _results = [];
      for (i = 0, _len = _ref.length; i < _len; i++) {
        frame = _ref[i];
        imageData = ctx.createImageData(frame.width, frame.height);
        pixels = this.decodePixels(new Uint8Array(frame.data));
        this.copyToImageData(imageData, pixels);
        frame.imageData = imageData;
        _results.push(frame.image = makeImage(imageData));
      }
      return _results;
    };
    PNG.prototype.renderFrame = function(ctx, number) {
      var frame, frames, prev;
      frames = this.animation.frames;
      frame = frames[number];
      prev = frames[number - 1];
      if (number === 0) {
        ctx.clearRect(0, 0, this.width, this.height);
      }
      if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND) {
        ctx.clearRect(prev.xOffset, prev.yOffset, prev.width, prev.height);
      } else if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS) {
        ctx.putImageData(prev.imageData, prev.xOffset, prev.yOffset);
      }
      if (frame.blendOp === APNG_BLEND_OP_SOURCE) {
        ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);
      }
      return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);
    };
    PNG.prototype.animate = function(ctx) {
      var doFrame, frameNumber, frames, numFrames, numPlays, _ref;
      frameNumber = 0;
      _ref = this.animation, numFrames = _ref.numFrames, frames = _ref.frames, numPlays = _ref.numPlays;
      return (doFrame = __bind(function() {
        var f, frame;
        f = frameNumber++ % numFrames;
        frame = frames[f];
        this.renderFrame(ctx, f);
        if (numFrames > 1 && frameNumber / numFrames < numPlays) {
          return this.animation._timeout = setTimeout(doFrame, frame.delay);
        }
      }, this))();
    };
    PNG.prototype.stopAnimation = function() {
      var _ref;
      return clearTimeout((_ref = this.animation) != null ? _ref._timeout : void 0);
    };
    PNG.prototype.render = function(canvas) {
      var ctx, data;
      if (canvas._png) {
        canvas._png.stopAnimation();
      }
      canvas._png = this;
      canvas.width = this.width;
      canvas.height = this.height;
      ctx = canvas.getContext("2d");
      if (this.animation) {
        this.decodeFrames(ctx);
        return this.animate(ctx);
      } else {
        data = ctx.createImageData(this.width, this.height);
        this.copyToImageData(data, this.decodePixels());
        return ctx.putImageData(data, 0, 0);
      }
    };*/
    return PNG;
  })();
  //window.PNG = PNG;
//}).call(this);



/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/lib/pxf.js: */

/**************************************************
PXF.js Folder Gather/Compiler

Built on Tuesday 10. June 14
This file is automatically generated from source bundle
Single and multi-line comments have been removed. 

Copyright 2011-2012 pixelfolders (PXF) 
Visit our website at www.pixelfolders.se for more projects
Or contact us at contact@pixelfolders.se 

LICENSE?
*************************************************/

/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/loaders/ctm/ctm.js: */

/*
Copyright (c) 2011 Juan Mellado

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
References:
- "OpenCTM: The Open Compressed Triangle Mesh file format" by Marcus Geelnard
  http://openctm.sourceforge.net/
*/

var CTM = CTM || {};

CTM.CompressionMethod = {
  RAW: 0x00574152,
  MG1: 0x0031474d,
  MG2: 0x0032474d
};

CTM.Flags = {
  NORMALS: 0x00000001
};

CTM.File = function(stream){
  this.load(stream);
};

CTM.File.prototype.load = function(stream){
  this.header = new CTM.FileHeader(stream);

  this.body = new CTM.FileBody(this.header);
  
  this.getReader().read(stream, this.body);
};

CTM.File.prototype.getReader = function(){
  var reader;

  switch(this.header.compressionMethod){
    case CTM.CompressionMethod.RAW:
      reader = new CTM.ReaderRAW();
      break;
    case CTM.CompressionMethod.MG1:
      reader = new CTM.ReaderMG1();
      break;
    case CTM.CompressionMethod.MG2:
      reader = new CTM.ReaderMG2();
      break;
  }

  return reader;
};

CTM.FileHeader = function(stream){
  stream.readInt32(); //magic "OCTM"
  this.fileFormat = stream.readInt32();
  this.compressionMethod = stream.readInt32();
  this.vertexCount = stream.readInt32();
  this.triangleCount = stream.readInt32();
  this.uvMapCount = stream.readInt32();
  this.attrMapCount = stream.readInt32();
  this.flags = stream.readInt32();
  this.comment = stream.readString();
};

CTM.FileHeader.prototype.hasNormals = function(){
  return this.flags & CTM.Flags.NORMALS;
};

CTM.FileBody = function(header){
  var i = header.triangleCount * 3,
      v = header.vertexCount * 3,
      n = header.hasNormals()? header.vertexCount * 3: 0,
      u = header.vertexCount * 2,
      a = header.vertexCount * 4,
      j = 0;

  var data = new ArrayBuffer(
    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);

  this.indices = new Uint32Array(data, 0, i);

  this.vertices = new Float32Array(data, i * 4, v);

  if ( header.hasNormals() ){
    this.normals = new Float32Array(data, (i + v) * 4, n);
  }
  
  if (header.uvMapCount){
    this.uvMaps = [];
    for (j = 0; j < header.uvMapCount; ++ j){
      this.uvMaps[j] = {uv: new Float32Array(data,
        (i + v + n + (j * u) ) * 4, u) };
    }
  }
  
  if (header.attrMapCount){
    this.attrMaps = [];
    for (j = 0; j < header.attrMapCount; ++ j){
      this.attrMaps[j] = {attr: new Float32Array(data,
        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a) };
    }
  }
};

CTM.FileMG2Header = function(stream){
  stream.readInt32(); //magic "MG2H"
  this.vertexPrecision = stream.readFloat32();
  this.normalPrecision = stream.readFloat32();
  this.lowerBoundx = stream.readFloat32();
  this.lowerBoundy = stream.readFloat32();
  this.lowerBoundz = stream.readFloat32();
  this.higherBoundx = stream.readFloat32();
  this.higherBoundy = stream.readFloat32();
  this.higherBoundz = stream.readFloat32();
  this.divx = stream.readInt32();
  this.divy = stream.readInt32();
  this.divz = stream.readInt32();
  
  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;
  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;
  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;
};

CTM.ReaderRAW = function(){
};

CTM.ReaderRAW.prototype.read = function(stream, body){
  this.readIndices(stream, body.indices);
  this.readVertices(stream, body.vertices);
  
  if (body.normals){
    this.readNormals(stream, body.normals);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderRAW.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readArrayInt32(indices);
};

CTM.ReaderRAW.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readArrayFloat32(vertices);
};

CTM.ReaderRAW.prototype.readNormals = function(stream, normals){
  stream.readInt32(); //magic "NORM"
  stream.readArrayFloat32(normals);
};

CTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    stream.readArrayFloat32(uvMaps[i].uv);
  }
};

CTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    stream.readArrayFloat32(attrMaps[i].attr);
  }
};

CTM.ReaderMG1 = function(){
};

CTM.ReaderMG1.prototype.read = function(stream, body){
  this.readIndices(stream, body.indices);
  this.readVertices(stream, body.vertices);
  
  if (body.normals){
    this.readNormals(stream, body.normals);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderMG1.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readInt32(); //packed size
  
  var interleaved = new CTM.InterleavedStream(indices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreIndices(indices, indices.length);
};

CTM.ReaderMG1.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readInt32(); //packed size
  
  var interleaved = new CTM.InterleavedStream(vertices, 1);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
};

CTM.ReaderMG1.prototype.readNormals = function(stream, normals){
  stream.readInt32(); //magic "NORM"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(normals, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
};

CTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  }
};

CTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  }
};

CTM.ReaderMG2 = function(){
};

CTM.ReaderMG2.prototype.read = function(stream, body){
  this.MG2Header = new CTM.FileMG2Header(stream);
  
  this.readVertices(stream, body.vertices);
  this.readIndices(stream, body.indices);
  
  if (body.normals){
    this.readNormals(stream, body);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderMG2.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(vertices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  
  var gridIndices = this.readGridIndices(stream, vertices);
  
  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);
};

CTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){
  stream.readInt32(); //magic "GIDX"
  stream.readInt32(); //packed size
  
  var gridIndices = new Uint32Array(vertices.length / 3);
  
  var interleaved = new CTM.InterleavedStream(gridIndices, 1);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  
  CTM.restoreGridIndices(gridIndices, gridIndices.length);
  
  return gridIndices;
};

CTM.ReaderMG2.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(indices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreIndices(indices, indices.length);
};

CTM.ReaderMG2.prototype.readNormals = function(stream, body){
  stream.readInt32(); //magic "NORM"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(body.normals, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);

  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);
};

CTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    
    var precision = stream.readFloat32();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
    
    CTM.restoreMap(uvMaps[i].uv, 2, precision);
  }
};

CTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    
    var precision = stream.readFloat32();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
    
    CTM.restoreMap(attrMaps[i].attr, 4, precision);
  }
};

CTM.restoreIndices = function(indices, len){
  var i = 3;
  if (len > 0){
    indices[2] += indices[0];
    indices[1] += indices[0];
  }
  for (; i < len; i += 3){
    indices[i] += indices[i - 3];
    
    if (indices[i] === indices[i - 3]){
      indices[i + 1] += indices[i - 2];
    }else{
      indices[i + 1] += indices[i];
    }

    indices[i + 2] += indices[i];
  }
};

CTM.restoreGridIndices = function(gridIndices, len){
  var i = 1;
  for (; i < len; ++ i){
    gridIndices[i] += gridIndices[i - 1];
  }
};

CTM.restoreVertices = function(vertices, grid, gridIndices, precision){
  var gridIdx, delta, x, y, z,
      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),
      ydiv = grid.divx, zdiv = ydiv * grid.divy,
      prevGridIdx = 0x7fffffff, prevDelta = 0,
      i = 0, j = 0, len = gridIndices.length;

  for (; i < len; j += 3){
    x = gridIdx = gridIndices[i ++];
    
    z = ~~(x / zdiv);
    x -= ~~(z * zdiv);
    y = ~~(x / ydiv);
    x -= ~~(y * ydiv);

    delta = intVertices[j];
    if (gridIdx === prevGridIdx){
      delta += prevDelta;
    }

    vertices[j]     = grid.lowerBoundx +
      x * grid.sizex + precision * delta;
    vertices[j + 1] = grid.lowerBoundy +
      y * grid.sizey + precision * intVertices[j + 1];
    vertices[j + 2] = grid.lowerBoundz +
      z * grid.sizez + precision * intVertices[j + 2];

    prevGridIdx = gridIdx;
    prevDelta = delta;
  }
};

CTM.restoreNormals = function(normals, smooth, precision){
  var ro, phi, theta, sinPhi,
      nx, ny, nz, by, bz, len,
      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),
      i = 0, k = normals.length,
      PI_DIV_2 = 3.141592653589793238462643 * 0.5;

  for (; i < k; i += 3){
    ro = intNormals[i] * precision;
    phi = intNormals[i + 1];

    if (phi === 0){
      normals[i]     = smooth[i]     * ro;
      normals[i + 1] = smooth[i + 1] * ro;
      normals[i + 2] = smooth[i + 2] * ro;
    }else{
      
      if (phi <= 4){
        theta = (intNormals[i + 2] - 2) * PI_DIV_2;
      }else{
        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;
      }
      
      phi *= precision * PI_DIV_2;
      sinPhi = ro * Math.sin(phi);

      nx = sinPhi * Math.cos(theta);
      ny = sinPhi * Math.sin(theta);
      nz = ro * Math.cos(phi);

      bz = smooth[i + 1];
      by = smooth[i] - smooth[i + 2];

      len = Math.sqrt(2 * bz * bz + by * by);
      if (len > 1e-20){
        by /= len;
        bz /= len;
      }

      normals[i]     = smooth[i]     * nz +
        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;
      normals[i + 1] = smooth[i + 1] * nz -
        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;
      normals[i + 2] = smooth[i + 2] * nz +
        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;
    }
  }
};

CTM.restoreMap = function(map, count, precision){
  var delta, value,
      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),
      i = 0, j, len = map.length;

  for (; i < count; ++ i){
    delta = 0;

    for (j = i; j < len; j += count){
      value = intMap[j];
      
      delta += value & 1? -( (value + 1) >> 1): value >> 1;
      
      map[j] = delta * precision;
    }
  }
};

CTM.calcSmoothNormals = function(indices, vertices){
  var smooth = new Float32Array(vertices.length),
      indx, indy, indz, nx, ny, nz,
      v1x, v1y, v1z, v2x, v2y, v2z, len,
      i, k;

  for (i = 0, k = indices.length; i < k;){
    indx = indices[i ++] * 3;
    indy = indices[i ++] * 3;
    indz = indices[i ++] * 3;

    v1x = vertices[indy]     - vertices[indx];
    v2x = vertices[indz]     - vertices[indx];
    v1y = vertices[indy + 1] - vertices[indx + 1];
    v2y = vertices[indz + 1] - vertices[indx + 1];
    v1z = vertices[indy + 2] - vertices[indx + 2];
    v2z = vertices[indz + 2] - vertices[indx + 2];
    
    nx = v1y * v2z - v1z * v2y;
    ny = v1z * v2x - v1x * v2z;
    nz = v1x * v2y - v1y * v2x;
    
    len = Math.sqrt(nx * nx + ny * ny + nz * nz);
    if (len > 1e-10){
      nx /= len;
      ny /= len;
      nz /= len;
    }
    
    smooth[indx]     += nx;
    smooth[indx + 1] += ny;
    smooth[indx + 2] += nz;
    smooth[indy]     += nx;
    smooth[indy + 1] += ny;
    smooth[indy + 2] += nz;
    smooth[indz]     += nx;
    smooth[indz + 1] += ny;
    smooth[indz + 2] += nz;
  }

  for (i = 0, k = smooth.length; i < k; i += 3){
    len = Math.sqrt(smooth[i] * smooth[i] + 
      smooth[i + 1] * smooth[i + 1] +
      smooth[i + 2] * smooth[i + 2]);

    if(len > 1e-10){
      smooth[i]     /= len;
      smooth[i + 1] /= len;
      smooth[i + 2] /= len;
    }
  }

  return smooth;
};

CTM.isLittleEndian = (function(){
  var buffer = new ArrayBuffer(2),
      bytes = new Uint8Array(buffer),
      ints = new Uint16Array(buffer);

  bytes[0] = 1;

  return ints[0] === 1;
}());

CTM.InterleavedStream = function(data, count){
  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  this.offset = CTM.isLittleEndian? 3: 0;
  this.count = count * 4;
  this.len = this.data.length;
};

CTM.InterleavedStream.prototype.writeByte = function(value){
  this.data[this.offset] = value;
  
  this.offset += this.count;
  if (this.offset >= this.len){
  
    this.offset -= this.len - 4;
    if (this.offset >= this.count){
    
      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);
    }
  }
};

CTM.Stream = function(data){
  this.data = data;
  this.offset = 0;
};

CTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);

CTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);

CTM.Stream.prototype.readByte = function(){
  return this.data[this.offset ++] & 0xff;
};

CTM.Stream.prototype.readInt32 = function(){
  var i = this.readByte();
  i |= this.readByte() << 8;
  i |= this.readByte() << 16;
  return i | (this.readByte() << 24);
};

CTM.Stream.prototype.readFloat32 = function(){
  var m = this.readByte();
  m += this.readByte() << 8;

  var b1 = this.readByte();
  var b2 = this.readByte();

  m += (b1 & 0x7f) << 16; 
  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);
  var s = b2 & 0x80? -1: 1;

  if (e === 255){
    return m !== 0? NaN: s * Infinity;
  }
  if (e > 0){
    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);
  }
  if (m !== 0){
    return s * m * this.TWO_POW_MINUS126;
  }
  return s * 0;
};

CTM.Stream.prototype.readString = function(){
  var len = this.readInt32();

  this.offset += len;

  return String.fromCharCode.apply(null,this.data.subarray(this.offset - len, this.offset));
};

CTM.Stream.prototype.readArrayInt32 = function(array){
  var i = 0, len = array.length;
  
  while(i < len){
    array[i ++] = this.readInt32();
  }

  return array;
};

CTM.Stream.prototype.readArrayFloat32 = function(array){
  var i = 0, len = array.length;

  while(i < len){
    array[i ++] = this.readFloat32();
  }

  return array;
};



/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/FPSHistogram.js: */


var shiftContext = function(ctx, w, h, dx, dy) {
  var clamp = function(high, value) { return Math.max(0, Math.min(high, value)); };
  var imageData = ctx.getImageData(clamp(w, -dx), clamp(h, -dy), clamp(w, w-dx), clamp(h, h-dy));
  ctx.clearRect(0, 0, w, h);
  ctx.putImageData(imageData, 0, 0);
}

var histogram;

var histogram_last_fps_check = 0.0;
var histogram_fps = 0;
var histogram_last_fps = 0;

function SpawnHistogram() {    
    histogram = FPSHistogram();
}

function InjectHistogram(fname)
{
	var chunks    = fname.split(".");
	var parent    = chunks.slice(0,chunks.length-1);
	var child     = null;
	var childname = chunks[chunks.length-1];

	if ( parent.length == 0 ) parent = self;
	else {
		parent = eval( parent.join(".") );
	};

	child = parent[childname];

	if ( parent && child ) 
	{
		if(!self.injectedHistogram) self.injectedHistogram = FPSHistogram();

		var injectedName = "injected_" + childname;
		parent[injectedName] = parent[childname];
		parent[childname]    = function( injectedFn )
		{
			injectedFn.apply( parent, arguments);

			histogram_fps += 1;
			if (Date.now() - histogram_last_fps_check >= 1000.0)
			{
			    histogram_last_fps = histogram_fps;
			    histogram_last_fps_check = Date.now();
			    histogram_fps = 0;
			}

			self.injectedHistogram.AddFrame();

		}.bind( parent, parent[injectedName] );


	}

	// if ( chunkfound )
	{
		// if(!self.injectedHistogram) self.injectedHistogram = FPSHistogram();

		// var injectedName = "injected_" + fname;
		// chunkparent[injectedName] = chunkfound;
	}

	/*

	if ( self[fname] )
	{
		if(!self.injectedHistogram) self.injectedHistogram = FPSHistogram();

		var injectedName = "injected_" + fname;
		self[injectedName] = self[fname];
		self[fname] = function( injectedFn )
		{
			injectedFn.apply(null, arguments);

			histogram_fps += 1;
			if (Date.now() - histogram_last_fps_check >= 1000.0)
			{
			    histogram_last_fps = histogram_fps;
			    histogram_last_fps_check = Date.now();
			    histogram_fps = 0;
			}

			self.injectedHistogram.AddFrame();

		}.bind( null, self[injectedName] );
	}

	*/
}

/**
 * Create a FPS Histogram
 * @function
 * @param {string} left Left-css screen position.
 * @param {string} top Top-css screen position.
 */
function FPSHistogram(left,top) {
	left 	= left 	|| "128px";
	top 	= top 	|| "0px";

	var histogram = {};

	histogram.w = 256;
	histogram.h = 64;

	histogram.barwidth = 2;

	histogram.bgcolor  = '#000';
	histogram.linecolor = '#fff';
	histogram.barcolor = '#f00';
	histogram.barcolor2 = '#ff0';
	histogram.barcolor3 = '#00f';

	var element 				= document.createElement('canvas');
	element.width 				=histogram.w;
	element.height 				=histogram.h;
	element.style["left"] 		= left;
	element.style["top"] 		= top;
	element.style["position"] 	= "absolute";
	element.style["z-index"] 	= "10";
	element.style["float"] 		= "left";

	document.body.appendChild(element);
	histogram.element = element;
	histogram.context = element.getContext('2d');
	histogram.context.fillStyle = histogram.bgcolor;
	histogram.context.fillRect(0, 0, histogram.w, histogram.h);

	/**
	 * Add new frame to histogram, usually called once per frame.
	 * @function
	 */
	histogram.AddFrame = function() {

		
		var current_time = Date.now();
		var ms_delta = current_time - histogram.last_time;
		histogram.last_time = current_time;
		histogram.ms_delta = ms_delta;


		var top_size = 120;
		var bar_size = ms_delta / top_size;


		// clear column
		histogram.context.fillStyle = histogram.bgcolor;
		histogram.context.fillRect(histogram.w-histogram.barwidth, 0, histogram.barwidth, histogram.h);

		

		// do column
		histogram.context.fillStyle = histogram.barcolor;
		if ( typeof vt != "undefined" && vt.readOutPixels) {
			vt.readOutPixels = false;
			histogram.context.fillStyle = histogram.barcolor2;
		} else if ( typeof vt != "undefined" && vt.uploadedSomeData) {
			vt.uploadedSomeData = false;
			histogram.context.fillStyle = histogram.barcolor3;
		}
		histogram.context.fillRect(histogram.w - histogram.barwidth, histogram.h * (1.0 - bar_size), histogram.barwidth, histogram.h * bar_size);

		histogram.context.fillStyle = histogram.barcolor;
		histogram.context.fillRect(histogram.w - 100, histogram.h - 12, 100, 12);

		histogram.context.fillStyle = histogram.bgcolor;
		histogram.context.font = "10px Arial";
        histogram.context.fillText( "FPS: " + histogram_last_fps + ", " + ms_delta + "ms", histogram.w - 80, histogram.h - 2 );

		// 16 ms line
		histogram.context.fillStyle = histogram.linecolor;
		histogram.context.fillRect(histogram.w - histogram.barwidth, histogram.h * (1.0 - (16.0 / top_size)), histogram.barwidth, 1);

		//histogram.context.translate(-1, 0);
		shiftContext(histogram.context, histogram.w, histogram.h, -histogram.barwidth, 0);


	};

	return histogram;
}




/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/core/Timer.js: */

/*
 * timer.js: Implements a high-resolution (up to µs) timer constructor.
 *
 * 2010-10-21
 * 
 * By Eli Grey, http://eligrey.com
 * Public Domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */

/*global chromium*/
/*jslint evil: true, laxbreak: true, eqeqeq: true, strict: true, maxlen: 90 */

/*! @source http://purl.eligrey.com/github/timer.js/blob/master/timer.js*/

"use strict";

var Timer = Timer || (function () {
	var
		  Timer
		, timerPrototype
		// My profiling indicates that Date.now is slightly faster than date.getTime
		// in all engines that support it.
		, now = Date.now || function () {
			return (new Date()).getTime();
		}
	;

	if (typeof chrome !== "undefined" && typeof chrome.Interval === "function") {
		// Google Chrome has a native timer constructor
		timerPrototype = (Timer = chrome.Interval).prototype;
		timerPrototype.milliseconds = function () {
			return this.microseconds() / 1000;
		};
	} else { 
		timerPrototype = (Timer = function () {
			var
				  startT = 0
				, stopT = 0
			;

			this.start = function () {
				stopT = 0;
				startT = now();
			};

			this.stop = function () {
				stopT = now();
				if (startT === 0) {
					stopT = 0;
				}
			};
			this.milliseconds = function () {
				var stop = stopT;
				if (stop === 0 && startT !== 0) {
					stop = now();
				}
				return stop - startT;
			};
		}).prototype;
		timerPrototype.microseconds = function () {
			return this.milliseconds() * 1000;
		};
	}
	timerPrototype.profile = function (fn, iterations) {
		if (typeof fn === "string") {
			fn = new Function(fn);
		}
		this.start();
		while (iterations--) {
			fn();
		}
		this.stop();
	};
	timerPrototype.seconds = function () {
		return this.milliseconds() / 1000;
	};
	return Timer;
}());


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/core/Debug.js: */

// Warning: Only include this function if you are using the non-concatinated pxf.js file.

/**
 * Writes a series of arguments to the console. Overshadowed by build script.
 */
function LOG()
{
	if (arguments.length <= 1) {
		console.log(arguments[0]);
		return;
	}

	var strings = [];
	var other = [];
	for( var i = 0; i < arguments.length; i++ ) {
		var t = typeof(arguments[i]);
		if (t == "object") {
			other.push(arguments[i]);
		} else {
			strings.push(arguments[i]);
		}
	}

	var output_str = "";
	for (var s in strings) {
		output_str += strings[s] + ", ";
	}

	console.log(output_str);

	for (var o in other) 
		console.log(other[o]);
}

/**
 * Writes a series of error msgs to the console. Overshadowed by build script.
 */
function ERROR(t)
{
	for( var i = 0; i < arguments.length; i++ ) 
		console.error(arguments[i]);
}





/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/loaders/ctm/lzma.js: */

var LZMA = LZMA || {};

LZMA.OutWindow = function(){
  this._windowSize = 0;
};

LZMA.OutWindow.prototype.create = function(windowSize){
  if ( (!this._buffer) || (this._windowSize !== windowSize) ){
    this._buffer = [];
  }
  this._windowSize = windowSize;
  this._pos = 0;
  this._streamPos = 0;
};

LZMA.OutWindow.prototype.flush = function(){
  var size = this._pos - this._streamPos;
  if (size !== 0){
    while(size --){
      this._stream.writeByte(this._buffer[this._streamPos ++]);
    }
    if (this._pos >= this._windowSize){
      this._pos = 0;
    }
    this._streamPos = this._pos;
  }
};

LZMA.OutWindow.prototype.releaseStream = function(){
  this.flush();
  this._stream = null;
};

LZMA.OutWindow.prototype.setStream = function(stream){
  this.releaseStream();
  this._stream = stream;
};

LZMA.OutWindow.prototype.init = function(solid){
  if (!solid){
    this._streamPos = 0;
    this._pos = 0;
  }
};

LZMA.OutWindow.prototype.copyBlock = function(distance, len){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  while(len --){
    if (pos >= this._windowSize){
      pos = 0;
    }
    this._buffer[this._pos ++] = this._buffer[pos ++];
    if (this._pos >= this._windowSize){
      this.flush();
    }
  }
};

LZMA.OutWindow.prototype.putByte = function(b){
  this._buffer[this._pos ++] = b;
  if (this._pos >= this._windowSize){
    this.flush();
  }
};

LZMA.OutWindow.prototype.getByte = function(distance){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  return this._buffer[pos];
};

LZMA.RangeDecoder = function(){
};

LZMA.RangeDecoder.prototype.setStream = function(stream){
  this._stream = stream;
};

LZMA.RangeDecoder.prototype.releaseStream = function(){
  this._stream = null;
};

LZMA.RangeDecoder.prototype.init = function(){
  var i = 5;

  this._code = 0;
  this._range = -1;
  
  while(i --){
    this._code = (this._code << 8) | this._stream.readByte();
  }
};

LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){
  var result = 0, i = numTotalBits, t;

  while(i --){
    this._range >>>= 1;
    t = (this._code - this._range) >>> 31;
    this._code -= this._range & (t - 1);
    result = (result << 1) | (1 - t);

    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
  }

  return result;
};

LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){
  var prob = probs[index],
      newBound = (this._range >>> 11) * prob;

  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){
    this._range = newBound;
    probs[index] += (2048 - prob) >>> 5;
    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
    return 0;
  }

  this._range -= newBound;
  this._code -= newBound;
  probs[index] -= prob >>> 5;
  if ( (this._range & 0xff000000) === 0){
    this._code = (this._code << 8) | this._stream.readByte();
    this._range <<= 8;
  }
  return 1;
};

LZMA.initBitModels = function(probs, len){
  while(len --){
    probs[len] = 1024;
  }
};

LZMA.BitTreeDecoder = function(numBitLevels){
  this._models = [];
  this._numBitLevels = numBitLevels;
};

LZMA.BitTreeDecoder.prototype.init = function(){
  LZMA.initBitModels(this._models, 1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){
  var m = 1, i = this._numBitLevels;

  while(i --){
    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);
  }
  return m - (1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < this._numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(this._models, m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(models, startIndex + m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.LenDecoder = function(){
  this._choice = [];
  this._lowCoder = [];
  this._midCoder = [];
  this._highCoder = new LZMA.BitTreeDecoder(8);
  this._numPosStates = 0;
};

LZMA.LenDecoder.prototype.create = function(numPosStates){
  for (; this._numPosStates < numPosStates; ++ this._numPosStates){
    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
  }
};

LZMA.LenDecoder.prototype.init = function(){
  var i = this._numPosStates;
  LZMA.initBitModels(this._choice, 2);
  while(i --){
    this._lowCoder[i].init();
    this._midCoder[i].init();
  }
  this._highCoder.init();
};

LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){
  if (rangeDecoder.decodeBit(this._choice, 0) === 0){
    return this._lowCoder[posState].decode(rangeDecoder);
  }
  if (rangeDecoder.decodeBit(this._choice, 1) === 0){
    return 8 + this._midCoder[posState].decode(rangeDecoder);
  }
  return 16 + this._highCoder.decode(rangeDecoder);
};

LZMA.Decoder2 = function(){
  this._decoders = [];
};

LZMA.Decoder2.prototype.init = function(){
  LZMA.initBitModels(this._decoders, 0x300);
};

LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){
  var symbol = 1;

  do{
    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){
  var symbol = 1, matchBit, bit;

  do{
    matchBit = (matchByte >> 7) & 1;
    matchByte <<= 1;
    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);
    symbol = (symbol << 1) | bit;
    if (matchBit !== bit){
      while(symbol < 0x100){
        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
      }
      break;
    }
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LZMA.LiteralDecoder = function(){
};

LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){
  var i;

  if (this._coders
    && (this._numPrevBits === numPrevBits)
    && (this._numPosBits === numPosBits) ){
    return;
  }
  this._numPosBits = numPosBits;
  this._posMask = (1 << numPosBits) - 1;
  this._numPrevBits = numPrevBits;

  this._coders = [];

  i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i] = new LZMA.Decoder2();
  }
};

LZMA.LiteralDecoder.prototype.init = function(){
  var i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i].init();
  }
};

LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){
  return this._coders[( (pos & this._posMask) << this._numPrevBits)
    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];
};

LZMA.Decoder = function(){
  this._outWindow = new LZMA.OutWindow();
  this._rangeDecoder = new LZMA.RangeDecoder();
  this._isMatchDecoders = [];
  this._isRepDecoders = [];
  this._isRepG0Decoders = [];
  this._isRepG1Decoders = [];
  this._isRepG2Decoders = [];
  this._isRep0LongDecoders = [];
  this._posSlotDecoder = [];
  this._posDecoders = [];
  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);
  this._lenDecoder = new LZMA.LenDecoder();
  this._repLenDecoder = new LZMA.LenDecoder();
  this._literalDecoder = new LZMA.LiteralDecoder();
  this._dictionarySize = -1;
  this._dictionarySizeCheck = -1;

  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);
};

LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){
  if (dictionarySize < 0){
    return false;
  }
  if (this._dictionarySize !== dictionarySize){
    this._dictionarySize = dictionarySize;
    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);
    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );
  }
  return true;
};

LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){
  var numPosStates = 1 << pb;

  if (lc > 8 || lp > 4 || pb > 4){
    return false;
  }

  this._literalDecoder.create(lp, lc);

  this._lenDecoder.create(numPosStates);
  this._repLenDecoder.create(numPosStates);
  this._posStateMask = numPosStates - 1;

  return true;
};

LZMA.Decoder.prototype.init = function(){
  var i = 4;

  this._outWindow.init(false);

  LZMA.initBitModels(this._isMatchDecoders, 192);
  LZMA.initBitModels(this._isRep0LongDecoders, 192);
  LZMA.initBitModels(this._isRepDecoders, 12);
  LZMA.initBitModels(this._isRepG0Decoders, 12);
  LZMA.initBitModels(this._isRepG1Decoders, 12);
  LZMA.initBitModels(this._isRepG2Decoders, 12);
  LZMA.initBitModels(this._posDecoders, 114);

  this._literalDecoder.init();

  while(i --){
    this._posSlotDecoder[i].init();
  }

  this._lenDecoder.init();
  this._repLenDecoder.init();
  this._posAlignDecoder.init();
  this._rangeDecoder.init();
};

LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){
  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,
      posState, decoder2, len, distance, posSlot, numDirectBits;

  this._rangeDecoder.setStream(inStream);
  this._outWindow.setStream(outStream);

  this.init();

  while(outSize < 0 || nowPos64 < outSize){
    posState = nowPos64 & this._posStateMask;

    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){
      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);

      if (state >= 7){
        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );
      }else{
        prevByte = decoder2.decodeNormal(this._rangeDecoder);
      }
      this._outWindow.putByte(prevByte);

      state = state < 4? 0: state - (state < 10? 3: 6);

    }else{

      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){
        len = 0;
        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){
          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){
            state = state < 7? 9: 11;
            len = 1;
          }
        }else{
          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){
            distance = rep1;
          }else{
            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){
              distance = rep2;
            }else{
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        if (len === 0){
          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);
          state = state < 7? 8: 11;
        }
      }else{
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;

        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);
        state = state < 7? 7: 10;

        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);
        if (posSlot >= 4){

          numDirectBits = (posSlot >> 1) - 1;
          rep0 = (2 | (posSlot & 1) ) << numDirectBits;

          if (posSlot < 14){
            rep0 += LZMA.reverseDecode2(this._posDecoders,
                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
          }else{
            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
            if (rep0 < 0){
              if (rep0 === -1){
                break;
              }
              return false;
            }
          }
        }else{
          rep0 = posSlot;
        }
      }

      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){
        return false;
      }

      this._outWindow.copyBlock(rep0, len);
      nowPos64 += len;
      prevByte = this._outWindow.getByte(0);
    }
  }

  this._outWindow.flush();
  this._outWindow.releaseStream();
  this._rangeDecoder.releaseStream();

  return true;
};

LZMA.Decoder.prototype.setDecoderProperties = function(properties){
  var value, lc, lp, pb, dictionarySize;

  if (properties.size < 5){
    return false;
  }

  value = properties.readByte();
  lc = value % 9;
  value = ~~(value / 9);
  lp = value % 5;
  pb = ~~(value / 5);

  if ( !this.setLcLpPb(lc, lp, pb) ){
    return false;
  }

  dictionarySize = properties.readByte();
  dictionarySize |= properties.readByte() << 8;
  dictionarySize |= properties.readByte() << 16;
  dictionarySize += properties.readByte() * 16777216;

  return this.setDictionarySize(dictionarySize);
};

LZMA.decompress = function(properties, inStream, outStream, outSize){
  var decoder = new LZMA.Decoder();

  if ( !decoder.setDecoderProperties(properties) ){
    throw "Incorrect stream properties";
  }

  if ( !decoder.decode(inStream, outStream, outSize) ){
    throw "Error in data stream";
  }

  return true;
};




/*
var LZMA = LZMA || {};

LZMA.OutWindow = function(){
  this._windowSize = 0;
};

LZMA.OutWindow.prototype.create = function(windowSize){
  if ( (!this._buffer) || (this._windowSize !== windowSize) ){
    this._buffer = [];
  }
  this._windowSize = windowSize;
  this._pos = 0;
  this._streamPos = 0;
};

LZMA.OutWindow.prototype.flush = function(){
  var size = this._pos - this._streamPos;
  if (size !== 0){
    while(size --){
      this._stream.writeByte(this._buffer[this._streamPos ++]);
    }
    if (this._pos >= this._windowSize){
      this._pos = 0;
    }
    this._streamPos = this._pos;
  }
};

LZMA.OutWindow.prototype.releaseStream = function(){
  this.flush();
  this._stream = null;
};

LZMA.OutWindow.prototype.setStream = function(stream){
  this.releaseStream();
  this._stream = stream;
};

LZMA.OutWindow.prototype.init = function(solid){
  if (!solid){
    this._streamPos = 0;
    this._pos = 0;
  }
};

LZMA.OutWindow.prototype.copyBlock = function(distance, len){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  while(len --){
    if (pos >= this._windowSize){
      pos = 0;
    }
    this._buffer[this._pos ++] = this._buffer[pos ++];
    if (this._pos >= this._windowSize){
      this.flush();
    }
  }
};

LZMA.OutWindow.prototype.putByte = function(b){
  this._buffer[this._pos ++] = b;
  if (this._pos >= this._windowSize){
    this.flush();
  }
};

LZMA.OutWindow.prototype.getByte = function(distance){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  return this._buffer[pos];
};

LZMA.RangeDecoder = function(){
};

LZMA.RangeDecoder.prototype.setStream = function(stream){
  this._stream = stream;
};

LZMA.RangeDecoder.prototype.releaseStream = function(){
  this._stream = null;
};

LZMA.RangeDecoder.prototype.init = function(){
  var i = 5;

  this._code = 0;
  this._range = -1;
  
  while(i --){
    this._code = (this._code << 8) | this._stream.readByte();
  }
};

LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){
  var result = 0, i = numTotalBits, t;

  while(i --){
    this._range >>>= 1;
    t = (this._code - this._range) >>> 31;
    this._code -= this._range & (t - 1);
    result = (result << 1) | (1 - t);

    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
  }

  return result;
};

LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){
  var prob = probs[index],
      newBound = (this._range >>> 11) * prob;

  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){
    this._range = newBound;
    probs[index] += (2048 - prob) >>> 5;
    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
    return 0;
  }

  this._range -= newBound;
  this._code -= newBound;
  probs[index] -= prob >>> 5;
  if ( (this._range & 0xff000000) === 0){
    this._code = (this._code << 8) | this._stream.readByte();
    this._range <<= 8;
  }
  return 1;
};

LZMA.initBitModels = function(probs, len){
  while(len --){
    probs[len] = 1024;
  }
};

LZMA.BitTreeDecoder = function(numBitLevels){
  this._models = [];
  this._numBitLevels = numBitLevels;
};

LZMA.BitTreeDecoder.prototype.init = function(){
  LZMA.initBitModels(this._models, 1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){
  var m = 1, i = this._numBitLevels;

  while(i --){
    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);
  }
  return m - (1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < this._numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(this._models, m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(models, startIndex + m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.LenDecoder = function(){
  this._choice = [];
  this._lowCoder = [];
  this._midCoder = [];
  this._highCoder = new LZMA.BitTreeDecoder(8);
  this._numPosStates = 0;
};

LZMA.LenDecoder.prototype.create = function(numPosStates){
  for (; this._numPosStates < numPosStates; ++ this._numPosStates){
    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
  }
};

LZMA.LenDecoder.prototype.init = function(){
  var i = this._numPosStates;
  LZMA.initBitModels(this._choice, 2);
  while(i --){
    this._lowCoder[i].init();
    this._midCoder[i].init();
  }
  this._highCoder.init();
};

LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){
  if (rangeDecoder.decodeBit(this._choice, 0) === 0){
    return this._lowCoder[posState].decode(rangeDecoder);
  }
  if (rangeDecoder.decodeBit(this._choice, 1) === 0){
    return 8 + this._midCoder[posState].decode(rangeDecoder);
  }
  return 16 + this._highCoder.decode(rangeDecoder);
};

LZMA.Decoder2 = function(){
  this._decoders = [];
};

LZMA.Decoder2.prototype.init = function(){
  LZMA.initBitModels(this._decoders, 0x300);
};

LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){
  var symbol = 1;

  do{
    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){
  var symbol = 1, matchBit, bit;

  do{
    matchBit = (matchByte >> 7) & 1;
    matchByte <<= 1;
    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);
    symbol = (symbol << 1) | bit;
    if (matchBit !== bit){
      while(symbol < 0x100){
        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
      }
      break;
    }
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LZMA.LiteralDecoder = function(){
};

LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){
  var i;

  if (this._coders
    && (this._numPrevBits === numPrevBits)
    && (this._numPosBits === numPosBits) ){
    return;
  }
  this._numPosBits = numPosBits;
  this._posMask = (1 << numPosBits) - 1;
  this._numPrevBits = numPrevBits;

  this._coders = [];

  i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i] = new LZMA.Decoder2();
  }
};

LZMA.LiteralDecoder.prototype.init = function(){
  var i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i].init();
  }
};

LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){
  return this._coders[( (pos & this._posMask) << this._numPrevBits)
    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];
};

LZMA.Decoder = function(){
  this._outWindow = new LZMA.OutWindow();
  this._rangeDecoder = new LZMA.RangeDecoder();
  this._isMatchDecoders = [];
  this._isRepDecoders = [];
  this._isRepG0Decoders = [];
  this._isRepG1Decoders = [];
  this._isRepG2Decoders = [];
  this._isRep0LongDecoders = [];
  this._posSlotDecoder = [];
  this._posDecoders = [];
  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);
  this._lenDecoder = new LZMA.LenDecoder();
  this._repLenDecoder = new LZMA.LenDecoder();
  this._literalDecoder = new LZMA.LiteralDecoder();
  this._dictionarySize = -1;
  this._dictionarySizeCheck = -1;

  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);
};

LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){
  if (dictionarySize < 0){
    return false;
  }
  if (this._dictionarySize !== dictionarySize){
    this._dictionarySize = dictionarySize;
    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);
    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );
  }
  return true;
};

LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){
  var numPosStates = 1 << pb;

  if (lc > 8 || lp > 4 || pb > 4){
    return false;
  }

  this._literalDecoder.create(lp, lc);

  this._lenDecoder.create(numPosStates);
  this._repLenDecoder.create(numPosStates);
  this._posStateMask = numPosStates - 1;

  return true;
};

LZMA.Decoder.prototype.init = function(){
  var i = 4;

  this._outWindow.init(false);

  LZMA.initBitModels(this._isMatchDecoders, 192);
  LZMA.initBitModels(this._isRep0LongDecoders, 192);
  LZMA.initBitModels(this._isRepDecoders, 12);
  LZMA.initBitModels(this._isRepG0Decoders, 12);
  LZMA.initBitModels(this._isRepG1Decoders, 12);
  LZMA.initBitModels(this._isRepG2Decoders, 12);
  LZMA.initBitModels(this._posDecoders, 114);

  this._literalDecoder.init();

  while(i --){
    this._posSlotDecoder[i].init();
  }

  this._lenDecoder.init();
  this._repLenDecoder.init();
  this._posAlignDecoder.init();
  this._rangeDecoder.init();
};

LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){
  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,
      posState, decoder2, len, distance, posSlot, numDirectBits;

  this._rangeDecoder.setStream(inStream);
  this._outWindow.setStream(outStream);

  this.init();

  while(outSize < 0 || nowPos64 < outSize){
    posState = nowPos64 & this._posStateMask;

    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){
      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);

      if (state >= 7){
        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );
      }else{
        prevByte = decoder2.decodeNormal(this._rangeDecoder);
      }
      this._outWindow.putByte(prevByte);

      state = state < 4? 0: state - (state < 10? 3: 6);

    }else{

      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){
        len = 0;
        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){
          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){
            state = state < 7? 9: 11;
            len = 1;
          }
        }else{
          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){
            distance = rep1;
          }else{
            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){
              distance = rep2;
            }else{
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        if (len === 0){
          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);
          state = state < 7? 8: 11;
        }
      }else{
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;

        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);
        state = state < 7? 7: 10;

        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);
        if (posSlot >= 4){

          numDirectBits = (posSlot >> 1) - 1;
          rep0 = (2 | (posSlot & 1) ) << numDirectBits;

          if (posSlot < 14){
            rep0 += LZMA.reverseDecode2(this._posDecoders,
                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
          }else{
            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
            if (rep0 < 0){
              if (rep0 === -1){
                break;
              }
              return false;
            }
          }
        }else{
          rep0 = posSlot;
        }
      }

      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){
        return false;
      }

      this._outWindow.copyBlock(rep0, len);
      nowPos64 += len;
      prevByte = this._outWindow.getByte(0);
    }
  }

  this._outWindow.flush();
  this._outWindow.releaseStream();
  this._rangeDecoder.releaseStream();

  return true;
};

LZMA.Decoder.prototype.setDecoderProperties = function(properties){
  var value, lc, lp, pb, dictionarySize;

  if (properties.size < 5){
    return false;
  }

  value = properties.readByte();
  lc = value % 9;
  value = ~~(value / 9);
  lp = value % 5;
  pb = ~~(value / 5);

  if ( !this.setLcLpPb(lc, lp, pb) ){
    return false;
  }

  dictionarySize = properties.readByte();
  dictionarySize |= properties.readByte() << 8;
  dictionarySize |= properties.readByte() << 16;
  dictionarySize += properties.readByte() * 16777216;

  return this.setDictionarySize(dictionarySize);
};

LZMA.decompress = function(properties, inStream, outStream, outSize){
  var decoder = new LZMA.Decoder();

  if ( !decoder.setDecoderProperties(properties) ){
    throw "Incorrect stream properties";
  }

  if ( !decoder.decode(inStream, outStream, outSize) ){
    throw "Error in data stream";
  }

  return true;
};
*/


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/pxf.js: */

/**
 * @namespace PXF namespace variable.
 */
var PXF = PXF || {};


// constants
// TODO: Add more for textures etc. if necessary
var __constants = [ 
    "DRAW_ELEMENTS", "DRAW_ARRAYS", "DRAW_NONE", // DRAW CALLS
    "LINEAR", "EXPONENTIAL", "INVERSE_EXPONENTIAL", // TWEENING ETC.
    "BREADTH_FIRST","DEPTH_FIRST" // GRAPH WALKING
    ]; 
for( var c in __constants ) {
    PXF[ __constants[c] ] = Number(c);
}


/**
 * Initiates PXF framework.
 *
 * @constructor
 * @param {integer} width WebGL context width.
 * @param {integer} height WebGL context height.
 * @param {HTMLElement} canvas Canvas element to get WebGL context from.
 * @param {boolean} [depth=false] Depth on the WebGL context.
 * @param {boolean} [antialias=false] Antialiasing on the WebGL context.
 * @param {boolean} [stencil=false] Enable stencil buffer.
 * @param {boolean} [debug=false] Enables debuging of PXF instance.
 * @returns {PXF.Instance} On success returns a PXF.Instance, on failure returns false.
 * @example
var ctx = new PXF.Instance(512, 512, document.getElementById('glcanvas'), false, false, true);
 */
PXF.Instance = function ( width, height, canvas, depth, alpha, antialias, stencil, frustumCulling, debug ) {
    this.debug          = debug;
    this.frustumCulling = frustumCulling;
    this.gl             = null;

    // todo: these should respond to canvas resize
    this.ctxWidth       = width;
    this.ctxHeight      = height;
	this.canvas         = canvas;

    // Resource containers
    this.AllTextures     = [];
    this.AllGeometry     = [];
    this.AllFramebuffers = [];

    try {
    
        // get context
        if (debug)
        {
            // this.gl = WebGLDebugUtils.makeDebugContext(canvas.getContext( 'experimental-webgl', { depth: depth, alpha: alpha, antialias: antialias, stencil: stencil, preserveDrawingBuffer: true, premultipliedAlpha: true } ) );
            this.gl = canvas.getContext( 'experimental-webgl', { depth: depth, alpha: alpha, antialias: antialias, stencil: stencil, preserveDrawingBuffer: false, premultipliedAlpha: true } );
        } else {
            this.gl = canvas.getContext( 'experimental-webgl', { depth: depth, alpha: alpha, antialias: antialias, stencil: stencil, preserveDrawingBuffer: false, premultipliedAlpha: true } );
        }

        if ( ! (  this.gl ) ) {
            throw 'Error creating WebGL context.';
        }

        
        var _gl = this.gl;
            
        LOG(
            navigator.userAgent + " | " +
            _gl.getParameter( _gl.VERSION ) + " | " +
            _gl.getParameter( _gl.VENDOR ) + " | " +
            _gl.getParameter( _gl.RENDERER ) + " | " +
            _gl.getParameter( _gl.SHADING_LANGUAGE_VERSION )
        );
        
    } catch ( error ) {
        console.error( error );
        return false;
    }
    
    // register all WebGL extensions that is supported by the client
    this.EnableExtensions();

    // set initial WebGL state table
    this.SetWebGLState();

    // inject opengl functions with lamba functions that checks the CPU state
    if (!this.debug) 
    {
        // this.SetWebGLTransition();
        // this.gl.getError = function() { return 0; }
    }

    // create all shaders in the lib
    this.BuildShaderLib();
    
    // Enable depth testing if there is a depth buffer
    if (depth) { _gl.enable(_gl.DEPTH_TEST); }
    
    // Clear canvas if in debug mode, and check for WebGL errors.
    if (debug) {        
        _gl.clearColor( 0, 0, 0, 1);
        _gl.clear( _gl.COLOR_BUFFER_BIT );
        
        if (this.getError() > 0)
        {
            return false
        }
    }

    ////////////////////////
    // Setup input handling
    // --------------------
    // create main input state
    this._inputState = PXF.Input.State();

    // bind inputs to event listeners
    this.BindInputs();  
    
    // bind touch inputs to event listeners
    this.BindTouchInputs();
};

PXF.Instance.prototype.CheckDXTSupport = function () {
    return (!!this.extensions && "WEBGL_compressed_texture_s3tc" in this.extensions) ? this.extensions["WEBGL_compressed_texture_s3tc"] : null;
} 

PXF.Instance.prototype.BindTouchInputs = function( node )
{ 
  node = node || this.canvas;

  if ( this._touchInputsBoundTo )
  {
    for ( var t in this._touchInputsBoundList )
    {
      this._inputsBoundTo.removeEventListener( t, this._touchInputsBoundList[t], false );
    };
  };

  this._touchInputsBoundTo = node;
  this._touchInputsBoundList = {
    touchstart : PXF._touchStart.bind(this),
    touchend : PXF._touchEnd.bind(this),
    touchmove : PXF._touchMove.bind(this)
  };

  for ( var t in this._touchInputsBoundList )
  {
    this._touchInputsBoundTo.addEventListener( t, this._touchInputsBoundList[t], false );
  };  
}

PXF.Instance.prototype.BindInputs = function( node )
{
  node = node || this.canvas;

  if ( this._inputsBoundTo )
  {
    for ( var t in this._inputsBoundList )
    {
      this._inputsBoundTo.removeEventListener( t, this._inputsBoundList[t], false );
    };
  };

  this._inputsBoundTo   = node;
  this._inputsBoundList = {
    mousedown      : function () { return false; },
    click          : PXF._inputMouseClick.bind(this),
    mousedown      : PXF._inputMouseDown.bind(this),
    mousewheel     : PXF._inputMouseWheel.bind(this),
    DOMMouseScroll : PXF._inputMouseWheel.bind(this),
    mouseup        : PXF._inputMouseUp.bind(this),
    mousemove      : PXF._inputMouseMove.bind(this),
    contextmenu    : function (e) {
          e.preventDefault();
          e.stopPropagation();
          e.cancelBubble = true; 
          e.cancel = true; 
          e.returnValue = false;
          return false;
      },
    keydown : PXF._inputKeyPress.bind(this),
    keyup   : PXF._inputKeyUp.bind(this),
  };

  for ( var t in this._inputsBoundList )
  {
    this._inputsBoundTo.addEventListener( t, this._inputsBoundList[t], false );
  };
}
/**
 * Calls destroy on all GL resource objects. Good practice is to remove all objects when they shouldn't be used anymore, but make sure to call this function in an unload function for you HTML page.
 */
PXF.Instance.prototype.CleanUp = function()
{
    var _pxfResourceArray = this.AllTextures.concat( this.AllGeometry.concat( this.AllFramebuffers ) );

    for (var res in _pxfResourceArray )
    {
        if ( _pxfResourceArray[res].Destroy )
             _pxfResourceArray[res].Destroy();
        else {
            console.error("[/pxf.js:202] Unhandled PXF Resources",_pxfResourceArray[res]);
        }
    };

    /*
    // GLboolean isTexture(WebGLTexture? texture)
    for (var i in PXF.AllTextures)
    {
        var tex = PXF.AllTextures[i];

        if ( tex && (tex instanceof PXF.Texture || tex instanceof PXF.TextureCube) ) 
        {
            tex.Destroy();
        }
    }

    for (var j in PXF.AllGeometry)
    {
        var geo = PXF.AllGeometry[j];

        if ( geo instanceof PXF.Geometry )
            geo.Destroy();
    }

    for (var k in PXF.AllFramebuffers)
    {
        var fbo = PXF.AllFramebuffers[k];


        fbo.Destroy();
    } */

    this.AllTextures     = [];
    this.AllGeometry     = [];
    this.AllFramebuffers = [];

    this.TextureResizeFBO = undefined;
};


PXF.Instance.prototype.Screenshot = function( openInWindow ) {

    var s_x = 0,
        s_y = 0,
        s_w = this.ctxWidth,
        s_h = this.ctxHeight;

    console.log("[/pxf.js:249] Taking screenshot @ ({0},{1},{2},{3})".format(s_x,s_y,s_w,s_h));

    var pixels  = new Uint8Array( s_w * s_h * 4);

    this.gl.readPixels( s_x,s_y,s_w,s_h, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels );

    // create a temporary canvas element and update its pixels
    var tcanvas    = document.createElement('canvas');
    var c          = tcanvas.getContext("2d");
    var canvasData = c.getImageData( 0, 0, s_w, s_h );
    tcanvas.width  = s_w;
    tcanvas.height = s_h;

    // if (  )
    //canvasData.data.set(pixels);
    for (var y = 0; y < s_h; y++)
    {
        var ty = s_h - 1 - y;
        for (var x = 0; x < s_w; x++)
        {
            var id1 = (y * s_w) + x;
            var id2 = (ty * s_w) + x;

            canvasData.data[id1*4 + 0] = pixels[id2*4 + 0];
            canvasData.data[id1*4 + 1] = pixels[id2*4 + 1];
            canvasData.data[id1*4 + 2] = pixels[id2*4 + 2];
            canvasData.data[id1*4 + 3] = pixels[id2*4 + 3];
        }
    }

    // convert canvas element to png data and update in a new window
    c.putImageData(canvasData, 0, 0);

    var dataUrl = tcanvas.toDataURL("image/png");

    if ( openInWindow ) window.open(dataUrl);

    tcanvas = null;

   return dataUrl;
}

// simple frame info managament
PXF.Instance.prototype.FrameBegin = function() {
    // todo: add timers etc for frame-delta handling?
    this.__frameInfo = {
        drawcalls           : 0,
        trianglecount       : 0,
        vertexcount         : 0
   };
};

/**
 * Enable WebGL Extensions supported by client browser.
 * @function
 */
PXF.Instance.prototype.EnableExtensions = function()
{
    this.extensions = {};

    var extPrefix = ["WEBKIT_","MOZ_","ANGLE_"];
    var extList   = this.gl.getSupportedExtensions();

    for ( var e in extList ) {
        (function( gl ) {
            var ext = extList[e];
            var n = ext;

            for ( var p in extPrefix ) if ( ext.search(extPrefix[p]) >= 0 ) {
                n = ext.replace(extPrefix[p],""); break;
            }                   

            // console.log("[/pxf.js:321] enabled extensions: " + ext);
            this.extensions[n] = gl.getExtension(ext);
        }.bind(this))(this.gl);
    }

    this.extensions["WEBGL_debug_shaders"] = this.gl.getExtension( "WEBGL_debug_shaders" );
};

// PXF.EnableExtensions = function(_gl) {
//     var extPrefix = ["WEBKIT_","MOZ_","ANGLE_"];
//     var extList   = _gl.getSupportedExtensions(); 
//     // console.log(extList);

//     // load extension objects
//     PXF.Extensions = {};

//     for ( var e in extList ) {
//         (function() {
//             var ext = extList[e];
//             var n = ext;

//             for ( var p in extPrefix ) if ( ext.search(extPrefix[p]) >= 0 ) {
//                 n = ext.replace(extPrefix[p],""); break;
//             }                   

//             console.log("[/pxf.js:346] enabled extensions: " + ext);
//             PXF.Extensions[n] = _gl.getExtension(ext);
//         })();
//     };

//     this.WEBGL_debug_shaders = this.gl.getExtension( "WEBGL_debug_shaders" );
// }

// per-frame info, reset by calling PXF.FrameBegin()
PXF.Instance.prototype.UpdateFrameInfo = function( info ) {
    if( !this.__frameInfo ) this.FrameBegin();

    var frameInfo = this.__frameInfo;

    switch ( info.type )
    {
        case( PXF.DRAW_ELEMENTS ) : 
            // console.warn("[/pxf.js:363] PXF.UpdateFrameInfo.DrawElements not implemented");
            break;
        case( PXF.DRAW_ARRAYS ) :
            {
                frameInfo.drawcalls++;

                // GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, and GL_TRIANGLES
                     if ( info.primitiveType == this.gl.TRIANGLES )  frameInfo.trianglecount += info.drawLength / 3;
                else if ( info.primitiveType == this.gl.POINTS )     frameInfo.trianglecount += info.drawLength / 6; // 2 per point
                else if ( info.primitiveType == this.gl.LINE_STRIP ) ; // TODO
                else if ( info.primitiveType == this.gl.LINE_LOOP ) ; // TODO
                else if ( info.primitiveType == this.gl.LINES ) ; // TODO
                else if ( info.primitiveType == this.gl.TRIANGLE_STRIP ) ; // TODO
                else if ( info.primitiveType == this.gl.TRIANGLE_FAN ) ; // TODO

                frameInfo.maxtrianglecount = Math.max( frameInfo.maxtrianglecount, frameInfo.trianglecount );

            } break;
        case( PXF.DRAW_NONE ) :
            break;
        default :
            console.warn("[/pxf.js:384] PXF.UpdateFrameInfo.type " + info.type + " not implemented");
            break;
    };
};


PXF.Instance.prototype.ToggleFullscreen = function( alternative_elem )
{
    var elem = this.canvas;
    if (alternative_elem)
    {
        elem = alternative_elem;
    }
    
    if ((document.fullScreenElement && document.fullScreenElement !== null) ||    // alternative standard method
    (!document.mozFullScreen && !document.webkitIsFullScreen)) {               // current working methods

        if (elem.requestFullScreen) {
            elem.requestFullScreen();
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        } else if (elem.webkitRequestFullScreen) {
            elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
        }

    } else {

        if (document.cancelFullScreen) {
            document.cancelFullScreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
        }

    }
};

PXF.Instance.prototype.BuildShaderLib = function() {
    // build and replace all entrys in shader lib 
    this.Shaderlib = {};
    for ( var s in PXF.Shaderlib ) {
        var shader          = PXF.Shaderlib[s];
        this.Shaderlib[s]   = new PXF.Shader( this, shader.vsRaw, shader.fsRaw );
    }
}

PXF.Instance.prototype.SetWebGLTransition = function() {

    var state   = this.webglState;
    var gl      = this.gl;
    var ctx     = this;

    // console.log(gl.BLEND.toString());

    var glCaps                                          = {};
        glCaps[gl.BLEND.toString()]                     = "BLEND";
        glCaps[gl.CULL_FACE.toString()]                 = "CULL_FACE";
        glCaps[gl.DEPTH_TEST.toString()]                = "DEPTH_TEST";
        glCaps[gl.DITHER.toString()]                    = "DITHER";
        glCaps[gl.POLYGON_OFFSET_FILL.toString()]       = "POLYGON_OFFSET_FILL";
        glCaps[gl.SAMPLE_ALPHA_TO_COVERAGE.toString()]  = "SAMPLE_ALPHA_TO_COVERAGE";
        glCaps[gl.SAMPLE_COVERAGE.toString()]           = "SAMPLE_COVERAGE";
        glCaps[gl.SCISSOR_TEST.toString()]              = "SCISSOR_TEST";
        glCaps[gl.STENCIL_TEST.toString()]              = "STENCIL_TEST";


    // return true if transition needed
    this.GLStateTransitionFunctions = {
        activeTexture : function() {
            if( state.ACTIVE_TEXTURE != arguments[0]) {
                state.ACTIVE_TEXTURE  = arguments[0];
                return true;
            };  return false;
        },
        attachShader: function () { return true; },
        bindAttribLocation: function () { return true; },   
        bindBuffer: function () { return true; },   
        bindFramebuffer: function () { return true; },   
        bindRenderbuffer: function () { return true; },   
        bindTexture: function () {
            var textureUnit         = state.ACTIVE_TEXTURE - gl.TEXTURE0;
            var textureUnitString   = "TEXTURE_BINDING_2D_" + textureUnit;

            if( state[textureUnitString] != arguments[1] ) {
                state[textureUnitString]  = arguments[1];
                return true;
            };  return false;
        },
        blendColor: function () { return true; },   
        blendEquation: function () { return true; },   
        blendEquationSeparate: function () { return true; },   
        blendFunc: function () { return true; },   
        blendFuncSeparate: function () { return true; },   
        bufferData: function () { return true; },   
        bufferSubData: function () { return true; }, 
        checkFramebufferStatus: function () { return true; },   
        clear: function () { return true; },   
        clearColor: function () { return true; },   
        clearDepth: function () { return true; },   
        clearStencil: function () { return true; },   
        colorMask: function () { return true; },   
        compileShader: function () { return true; },   
        compressedTexImage2D: function () { return true; },   
        compressedTexSubImage2D: function () { return true; },   
        copyTexImage2D: function () { return true; },   
        copyTexSubImage2D: function () { return true; },   
        createBuffer: function () { return true; },   
        createFramebuffer: function () { return true; },   
        createProgram: function () { return true; },   
        createRenderbuffer: function () { return true; },   
        createShader: function () { return true; },   
        createTexture: function () { return true; },   
        cullFace: function () { return true; },  
        deleteBuffer: function () { return true; },   
        deleteFramebuffer: function () { return true; },   
        deleteProgram: function () { return true; },   
        deleteRenderbuffer: function () { return true; },   
        deleteShader: function () { return true; },   
        deleteTexture: function () { return true; },   
        depthFunc: function () { return true; },   
        depthMask: function () { return true; },   
        depthRange: function () { return true; },   
        detachShader: function () { return true; },   
        disable: function () { 
            var capKey = arguments[0].toString();
            var capStr = glCaps[capKey];

            if ( state[capStr] ) {
                state[capStr] = false;
                return true;
            };  return false; 
        },   
        disableVertexAttribArray: function () { return true; },   
        drawArrays: function () { return true; },   
        drawElements: function () { return true; },   
        enable: function () { 
            var capKey = arguments[0].toString();
            var capStr = glCaps[capKey];

            if ( !(state[capStr]) ) {
                state[capStr] = true;
                return true;
            };  return false; 
        },   
        enableVertexAttribArray: function () { return true; },
        finish: function () { return true; },   
        flush: function () { return true; },   
        framebufferRenderbuffer: function () { return true; },   
        framebufferTexture2D: function () { return true; }, 
        frontFace: function () { return true; },   
        generateMipmap: function () { return true; },   
        getActiveAttrib: function () { return true; },   
        getActiveUniform: function () { return true; },   
        getAttachedShaders: function () { return true; },   
        getAttribLocation: function () { return true; },   
        getBufferParameter: function () { return true; },   
        getContextAttributes: function () { return true; },   
        getError: function () { return true; },   
        getExtension: function () { return true; },  
        getFramebufferAttachmentParameter: function () { return true; },   
        getParameter: function () { return true; },   
        getProgramInfoLog: function () { return true; },   
        getProgramParameter: function () { return true; },   
        getRenderbufferParameter: function () { return true; },   
        getShaderInfoLog: function () { return true; },   
        getShaderParameter: function () { return true; },   
        getShaderPrecisionFormat: function () { return true; },   
        getShaderSource: function () { return true; },   
        getSupportedExtensions: function () { return true; },   
        getTexParameter: function () { return true; },   
        getUniform: function () { return true; },   
        getUniformLocation: function () { return true; },   
        getVertexAttrib: function () { return true; },   
        getVertexAttribOffset: function () { return true; },   
        hint: function () { return true; }, 
        ignoreErrors: function () { return true; },   
        isBuffer: function () { return true; },   
        isContextLost: function () { return true; },   
        isEnabled: function () { return true; },   
        isFramebuffer: function () { return true; },   
        isProgram: function () { return true; },   
        isRenderbuffer: function () { return true; },   
        isShader: function () { return true; },   
        isTexture: function () { return true; }, 
        lineWidth: function () { return true; },   
        linkProgram: function () { return true; },   
        mark: function () { return true; },   
        pixelStorei: function () { return true; },   
        polygonOffset: function () { return true; },   
        readPixels: function () { return true; },   
        releaseShaderCompiler: function () { return true; },   
        renderbufferStorage: function () { return true; },
        sampleCoverage: function () { return true; },   
        scissor: function () { return true; },   
        shaderSource: function () { return true; },
        stencilFunc: function () { return true; },   
        stencilFuncSeparate: function () { return true; },   
        stencilMask: function () { return true; },   
        stencilMaskSeparate: function () { return true; },   
        stencilOp: function () { return true; },   
        stencilOpSeparate: function () { return true; },   
        texImage2D: function () { return true; },   
        texParameterf: function () { return true; },   
        texParameteri: function () { return true; },   
        texSubImage2D: function () { return true; },   
        uniform1f: function () { return true; },   
        uniform1fv: function () { return true; },   
        uniform1i: function () { return true; },   
        uniform1iv: function () { return true; },   
        uniform2f: function () { return true; },   
        uniform2fv: function () { return true; },   
        uniform2i: function () { return true; },   
        uniform2iv: function () { return true; },   
        uniform3f: function () { return true; },   
        uniform3fv: function () { return true; },   
        uniform3i: function () { return true; },   
        uniform3iv: function () { return true; },   
        uniform4f: function () { return true; },   
        uniform4fv: function () { return true; },   
        uniform4i: function () { return true; },   
        uniform4iv: function () { return true; },   
        uniformMatrix2fv: function () { return true; },   
        uniformMatrix3fv: function () { return true; },   
        uniformMatrix4fv: function () { return true; },   
        useProgram: function () { 
            if (    state.CURRENT_PROGRAM != arguments[0] ) {
                    state.CURRENT_PROGRAM  = arguments[0];
                    return true; 
            };      return false;
        },   
        validateProgram: function () { return true; },   
        vertexAttrib1f: function () { return true; },   
        vertexAttrib1fv: function () { return true; },   
        vertexAttrib2f: function () { return true; },   
        vertexAttrib2fv: function () { return true; },   
        vertexAttrib3f: function () { return true; },   
        vertexAttrib3fv: function () { return true; },   
        vertexAttrib4f: function () { return true; },   
        vertexAttrib4fv: function () { return true; },   
        vertexAttribPointer: function () { return true; },   
        viewport: function () { return true; }
    };


    // inject gl functions
    for ( var attr in gl ) {
        // bind var to closures
        (function() {
            var attrStr = (function() { var attrStr = attr; return attrStr; })();
            var oldFun  = (function() { return gl[attr]; })();

            if ( typeof(oldFun) == "function" && attrStr in ctx.GLStateTransitionFunctions ) {

                gl[ attrStr ] = function() {
                    if( ctx.GLStateTransitionFunctions[attrStr].apply( null, arguments ) )
                            return oldFun.apply(gl, arguments );
                    else    return state[ attrStr ];
                }

                gl[ attrStr ].oldFun = oldFun;
            }
        })();
    }   

}

PXF.Instance.prototype.SetWebGLState = function() {
    if(!this.gl) return;

    var gl      = this.gl;
    var ctx     = this;

    // set state params
    this.webglState = {
        "ACTIVE_TEXTURE"                        : null, 
        "ALPHA_BITS"                            : null, 
        "BLEND"                                 : null, 
        "BLEND_COLOR"                           : null, 
        "BLEND_DST_ALPHA"                       : null, 
        "BLEND_DST_RGB"                         : null, 
        "BLEND_EQUATION_ALPHA"                  : null, 
        "BLEND_EQUATION_RGB"                    : null, 
        "BLEND_SRC_ALPHA"                       : null, 
        "BLEND_SRC_RGB"                         : null, 
        "BLUE_BITS"                             : null, 
        "COLOR_CLEAR_VALUE"                     : null, 
        "COLOR_WRITEMASK"                       : null, 
        "CULL_FACE"                             : null, 
        "CULL_FACE_MODE"                        : null, 
        "CURRENT_PROGRAM"                       : null, 
        "DEPTH_BITS"                            : null, 
        "DEPTH_CLEAR_VALUE"                     : null, 
        "DEPTH_FUNC"                            : null, 
        "DEPTH_RANGE"                           : null, 
        "DEPTH_TEST"                            : null, 
        "DEPTH_WRITEMASK"                       : null, 
        "DITHER"                                : null, 
        "ELEMENT_ARRAY_BUFFER_BINDING"          : null,
        "FRAGMENT_SHADER_DERIVATIVE_HINT_OES"   : null,
        "FRAMEBUFFER_BINDING"                   : null,
        "FRONT_FACE"                            : null,
        "GENERATE_MIPMAP_HINT"                  : null,
        "GREEN_BITS"                            : null,
        "LINE_WIDTH"                            : null,
        "MAX_COMBINED_TEXTURE_IMAGE_UNITS"      : null,
        "MAX_CUBE_MAP_TEXTURE_SIZE"             : null,
        "MAX_FRAGMENT_UNIFORM_VECTORS"          : null,
        "MAX_RENDERBUFFER_SIZE"                 : null,
        "MAX_TEXTURE_MAX_ANISOTROPY_EXT"        : null,
        "MAX_VARYING_VECTORS"                   : null,
        "MAX_VERTEX_ATTRIBS"                    : null,
        "MAX_VERTEX_TEXTURE_IMAGE_UNITS"        : null,
        "MAX_VERTEX_UNIFORM_VECTORS"            : null,
        "MAX_VIEWPORT_DIMS"                     : null,
        "MAX_TEXTURE_IMAGE_UNITS"               : null,
        "MAX_TEXTURE_SIZE"                      : null,
        "PACK_ALIGNMENT"                        : null,
        "POLYGON_OFFSET_FACTOR"                 : null,
        "POLYGON_OFFSET_FILL"                   : null,
        "POLYGON_OFFSET_UNITS"                  : null,
        "RED_BITS"                              : null,
        "RENDERBUFFER_BINDING"                  : null,
        "RENDERER"                              : null,
        "SAMPLE_BUFFERS"                        : null,
        "SAMPLE_COVERAGE_INVERT"                : null,
        "SAMPLE_COVERAGE_VALUE"                 : null,
        "SAMPLES"                               : null,
        "SCISSOR_BOX"                           : null,
        "SCISSOR_TEST"                          : null,
        "SHADING_LANGUAGE_VERSION"              : null,
        "STENCIL_BACK_FAIL"                     : null,
        "STENCIL_BACK_FUNC"                     : null,
        "STENCIL_BACK_PASS_DEPTH_FAIL"          : null,
        "STENCIL_BACK_PASS_DEPTH_PASS"          : null,
        "STENCIL_BACK_REF"                      : null,
        "STENCIL_BACK_VALUE_MASK"               : null,
        "STENCIL_BACK_WRITEMASK"                : null,
        "STENCIL_BITS"                          : null,
        "STENCIL_CLEAR_VALUE"                   : null,
        "STENCIL_FAIL"                          : null,
        "STENCIL_FUNC"                          : null,
        "STENCIL_PASS_DEPTH_FAIL"               : null,
        "STENCIL_PASS_DEPTH_PASS"               : null,
        "STENCIL_REF"                           : null,
        "STENCIL_TEST"                          : null,
        "STENCIL_VALUE_MASK"                    : null,
        "STENCIL_WRITEMASK"                     : null,
        "SUBPIXEL_BITS"                         : null,
        "UNPACK_ALIGNMENT"                      : null,
        "UNPACK_COLORSPACE_CONVERSION_WEBGL"    : null,
        "UNPACK_FLIP_Y_WEBGL"                   : null,
        "UNPACK_PREMULTIPLY_ALPHA_WEBGL"        : null,
        "VENDOR"                                : null,
        "VERSION"                               : null,
        "VIEWPORT"                              : null
    };

    // helpers
    this.GetActiveTexture           = function() { return this.webglState["ACTIVE_TEXTURE"];            };
    this.GetMaxTextureUnits         = function() { return this.webglState["MAX_TEXTURE_IMAGE_UNITS"];   };
    this.GetMaxTextureSize          = function() { return this.webglState["MAX_TEXTURE_SIZE"];          };
    this.GetMaxCubeMapTextureSize   = function() { return this.webglState["MAX_CUBE_MAP_TEXTURE_SIZE"]; };

    // set state
    for( var s in this.webglState ) if ( gl[s] ) {
        this.webglState[s] = gl.getParameter( gl[s] );
    }

    // set texture bindings
    var activeBind  = gl.getParameter(gl.ACTIVE_TEXTURE);

    for( var t = 0; t < this.GetMaxTextureUnits(); t++) {
        gl.activeTexture(gl.TEXTURE0 + t);

        this.webglState["TEXTURE_BINDING_2D_"       + t] = gl.getParameter(gl.TEXTURE_BINDING_2D);
        this.webglState["TEXTURE_BINDING_CUBE_MAP"  + t] = gl.getParameter(gl.TEXTURE_BINDING_CUBE_MAP);
    }

    gl.activeTexture(activeBind);
}

/**
 * @function 
 * Queries the OpenGL error string and prints WebGL errors if there are any.
 * @param {string} [scope=""] The current scope getError is called from, for easier debugging.
 * @return {mixed} Returns a print friendly WebGL error string if an error occurred, returns false if there was no error.
 */
PXF.Instance.prototype.getError = function ( scope )
{
  var error = this.gl.getError();
  var gl = this.gl;

  if (error != gl.NO_ERROR) {
    scope = scope || "";

    var err_str = "";
    switch (error) {
      case gl.INVALID_ENUM:
        err_str = "INVALID_ENUM";
        break;
      case gl.INVALID_VALUE:
        err_str = "INVALID_VALUE";
        break;
      case gl.INVALID_OPERATION:
        err_str = "INVALID_OPERATION";
        break;
      case gl.STACK_OVERFLOW:
        err_str = "STACK_OVERFLOW";
        break;
      case gl.STACK_UNDERFLOW:
        err_str = "STACK_UNDERFLOW";
        break;
      case gl.OUT_OF_MEMORY:
        err_str = "OUT_OF_MEMORY";
        break;
      default:
        err_str = "UNKNOWN";
        break;
    }

    return (scope + " Error: " + err_str + " (" + error + ")");
  }

  return false; 
};

PXF.Instance.prototype.printError = function ( scope )
{
    var err = this.getError(scope); 
    if ( err ) ERROR( scope + err ); 
}

/**
 * Render helper function - DEPRECATED/untested
 */
PXF.Instance.prototype.RenderObject = function(scene, object, shader, camera, bindBuffers, bindTextures) {
    if(scene && object && shader) {
    
        // only know how to render mesh objects
        if (object instanceof PXF.MeshObject || object instanceof PXF.AnimatedMeshObject)
        {
            // Set model matrix in shader
            var mvmat           = mat4.identity();

            //mat4.multiply(sceneTransform, object.WorldTransform, sceneTransform);
            //mat4.multiply(camera.WorldTransform, sceneTransform, mvmat);
            mat4.multiply(camera.worldtransform, object.worldtransform, mvmat);

            shader.SetUniform("uMVMatrix", mvmat);
            shader.SetUniform("uNMatrix", camera.normaltransform);
            
            // Bind textures
            // todo: set texture ID from dict key?
            var texUnitCounter = 0;
            if ( object.texture && (bindTextures || bindTextures == undefined) ) 
            {
                if(object.texture in scene.textures) 
                {
                    scene.textures[object.texture].Bind( shader, "tex0", 0 );
                }
            }
            
            // Bind and draw mesh buffers
            object.Draw(shader, bindBuffers);
        }

        // render children
        for (var c in object.children)
        {
            this.RenderObject(scene, object.children[c], shader, camera, bindBuffers, bindTextures);
        }
    }
}

/**
 * Updates all object in tree.
 * @param {PXF.Scene} scene Scene to update.
 * @param {number} delta Time passed since last frame.
 */
PXF.Instance.prototype.UpdateObjects = function(scene, delta) {

    if ( scene && scene.root && scene.root instanceof PXF.Object )
    {
        scene.root.Update(delta);
    }

};

/**
 * @function 
 * Simple scene object renderer. Loops recursively through the object children and renders Mesh objects.
 * @param {PXF.Scene} scene Scene to render.
 * @param {PXF.Shader} shader Shader object used to render each 3D object.
 * @param {PXF.Camera} camera Camera object that always will be used to render each 3D object.
 */
PXF.Instance.prototype.Render = function(scene, shader, camera, bindBuffers, bindTextures)
{
    // pre-frame

    shader.Bind();
    shader.SetUniform("uPMatrix", camera.pMatrix);

    // render scene graph
    //for (var c in scene.root.children)
    if ("root" in scene)
    {
        this.RenderObject(scene, scene.root, shader, camera, bindBuffers, bindTextures);
    }

    shader.Unbind();

    // post-frame
    // reset mouse state
    PXF._inputReset();
};

PXF.Instance.prototype.ResetInput = function() 
{
    this._inputState.mouseMoved         = false;
    this._inputState.mouseDelta         = [0,0];
    this._inputState.mouseWheelDelta    = 0;
    this._inputState.mouseDoubleClicked = false;
    this._inputState.touches            = {};
};

PXF.Instance.prototype.UpdateInput = function() 
{
    if (this._inputState.callbackOnUpdate)
    {
        for (var k in this._inputState.keyState)
        {
            // are there any actions for this key?
            if (this._inputState.keyState[k] != undefined)
            {                                   
                var action = this._inputState.keyState[k].state;
                var event = this._inputState.keyState[k].event;

                // call the global key callback
                if (this._inputState.keyGlobal)
                {
                    this._inputState.keyGlobal(action, event);
                }

                if (this._inputState.keyCallbacks)
                {
                    // does the current key have any callback registered?
                    if (this._inputState.keyCallbacks[k])
                    {
                        var c = (PXF._translateKeyCodeToString.bind(this))(k);

                        // call each callback!
                        for (var i in this._inputState.keyCallbacks[k])
                        {
                            this._inputState.keyCallbacks[k][i](action, c, event);
                        }
                    }
                }
            
                if (action == "up")
                {

                    // remove everything before 
                    delete this._inputState.keyState[k];
                }
            }
        }
    };
}

/**
 * Updates the context (objects/input)
 * @param {number} delta Time delta.
 * @param {PXF.Scene} scene PXF.Scene to update.
 */
PXF.Instance.prototype.Update = function(delta, scene)
{
    // update scene graph objects
    if (scene) this.UpdateObjects(scene, 1000.0/60.0);

    this.UpdateInput();
};





/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/GenericWorker.js: */

// DEPENDENCIES: /pxf.js

PXF.GenericWorker = function(path, dependencies )
{
	if (!path) {
		console.error("[/extra/GenericWorker.js:6] No path passed to GenericWorker");
		return;
	};

	var w    = {};
	w.jobs = {};
	w.worker = new Worker(path);
	w.ready = true;
	w.worker.onmessage = function(event)
	{
		var payload = event.data.payload;

		switch( event.data.msg )
		{
			case("log") : 
				LOG( payload );
				break;
			case("run") : 
				console.log("[/extra/GenericWorker.js:24] Finished job " + payload.uuid );
				w.jobs[payload.uuid].oncomplete && w.jobs[payload.uuid].oncomplete( payload.result );
				this.ready = true;
				break;
			default: console.log("[/extra/GenericWorker.js:28] Unknown msg type " + event.data.msg);
		}
	};

	w.worker.onerror = function(event)
	{
		console.error("[/extra/GenericWorker.js:34] Received new error @ GenericWorker");
	};

	w.AddDependency = function( k, v )
	{
		this.worker.postMessage( { msg : "dependency", payload : { key : k, value : v } });
	}

	w.Run = function( fn,oncomplete, args )
	{
		var fn_string = fn.toString();
		var fn_args  = fn_string.substring( fn_string.indexOf("(") + 1, fn_string.indexOf(")") );
		var fn_body = fn_string.substring( fn_string.indexOf("{") + 1, fn_string.lastIndexOf("}") );
		var uuid = guid();

		if ( uuid in this.jobs ){
			console.warn("[/extra/GenericWorker.js:50] Job " + uuid + " already exists in GenericWorker");
			return false;
		}

		this.ready = false;
		this.jobs[uuid]   = { fn : fn, oncomplete : oncomplete };
		this.worker.postMessage( { msg : "run", payload : { fn_args : fn_args.split(","), fn_body : fn_body, uuid : uuid, args : args } } );
	};

	w.Close = function()
	{
		this.worker.terminate();
		delete this.worker;
	};

	for( var d in dependencies )
	{
		w.AddDependency( d, dependencies[d] );
	}


	return w;
};

PXF.NewResourceWorker = function()
{
	if ( !PXF.__resourceWorkers ) PXF.__resourceWorkers = [];

	var worker = PXF.GenericWorker.apply(null,arguments);
	worker.id = PXF.__resourceWorkers.length+1;

	PXF.__resourceWorkers.push(worker);

	return worker;
};

PXF.GetResourceWorker = function()
{
	if(!this.__resourceWorkers) return;

	if (this.__resourceWorkers.lastpicked === undefined)
		this.__resourceWorkers.lastpicked=0;

	var worker;

	for( var r in this.__resourceWorkers )
	{
		if ( this.__resourceWorkers[r].ready )
			worker = this.__resourceWorkers[r];
	};

	if ( worker === undefined )
	{
		this.__resourceWorkers.lastpicked = (this.__resourceWorkers.lastpicked+1) % this.__resourceWorkers.length;
		return this.__resourceWorkers[this.__resourceWorkers.lastpicked];
	};

	return worker;
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/resource/Shader.js: */

/**
 * Constructor for the Shader class.
 * @constructor
 * @param {WebGLContext} gl WebGL context.
 * @param {string} vert Vertex shader source.
 * @param {string} frag Fragment shader source.
 * @param {boolean} extern True if vertex and fragment sources are external files and should be treated as paths.
 * @returns {PXF.Shader} Returns a PXF.Shader (compiled and linked vertex/fragment shaders), on failure returns false.
 * 
 * @class Simple Shader class.
 * @property {GL_UINT} program GLSL Shader program handle.
 * @property {string} vs Vertex shader source.
 * @property {string} fs Fragment shader source. 
 */
PXF.Shader = function(ctx, vert, frag, extern)
{

	this.ctx      = ctx;
	this.gl       = ctx.gl;
	this.program  = undefined;
	this.extern   = extern; // true if vert and frag are URLs
	this.vs       = this.gl.createShader(this.gl.VERTEX_SHADER);
	this.fs       = this.gl.createShader(this.gl.FRAGMENT_SHADER);
	this.program  = null;
	this.bound 	  = false;
	
	this.vsRaw    = vert;
	this.fsRaw    = frag;
	
	this.err        = {};
	this.latest_err = "";

	this.uniforms = {};
	
	// uniform lookups
	this.uniformFunctions = { };
	
	// BOOLS
	this.uniformFunctions[this.gl.BOOL] 		= this.gl.uniform1i;
	this.uniformFunctions[this.gl.BOOL_VEC2] 	= this.gl.uniform2iv;
	this.uniformFunctions[this.gl.BOOL_VEC3] 	= this.gl.uniform3iv;
	this.uniformFunctions[this.gl.BOOL_VEC4] 	= this.gl.uniform4iv;

	// INTS
	this.uniformFunctions[this.gl.INT] 			= this.gl.uniform1i;
	this.uniformFunctions[this.gl.INT_VEC2]  	= this.gl.uniform2iv;
	this.uniformFunctions[this.gl.INT_VEC3] 	= this.gl.uniform3iv;
	this.uniformFunctions[this.gl.INT_VEC4] 	= this.gl.uniform4iv;

	// FLOATS
	this.uniformFunctions[this.gl.FLOAT]		= this.gl.uniform1f;
	this.uniformFunctions[this.gl.FLOAT_VEC2]	= this.gl.uniform2fv;
	this.uniformFunctions[this.gl.FLOAT_VEC3]	= this.gl.uniform3fv;
	this.uniformFunctions[this.gl.FLOAT_VEC4]	= this.gl.uniform4fv;

	// MATRICES
	this.uniformFunctions[this.gl.FLOAT_MAT2] 	= this.gl.uniformMatrix2fv;	
	this.uniformFunctions[this.gl.FLOAT_MAT3]	= this.gl.uniformMatrix3fv;
	this.uniformFunctions[this.gl.FLOAT_MAT4] 	= this.gl.uniformMatrix4fv;

	// samplers
	this.uniformFunctions[this.gl.SAMPLER_2D] 	= this.gl.uniform1i;
	this.uniformFunctions[this.gl.SAMPLER_CUBE] = this.gl.uniform1i;

	if ( vert && frag && !this.Build())
	{


		if ( this.extern ) 	console.error("[/resource/Shader.js:69] Failed while building shader '" + this.vsRaw + "' & '" + this.fsRaw + "': " + this.latest_err);
		else 				console.error("[/resource/Shader.js:70] Failed while building shader: " + this.latest_err);
		return this;
	}
}

PXF.Shader.prototype._AddError = function(err) {

	this.latest_err = err;

	if (!(this.latest_err in this.err)) {
		this.err[err] = 1;
		return true;
	}
	this.err[err] += 1;
	return false;

};


PXF.Shader.prototype.SetUniformCache = function() {
	var gl = this.gl;
	var activeUniforms = gl.getProgramParameter(this.program,gl.ACTIVE_UNIFORMS);

	for(var i = 0; i < activeUniforms; i++) {
		var activeUniformInfo = gl.getActiveUniform(this.program,i);

		var name = activeUniformInfo.name;
		var type = activeUniformInfo.type;

		var loc  = gl.getUniformLocation(this.program, name);

		this.uniforms[name] = [loc,type];
	}
};

/**
 * Builds (and rebuilds) the shader from sources supplied in the constructor.
 * If previously supplied sources was filepaths, the files will be reloaded as well.
 */
PXF.Shader.prototype.Build = function( )
{
	this.compiled 	= false;
	var gl 			= this.gl;
	
	// Detach vert/frag shader if this isn't the first time we call Build
	gl.useProgram(null);
	if (this.program != null)
	{
		gl.detachShader(this.program, this.vs);
		gl.detachShader(this.program, this.fs);
		console.log("[/resource/Shader.js:120] detaching old vertex and fragment shaders");
	} else {
		this.program = gl.createProgram();	
		// console.log("[/resource/Shader.js:123] creating new shader program");
	}
	
	// Clear buffered uniforms and attribs
	this.uniforms = {};
	this.attribs  = {};
	
	var vs = this.vsRaw;
	var fs = this.fsRaw;

	if (this.extern)
	{
		vs = PXF.LoadRawFile(vs);
		fs = PXF.LoadRawFile(fs);

		this.extern_vs = vs;
		this.extern_fs = fs;
	};
	
	// Create vertex shader
	gl.shaderSource(this.vs, vs);
	gl.compileShader(this.vs);
	if (!gl.getShaderParameter(this.vs, gl.COMPILE_STATUS)) {
		this._AddError("Could not compile vertex shader: " + gl.getShaderInfoLog(this.vs));
		//console.log(WEBGL_debug_shaders.getTranslatedShaderSource(this.vs));
		return false;
	}
	
	// Create fragment shader
	gl.shaderSource(this.fs, fs);
	gl.compileShader(this.fs);
	if (!gl.getShaderParameter(this.fs, gl.COMPILE_STATUS)) {
		this._AddError("Could not compile fragment shader: " + gl.getShaderInfoLog(this.fs));
		//console.log(WEBGL_debug_shaders.getTranslatedShaderSource(this.fs));
		return false;
	}
	
	// Create shader program
	gl.attachShader(this.program, this.vs);
	gl.attachShader(this.program, this.fs);
	gl.linkProgram(this.program);
			
	if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
		this._AddError("Could not initilize/link shader; " + gl.getProgramInfoLog(this.program));

		// pop gl error
		var error = gl.getError();

		return false;
	}

	if ( this.ctx.extensions.WEBGL_debug_shaders )
	{
		this.hlsl_vs = this.ctx.extensions.WEBGL_debug_shaders.getTranslatedShaderSource(this.vs);
		this.hlsl_fs = this.ctx.extensions.WEBGL_debug_shaders.getTranslatedShaderSource(this.fs);
	}

	// everything ok, set cache
	this.SetUniformCache();
	this.compiled = true;

	return this;
};

/**
 * Shortcut to bind shader program.
 */
PXF.Shader.prototype.Bind = function()
{
	this.gl.useProgram(this.program);
};


/**
 * Shortcut to unbind shader program.
 */
PXF.Shader.prototype.Unbind = function() {
	this.gl.useProgram(null);
};

/**
 * Gets a attribute location. This method also buffers the locations internally in the Shader object.
 * @param {string} name Attribute name.
 * @returns {GLint} Returns the raw attribute location returned by WebGL.
 */
PXF.Shader.prototype.GetAttribLocation = function(name)
{
	if (this.attribs[name] >= 0)
	{
		return this.attribs[name];
	}
	
	var attrLoc = this.gl.getAttribLocation(this.program, name);
	if (attrLoc == -1)
	{
		var errormsg = "Invalid attrib location for '" + name + "':" + attrLoc;

		if ( this.extern ) errormsg += ", ( VS: '" + this.vsRaw + "', FS: '" + this.fsRaw + "')";

		if (this._AddError(errormsg)) {
			LOG(this.latest_err);
		}
	} else {
		this.gl.enableVertexAttribArray(attrLoc); // TODO Should this be done automatically?
		this.attribs[name] = attrLoc;
	}
	
	return attrLoc;
};

PXF.Shader.prototype.SetUniforms = function( uniforms )
{
	var _texUnits = 0;

	for( var u in uniforms )
	{
		var uniform = uniforms[u];

		if ( uniform instanceof PXF.Texture || uniform instanceof PXF.TextureCube )
		{
			uniform.Bind(this,u,_texUnits++);
		} else {
			this.SetUniform( u, uniforms[u] );
		}
	}
}

/**
 * Sets a shader uniform.
 * @param {string} uniType Uniform type, can be [...]
 * @param {string} name Uniform name (uniform location is gathered automatically).
 * @param {mixed} value Value to declare to uniform.
 * @param {boolean} [transpose=false] True if matrix should be transposed (only valid for "mat*" types).
 * @returns {boolean} Returns true on success, and false on failure and sets err property with appropriet error message.
 */
PXF.Shader.prototype.SetUniform = function(name, value, transpose)
{
	var gl = this.gl;

	transpose = transpose != undefined ? transpose : false;

	if ( this.uniforms[name] === undefined )
	{
		if (this._AddError("Error while setting uniform location for '" + name + "'.")) {
			LOG(this.latest_err);
		}
		return false;
	}

	var uniLoc = this.uniforms[name][0];
	var uniTyp = this.uniforms[name][1];

	// matrix functions have a different argument order
	if(uniTyp == gl.FLOAT_MAT4 || uniTyp == gl.FLOAT_MAT3 || uniTyp == gl.FLOAT_MAT2)
		this.uniformFunctions[uniTyp].call(gl,uniLoc,transpose,value)
	else 
		this.uniformFunctions[uniTyp].call(gl,uniLoc,value); 

	/*
	try {
		var uniLoc = this.uniforms[name][0];
		var uniTyp = this.uniforms[name][1];

		// matrix functions have a different argument order
		if(uniTyp == gl.FLOAT_MAT4 || uniTyp == gl.FLOAT_MAT3 || uniTyp == gl.FLOAT_MAT2)
			this.uniformFunctions[uniTyp].call(gl,uniLoc,transpose,value)
		else 
			this.uniformFunctions[uniTyp].call(gl,uniLoc,value); 

	} catch (e) {
		if (this._AddError("Error while setting uniform location for '" + name + "'.")) {
			LOG(this.latest_err);
		}
		return false;
	} */
	
	return true;
};

/**
 * Sets different shader attributes.
 * @param {string} attrType Attribute type, can be [...]
 * @param {string} name Attribute name (attrib location is gathered automatically).
 * @param {mixed} value If attribute type is "p" (vertexAttribPointer), value is the size of the buffer. Otherwise value is second parameter sent to the vertexAttrib* function.
 * @param {GLenum} type Same as type parameter to vertexAttribPointer.
 * @param {GLboolean} normalized Same as normalized parameter to vertexAttribPointer.
 * @param {GLsizei} stride Same as stride parameter to vertexAttribPointer.
 * @param {GLintptr} offset Same as offset parameter to vertexAttribPointer.
 * @returns {boolean} Returns true on success, and false on failure and sets err property with appropriet error message.
 */
PXF.Shader.prototype.VertexAttrib = function(attrType, name, value, type, normalized, stride, offset)
{	
	var gl = this.gl;
	
	var attrLoc = this.GetAttribLocation(name);
	if (attrLoc < 0)
	{
		this._AddError("Error while getting attribute location for '" + name + "'.");
		return false;
	}
	
	// TODO Change attribute types to constants instead of strings?
	switch (attrType)
	{
		case "f":
		case "f1":
			gl.vertexAttrib1f(attrLoc, value);
			break;
		case "f2":
			gl.vertexAttrib2fv(attrLoc, value);
			break;
		case "f3":
			gl.vertexAttrib3fv(attrLoc, value);
			break;
		case "f4":
			gl.vertexAttrib4fv(attrLoc, value);
			break;
		case "p":
			gl.vertexAttribPointer(attrLoc, value, type, normalized, stride, offset);
			break;
		default:
			this._AddError("Unknown attribute type.");
			return false;
			break;
	}
	
	return true;
};




/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/resource/TextureCube.js: */

// DEPENDENCIES: /pxf.js

/**
 * Constructor for the TextureCube class.
 * @constructor
 * @param {WebGLContext} gl WebGL context.
 * @param {string} [url=undefined] Create texture from this image url. 
 * @param {JSON} [settings=undefined] Texture settings, such as filter modes, data types etc.
 * @param {function} [onComplete=undefined] Function that will be called when the texture creation process is complete.
 
 * @returns {PXF.Texture} Returns a PXF.Texture, on failure returns false.
 * 
 * @class Simple Texture class.
 * @property {GL_UINT} texture Internal WebGL texture reference.
 * @property {GL_UINT} [minFilter=gl.LINEAR] OpenGL minification filter.
 * @property {GL_UINT} [magFilter=gl.LINEAR] OpenGL magnification filter.
 * @property {GL_UINT} [format=gl.RGBA] OpenGL format specification, see documentation for gl.TexImage2D for further details.
 * @property {GL_UINT} [internalFormat=gl.RGBA] OpenGL internalFormat specification, see documentation for gl.TexImage2D for further details.
 * @property {GL_UINT} [dataType=gl.UNSIGNED_BYTE] OpenGL dataType specification, see documentation for gl.TexImage2D for further details.
 * @property {number} width Width of texture. 
 * @property {number} height Height of texture. 
 */

PXF.TextureCube = function(ctx, url, settings, onComplete)
{
	var gl = ctx.gl;
	this.ctx = ctx;
	this.gl = ctx.gl;

	// sample settings
	this.minFilter 				= gl.LINEAR;
	this.magFilter 				= gl.LINEAR;
	this.wrapS     				= gl.CLAMP_TO_EDGE;
	this.wrapT     				= gl.CLAMP_TO_EDGE;

	this.format 				= gl.RGBA;
	this.internalFormat 		= gl.RGBA;
	this.dataType 				= gl.UNSIGNED_BYTE;

	this.url 					= url;	
	this.loaded 				= false;
	this.err 					= "";

	this.width 					= 0;
	this.height 				= 0;
	this.onComplete 			= onComplete;
	this.autoGenerateMipmaps 	= false;

	extend(this,settings);	

	this.Create();

	if (url && !this.UpdateFromUrl(url))
	{
		console.error("[/resource/TextureCube.js:55] Failed while creating texture: " + this.err);
	}
}

/**
 * Custom Layout, set ["+x"],["+y"],["+z"],["-x"],["-y"],["-z"] properties on the texturecube object to create a custom layout
 */
PXF.TextureCube.LAYOUT_CUSTOM 				= 1;
/**
 * Horizontal Cross Layout.
 */
PXF.TextureCube.LAYOUT_HORIZONTAL_CROSS 	= 2;
/**
 * Vertical Cross Layout.
 */
PXF.TextureCube.LAYOUT_VERTICAL_CROSS 		= 3;
/**
 * Grid layout. (not implemented)
 */
PXF.TextureCube.LAYOUT_GRID 				= 4;

/**
 * Loads an external image into the WebGL texture. 
 * @param {url} Image path.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.TextureCube.prototype.UpdateFromUrl = function(url) {
	var texobj = this;

	if ( typeof(url) == "string" ) {

		if ( this.layout === undefined ) this.layout = this.LAYOUT_HORIZONTAL_CROSS;

		// fallback to vertical cross or other types of cubemap layout?
		PXF.LoadImage( url, function(event) {
			console.log("[/resource/TextureCube.js:90] Texture loaded: " + url);
			texobj.Upload( this );
		});

		return true;
	} 
	else if ( typeof(url) == "object" ) 
	{
		// side bitmasks:
		// +x : 1
		// +y : 2
		// +z : 4
		// -x : 8
		// -y : 16
		// -z : 32
		// sum : 63


		function __loadTexCubeSide( sideUrl, sideGLEnum, sideBitMask ) {
			var __sideGLEnum 	= sideGLEnum;
			var __sideBitMask 	= sideBitMask;

			PXF.LoadImage( sideUrl, function(event) {
				this.glEnum 	= __sideGLEnum;
				this.bitMask 	= __sideBitMask;
				console.log("[/resource/TextureCube.js:115] Texture loaded: " + sideUrl);
				texobj.Upload( this );
			});
		};

		for( var side_key in url ) {
			var side_url = url[side_key];

			switch( side_key ) 
			{	
				// POSITIVE X:
				case ( '+x'		):
				case ( 'f' 		):
				case ( 'front' 	): __loadTexCubeSide( side_url, this.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 1 ); break;
				// NEGATIVE X:
				case ( '-x' 	):
				case ( 'b' 		):
				case ( 'back' 	): __loadTexCubeSide( side_url, this.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 8 ); break;

				// POSITIVE Y:
				case ( '+y' 	):
				case ( 'u' 		):
				// case ( 'up' 	): __loadTexCubeSide( side_url, this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 2 ); break;
				case ( 'up' 	): __loadTexCubeSide( side_url, this.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 2 ); break;

				case ( '-y' 	):
				case ( 'd' 		):
				// case ( 'down' 	): __loadTexCubeSide( side_url, this.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 16 ); break;
				case ( 'down' 	): __loadTexCubeSide( side_url, this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 16 ); break;

				case ( '+z' 	): __loadTexCubeSide( side_url, this.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 4 ); break;
				case ( '-z' 	): __loadTexCubeSide( side_url, this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 32 ); break;

				default: break;
			};
		};

		return true;
	}

	return false;
};

/**
 * Main data upload function.
 * @param {buffer} data Data pointer, must be Image DOM object (i think).
 */
PXF.TextureCube.prototype.Upload = function( data ) {
	// sigh, browser capability..
	if ( data ) {

		var gl 				= this.gl;

		if ( this.layout )
		{
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			var copy_from_tex 	= gl.createTexture();
			var tmp_tex 		= (new PXF.Texture( gl )).Upload( data );
			var tmp_fbo 		= new PXF.Framebuffer( gl,tmp_tex );
			var tmp_qb 			= new PXF.QuadBatch( gl );
			tmp_qb.Reset();

			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

			var cube_sides		= {};

			if ( this.layout == PXF.TextureCube.LAYOUT_HORIZONTAL_CROSS )
			{
				this.cubeSize  = this.cubeSize || data.width / 4;

				cube_sides["negx"] = [ 					0, this.cubeSize	, gl.TEXTURE_CUBE_MAP_NEGATIVE_X ];
				cube_sides["posx"] = [ 	2 * this.cubeSize, this.cubeSize	, gl.TEXTURE_CUBE_MAP_POSITIVE_X ];

				cube_sides["negy"] = [ 	 	this.cubeSize, this.cubeSize * 2, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y ];
				cube_sides["posy"] = [ 		this.cubeSize, 				   0, gl.TEXTURE_CUBE_MAP_POSITIVE_Y ];

				cube_sides["negz"] = [ 	3 * this.cubeSize, this.cubeSize	, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ];
				cube_sides["posz"] = [ 		this.cubeSize, this.cubeSize	, gl.TEXTURE_CUBE_MAP_POSITIVE_Z ];
			} 

			else if ( this.layout == PXF.TextureCube.LAYOUT_VERTICAL_CROSS )
			{
				this.cubeSize  = this.cubeSize || data.height / 4;

				cube_sides["negx"] = [ 	 				0, 	   this.cubeSize, gl.TEXTURE_CUBE_MAP_NEGATIVE_X ];
				cube_sides["posx"] = [  2 * this.cubeSize, 	   this.cubeSize, gl.TEXTURE_CUBE_MAP_POSITIVE_X ];

				cube_sides["negy"] = [ 		this.cubeSize, 0				, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y ];
				cube_sides["posy"] = [ 		this.cubeSize, this.cubeSize * 2, gl.TEXTURE_CUBE_MAP_POSITIVE_Y ];

				cube_sides["negz"] = [ 	    this.cubeSize, this.cubeSize * 3, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ];
				cube_sides["posz"] = [ 		this.cubeSize, this.cubeSize	, gl.TEXTURE_CUBE_MAP_POSITIVE_Z ];

			} else if ( this.layout == PXF.TextureCube.LAYOUT_GRID )
			{

			} else if ( this.layout == PXF.TextureCube.LAYOUT_CUSTOM )
			{
				
				if(this["+x"]) cube_sides["posx"] 	= [ this["+x"][0], this["+x"][1], gl.TEXTURE_CUBE_MAP_POSITIVE_X ];
				if(this["-x"]) cube_sides["negx"] 	= [ this["-x"][0], this["-x"][1], gl.TEXTURE_CUBE_MAP_NEGATIVE_X ];

				if(this["+y"]) cube_sides["posy"] 	= [ this["+y"][0], this["+y"][1], gl.TEXTURE_CUBE_MAP_POSITIVE_Y ];
				if(this["-y"]) cube_sides["negy"] 	= [ this["-y"][0], this["-y"][1], gl.TEXTURE_CUBE_MAP_NEGATIVE_Y ];
 
 				if(this["+z"]) cube_sides["posz"] 	= [ this["+z"][0], this["+z"][1], gl.TEXTURE_CUBE_MAP_POSITIVE_Z ];
				if(this["-z"]) cube_sides["negz"] 	= [ this["-z"][0], this["-z"][1], gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ];

			} else {
				console.error("[/resource/TextureCube.js:225] Unknown layout for cube map generation " + this.layout); return;
			};

			this.width 			= this.cubeSize;
			this.height 		= this.cubeSize;

			tmp_fbo.Bind();

			gl.bindTexture( gl.TEXTURE_CUBE_MAP, this.texture );

			for ( var k in cube_sides )
			{
				console.log("[/resource/TextureCube.js:237] Setting side " + k);

				var cube_side 	= cube_sides[k];
				var pixels 		= new Uint8Array( this.cubeSize * this.cubeSize * 4 );

				// extract pixels
				gl.readPixels( cube_side[0],cube_side[1], this.cubeSize,this.cubeSize, gl.RGBA,gl.UNSIGNED_BYTE, pixels );

				// upload pixels to cube map
				gl.texImage2D(cube_side[2], 0, this.internalFormat, this.cubeSize, this.cubeSize,0,this.format,this.dataType, pixels );
			};

			gl.bindTexture( gl.TEXTURE_CUBE_MAP, null );

			// cleanup
			// TODO: remove FBO?
			tmp_fbo.Unbind();
			tmp_tex.Destroy();

			this.loaded = true;
		} else {

			// gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.texture);
			this.gl.texImage2D( data.glEnum, 0, this.internalFormat, this.format, this.dataType, data);
			this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, null);

			this.width 	= data.width;
			this.height = data.height;

			this.__bitmask = this.__bitmask | data.bitMask;

			// check if cubemap is complete (all 6 sides are done = 1 + 2 + 4 + 8 + 16 + 32 )
			if ( this.__bitmask == 63 ) {
				this.loaded 	= true;
				this.onComplete && this.onComplete( this );
			};

			// gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
		}

	};
};

/**
 * Creates a texture handle and sets all the texture parameters. 
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.TextureCube.prototype.Create = function() {
	if ( this.ctx.AllTextures.indexOf( this ) != -1 )
		this.Destroy();

	this.ctx.AllTextures.push( this );


	var gl 			= this.gl;
	this.texture 	= this.texture || gl.createTexture();


	gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
	this.SetTextureParameters();
	gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);


	return this;
}

PXF.TextureCube.prototype.SetBytesPerPixel = function() {
	var gl = this.gl;
	var bpp;

	// build an enum list
	if( !PXF.interalFormatByteList ) {
		var enums 	= {};
		var s3 		= PXF.CheckDXTSupport();

		if ( s3 ) {
			enums[s3.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 1;
			enums[s3.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
			enums[s3.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;
			enums[s3.COMPRESSED_RGB_S3TC_DXT1_EXT]  = 0.5;	
		}

		enums[gl.ALPHA] 			= 1;
		enums[gl.LUMINANCE] 		= 1;
		enums[gl.LUMINANCE_ALPHA] 	= 2;
		enums[gl.RGB] 			  	= 3;
		enums[gl.RGBA] 				= 4;

		PXF.interalFormatByteList = enums;
	}

	// dont worry mam, im from the internet
	for(var e in PXF.interalFormatByteList) if ( e == this.internalFormat ) {
		bpp = PXF.interalFormatByteList[e];
		break;
	} 
	
	this.bpp = bpp;

	return this;
}

/**
 * Set OpenGL texture state based on this textures parameters.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.TextureCube.prototype.SetTextureParameters = function() {
	var gl = this.gl;
	
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);

	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);

	// generate mipmap if needed
	if ((this.minFilter == gl.NEAREST_MIPMAP_NEAREST ||
	     this.minFilter == gl.LINEAR_MIPMAP_NEAREST  ||
	     this.minFilter == gl.NEAREST_MIPMAP_LINEAR  ||
	     this.minFilter == gl.LINEAR_MIPMAP_LINEAR) &&
		 this.autoGenerateMipmaps
		)
	{
		gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
	}

	this.SetBytesPerPixel();

	return this;
}
/**
 * Deletes the opengl texture object.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.TextureCube.prototype.Destroy = function()
{
	this.gl.deleteTexture(this.texture);
	this.texture = undefined;
};

/**
 * Utility function that binds this texture to a shader uniform and a OpenGL texture unit.
 * @param {PXF.Shader} shader Binds the texture to this shader.
 * @param {string} samplerName Uniform name in shader.
 * @param {number} [textureSlot=0] Bind texture to specified texture unit.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.TextureCube.prototype.Bind = function(shader, samplerName, textureSlot)
{

	/*if ( shader instanceof PXF.Shader )
	{
	} else {
		textureSlot = shader === undefined ? 0 : shader;
	}*/

	var gl 				= this.gl;
	this.textureSlot 	= textureSlot || 0;

	gl.activeTexture(gl.TEXTURE0 + this.textureSlot);
	gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);

	shader.SetUniform(samplerName, this.textureSlot);


	return this;
}

PXF.TextureCube.prototype.Unbind = function() {
	var gl = this.gl;

	gl.activeTexture(gl.TEXTURE0 + this.textureSlot);
	gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

	return this;
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/core/Utils.js: */

// DEPENDENCIES: /pxf.js

if ( !window.requestAnimationFrame ) {

  window.requestAnimationFrame = ( function() {

    return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {
        window.setTimeout( callback, 1000 / 60 );
      };

  } )();
}

// from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
function s4() {
  return Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1);
};

function guid(prefix) {
	if ( prefix ) 
	{
		return prefix + "-" + s4() + s4() + '-' + s4() + '-' + s4() + '-' +
	     s4() + '-' + s4() + s4() + s4();
	}

  	return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
         s4() + '-' + s4() + s4() + s4();
};

// from https://developer.mozilla.org/en-US/docs/Web/API/DataView
var littleEndian = (function() {
	var buffer = new ArrayBuffer(2);
	new DataView(buffer).setInt16(0, 256, true);
	return new Int16Array(buffer)[0] === 256;
})();

// from http://stackoverflow.com/questions/728360/most-elegant-way-to-clone-a-javascript-object
function deepcopy(obj) {
    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj) return obj;

    // Handle Date
    if (obj instanceof Date) {
        var copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        var copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = deepcopy(obj[i]);
        }
        return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        var copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = deepcopy(obj[attr]);
        }
        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
}

PXF.IsIOSContext = function()
{
	return navigator.userAgent.match(/ios/g);
};

PXF.IsAndroidContext = function()
{
	return navigator.userAgent.match(/android/g);
}

/**
 * Enable WebGL Extensions supported by client browser.
 * @function
 * @param {WebGLContext} _gl WebGL context.
 */

/* 
 * DEPRECATED - moved to Instance class
PXF.EnableExtensions = function(_gl) {
	var extPrefix = ["WEBKIT_","MOZ_","ANGLE_"];
	var extList	  = _gl.getSupportedExtensions(); 
	// console.log(extList);

	// load extension objects
	PXF.Extensions = {};

	for ( var e in extList ) {
		(function() {
			var ext = extList[e];
			var n = ext;

			for ( var p in extPrefix ) if ( ext.search(extPrefix[p]) >= 0 ) {
				n = ext.replace(extPrefix[p],""); break;
			}					

			console.log("[/core/Utils.js:111] enabled extensions: " + ext);
			PXF.Extensions[n] = _gl.getExtension(ext);
		})();
	}
	WEBGL_debug_shaders = _gl.getExtension( "WEBGL_debug_shaders" );
}
*/

/**
 * Check if browser supports DXT Extensions.
 * @function
 */
PXF.CheckDXTSupport = function() {
	return (!!PXF.Extensions && "WEBGL_compressed_texture_s3tc" in PXF.Extensions) ? PXF.Extensions["WEBGL_compressed_texture_s3tc"] : null;
}

/**
 * Load and create new HTML Image object.
 * @function
 * @param {string} path URL Path to Image file.
 * @param {function} onload On finished load callback for when image has finished loading.
 * @param {function} [onerror=undefined] On error callback if an error occurrs while loading the image.
 */
// TODO: Add different load methods
PXF.LoadImage = function (path, onload, onerror) {
	var img = new Image();
	img.onload = onload;
	if (onerror)
		img.onerror = onerror;
	else
		img.onerror = function (e) { console.error("[/core/Utils.js:141] Could not load image '" + path + "'."); };
	img.src = path;
}


/**
 * Load remote JSON file.
 * @function
 * @param {string} path Path to JSON file.
 * @param {function} [callback=undefined] If set will use asynchronous download and use callback function when completed.
 * @returns {JSONTree} On success returns a JSON tree, on failure returns false.
 */
PXF.LoadJson = function ( path, callback  ) {
	
	var jsontree = {};
	var req = new XMLHttpRequest();
	if (typeof(callback) == "function")
	{
		req.open("GET", path, true);
		req.onreadystatechange = function () {
			if (req.readyState == 4) {
				if ((req.status == 200 || req.status == 0 ) && req.responseText)
				{
					jsontree = JSON.parse(req.responseText);
					callback(jsontree);
				} else {
					callback(undefined);
				}
			}
		};
		req.send(null);
		
		return true;
		
	} else {
		
		req.open("GET", path, false);
		req.send(null);
		
		if ((req.status == 200 || req.status == 0 ) && req.responseText)
		{
			jsontree = JSON.parse(req.responseText);
			return jsontree;
		} else {
			console.log("Error while downloading file. Response: " + req.responseText);
		}
		
		return false;
	}
	
	
	return false;
};

/**
 * Load remote binary buffer.
 * @function
 * @param {string} path Path to JSON file.
 * @param {function} [callback=undefined] If set will use asynchronous download and use callback function when completed. (DEPRECATED - won't work)
 * @param {JSON} args Args that will be sent to callback function.
 * @returns {JSONTree} On success returns a JSON tree, on failure returns false.
 */
PXF.LoadBuffer = function ( path, callback, args ) {
	var req = new XMLHttpRequest();

	if (typeof(callback) == "function")
	{
		req.open("GET", path, true);
		req.onreadystatechange = function () {
			if (req.readyState == 4) {
				if ((req.status == 200 || req.status == 0 ) && req.response)
				{
					callback( req.response, args );
				} else {
					callback(false);
				}
			}
		};		

		req.responseType = "arraybuffer";
		req.send(null);
		
		return true;
		
	} else {
		
		req.open("GET", path, false);
		req.responseType = "arraybuffer";
		req.send(null);

		if ((req.status == 200 || req.status == 0 ) && req.response)
		{
			return req.response;
		} else {
			console.log("Error while downloading file. Response: " + req.responseText);
		}
		
		return false;
	}
	
	
	return false;
}

/**
 * Load raw remote file.
 * @function
 * @param {string} path Path to file.
 * @param {function} [callback=undefined] If set will use asynchronous download and use callback function when completed.
 * @returns {JSONTree} On success returns the content of the file as a string, on failure returns false.
 */
PXF.LoadRawFile = function ( path, callback ) {
	var req = new XMLHttpRequest();
	if (typeof(callback) == "function")
	{
		req.open("GET", path, true);
		req.onreadystatechange = function () {
			if (req.readyState == 4) {
				if ((req.status == 200 || req.status == 0 ) && req.responseText)
				{
					callback(req.responseText);
				} else {
					callback(false);
				}
			}
		};
		req.send(null);
		
		return true;
		
	} else {
		
		req.open("GET", path, false);
		req.send(null);
		
		if ((req.status == 200 || req.status == 0 ) && req.responseText)
		{
			return req.responseText;
		} else {
			console.log("Error while downloading file '" + path + "'. Response: " + req.responseText);
		}
		
		return false;
	}
	
	
	return false;
}

/**
 * Load ctm file.
 * @function
 * @param {string} path Path to file.
 * @param {function} [callback=undefined] If set will use asynchronous download and use callback function when completed.
 * @returns {boolean} TODO: Truly understand (and state) the returns of this function, now it's true / false on callback==function / callback!=function.
 */
PXF.LoadCTMFile = function ( path, callback ) {
    var req = new XMLHttpRequest();
    if (typeof(callback) == "function")
    {
        req.open("GET", path, true);
        req.overrideMimeType("text/plain; charset=x-user-defined");
        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if ((req.status == 200 || req.status == 0 ) && req.responseText)
                {
                    callback(req.responseText);
                } else {
                    callback(false);
                }
            }
        };
        req.setRequestHeader( "Content-Type", "text/plain" );
        req.send(null);
        
        return true;
        
    } else {
        
        req.open("GET", path, false);
        req.overrideMimeType("text/plain; charset=x-user-defined");
        req.setRequestHeader( "Content-Type", "text/plain" );
        req.send(null);
        
        if ((req.status == 200 || req.status == 0 ) && req.responseText)
        {
            return req.responseText;
        } else {
            console.log("Error while downloading file '" + path + "'. Response: " + req.responseText);
        }
        
        return false;
    }
    
    
    return false;
}

// http://www.inventpartners.com/content/javascript_is_int
/**
 * Checks to see if argument is int
 * @function
 */
function isInt(value){ 
  return (parseFloat(value) == parseInt(value)) && !isNaN(value);
}

/**
 * Get path for a given URL.
 * @function
 * @param {string} url Path to parse.
 * @returns {string} Base
 */
function urlBase( url ) {
	// same as how three.js does it
	var chunks = url.split( "/" );
	chunks.pop();
	return chunks.join( "/" ) + "/";
}

/**
 * Get extension from given URL. 
 * @function
 * @param {string} url Path to parse.
 * @returns {string} Extension
 */
function getExtension( url ) {
	if(!url) return;

	var chunks = url.split( "." );
	return chunks[chunks.length-1];
}

/**
 * Get length of a dictionary.
 * @function
 * @param {object} Dictionary.
 * @returns {number} Length of dictionary.
 */
function dictLength( d ) {
	var l = 0;
	for(var o in d) {
		l++;
	}

	return l;
}

/**
 * Merge (serialize/de-serialize) one object into another.
 * @function
 * @param {Object} obj1 Merge destination
 * @param {Object} obj2 Merge source
 */
var extend = function (obj1, obj2) {
    for (var i in obj2) {
        if (!obj2.hasOwnProperty(i)) continue;
        obj1[i] = obj2[i];
    }

    return obj1;
};

/**
 * Set position coordinates in matrix based from vec3.
 * @function
 * @param {mat4} mtx Set this matrix.
 * @param {vec3} position Use this position vector.
 */
var setMatrixPosition = function( mtx, position ) {
	if(!mtx || !position) return;

	mtx[12] = position[0];
	mtx[13] = position[1];
	mtx[14] = position[2];
}

/**
 * Get position coordinates in matrix.
 * @function
 * @param {mat4} mtx Get position from this matrix.
 */
var getPositionFromMatrix = function( mtx ) {
	if(!mtx || mtx.length != 16) return;
	return vec3.create([mtx[12],mtx[13],mtx[14]]);
}

/**
 * Get scale coordinates in transformation matrix.
 * @function
 * @param {mat4} mtx Get scale from this matrix.
 */
var getScaleFromMatrix = function( mtx )
{
	if (!mtx) return;

	if ( mtx.length == 16 )
	{
		var scaleX = vec3.length( [ mtx[0], mtx[4], mtx[ 8] ] );
		var scaleY = vec3.length( [ mtx[1], mtx[5], mtx[ 9] ] );
		var scaleZ = vec3.length( [ mtx[2], mtx[6], mtx[10] ] );

		return vec3.create( [scaleX,scaleY,scaleZ] );
	};

	if ( mtx.length == 9 )
	{
		var scaleX = vec3.length( [ mtx[0], mtx[3], mtx[7] ] );
		var scaleY = vec3.length( [ mtx[1], mtx[4], mtx[8] ] );
		var scaleZ = vec3.length( [ mtx[2], mtx[5], mtx[9] ] );

		return vec3.create( [scaleX,scaleY,scaleZ] );
	};
}


/**
 * Wraps a function around a profiling function. Will leave profiling data in _prof
 * property on resulting function.
 * @param {function} fun Function to be wrapped.
 * @param {function} [proxy=undefined] Optional function that should be run after profiling is done.
 * @returns {function} Returns the wrapped function.
 */
var profileFunction = function (fun, proxy) {
	var pfun = function () {
		pfun._prof.timer.start();
		fun.apply(this, arguments);
		pfun._prof.timer.stop();
		if (proxy)
			proxy(pfun, fun);
	};
	pfun._prof = {"timer" : new Timer()};
	return pfun;
};


/**
 *  Browser Detection
 *  From: http://www.quirksmode.org/js/detect.html
 */
var BrowserDetect = {
	init: function () {
		this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
		this.version = this.searchVersion(navigator.userAgent)
			|| this.searchVersion(navigator.appVersion)
			|| "an unknown version";
		this.OS = this.searchString(this.dataOS) || "an unknown OS";
	},
	searchString: function (data) {
		for (var i=0;i<data.length;i++)	{
			var dataString = data[i].string;
			var dataProp = data[i].prop;
			this.versionSearchString = data[i].versionSearch || data[i].identity;
			if (dataString) {
				if (dataString.indexOf(data[i].subString) != -1)
					return data[i].identity;
			}
			else if (dataProp)
				return data[i].identity;
		}
	},
	searchVersion: function (dataString) {
		var index = dataString.indexOf(this.versionSearchString);
		if (index == -1) return;
		return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
	},
	dataBrowser: [
		{
			string: navigator.userAgent,
			subString: "Chrome",
			identity: "Chrome"
		},
		{ 	string: navigator.userAgent,
			subString: "OmniWeb",
			versionSearch: "OmniWeb/",
			identity: "OmniWeb"
		},
		{
			string: navigator.vendor,
			subString: "Apple",
			identity: "Safari",
			versionSearch: "Version"
		},
		{
			prop: window.opera,
			identity: "Opera",
			versionSearch: "Version"
		},
		{
			string: navigator.vendor,
			subString: "iCab",
			identity: "iCab"
		},
		{
			string: navigator.vendor,
			subString: "KDE",
			identity: "Konqueror"
		},
		{
			string: navigator.userAgent,
			subString: "Firefox",
			identity: "Firefox"
		},
		{
			string: navigator.vendor,
			subString: "Camino",
			identity: "Camino"
		},
		{		// for newer Netscapes (6+)
			string: navigator.userAgent,
			subString: "Netscape",
			identity: "Netscape"
		},
		{
			string: navigator.userAgent,
			subString: "MSIE",
			identity: "Explorer",
			versionSearch: "MSIE"
		},
		{
			string: navigator.userAgent,
			subString: "Gecko",
			identity: "Mozilla",
			versionSearch: "rv"
		},
		{ 		// for older Netscapes (4-)
			string: navigator.userAgent,
			subString: "Mozilla",
			identity: "Netscape",
			versionSearch: "Mozilla"
		}
	],
	dataOS : [
		{
			string: navigator.platform,
			subString: "Win",
			identity: "Windows"
		},
		{
			string: navigator.platform,
			subString: "Mac",
			identity: "Mac"
		},
		{
			   string: navigator.userAgent,
			   subString: "iPhone",
			   identity: "iPhone/iPod"
	    },
		{
			string: navigator.platform,
			subString: "Linux",
			identity: "Linux"
		}
	]

};
BrowserDetect.init();


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/Geometry.js: */

// DEPENDENCIES: /pxf.js, /core/Utils.js
/**
 * Constructor for the Texture class.
 * @constructor
 * @param {WebGLContext} gl WebGL context.
 * @param {JSON} [json=undefined] Json table that describes the geometry.
 * 
 * @class Geometry class.
 * @property {GL_UINT} [primitiveType=gl.TRIANGLES] OpenGL primitive type enum.
 * @property {JSON} glBuffers OpenGL buffer handles.
 * @property {JSON} staticBuffers Static data buffer storage, essentially a copy of the geometry data.
 * @property {JSON} buffers Buffer object that stores the different buffers and their draw properties, such as size,type and buffer data.
 * @property {string} faceBuffer A string identifier that tells the geometry class where to find face indices.
 */
PXF.Geometry = function(ctx, json)
{
	if ( !ctx ) return;
	// load external geometry
	if ( typeof(json) == "string" ) {
		json = PXF.LoadJson( json );
	}

	this.__renderIndex 	= 0;

	this.ctx 			= ctx;
	this.gl 			= ctx.gl;

	this.primitiveType  =  4; // 4 = GL.TRIANGLES
	this.glBuffers      = {};
	this.staticBuffers  = {};
	this.buffers        = {};

	this.faceBuffer     = "";
	this.needsToRebuild = true;
	this.drawLength     = undefined;

	// geometryinfo
	this.triangleCount 	= 0;

	extend(this, json || {} );

	this.ctx.AllGeometry.push(this);

	this.BuildBuffers();
}

PXF.Geometry.prototype.constructor 	= PXF.Geometry;
PXF.Geometry.prototype.BuildSpecificBuffer = function( buffer_name ) {

	// create webgl buffers
	var minBufLen 	= this.drawLength || Number.MAX_VALUE;
	var gl 			= this.gl;
	var minBufCalc 	= false;
	var usage;

	// for (var b in this.buffers)
	var b = buffer_name;
	{
		// if(this.glBuffers[b] && !force) continue;

		if(!this.glBuffers[b])
		{
			this.glBuffers[b] = gl.createBuffer();
		}

		if (!("format" in this.buffers[b]))
		{
			this.buffers[b].format = gl.FLOAT;
		} else {

			if (this.buffers[b].format == "int")
			{
				this.buffers[b].format = gl.INT;
			} else {
				this.buffers[b].format = gl.FLOAT;
			}
		}

		if (this.buffers[b].usage != undefined)
			usage = this.buffers[b].usage;
		else
			usage = gl.STATIC_DRAW;

		if (this.buffers[b].elements)
		{

			this.staticBuffers[b] = new Uint16Array(this.buffers[b].data);
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.glBuffers[b] );
			this.useFaceBuffer  = true;
			this.faceBufferName = b;
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, this.staticBuffers[b], usage );

		} else {

			if (this.buffers[b].format == gl.INT)
				this.staticBuffers[b] = new Uint16Array(this.buffers[b].data);
			else
				this.staticBuffers[b] = new Float32Array(this.buffers[b].data);

			gl.bindBuffer( gl.ARRAY_BUFFER, this.glBuffers[b] );

			// see if this is the shortest data array
			if (minBufLen > this.buffers[b].data.length / this.buffers[b].size)
			{
				minBufLen 	= this.buffers[b].data.length / this.buffers[b].size;
				minBufCalc 	= true;
			}

			gl.bufferData( gl.ARRAY_BUFFER, this.staticBuffers[b], usage );
		}
	}

	this.drawLength = minBufLen;

	if (this.useFaceBuffer)
	{
		this.drawLength = this.buffers[this.faceBufferName].data.length; // TODO This only works for triangles atm...
	}

	if ( this.offsets === undefined && minBufCalc )
	{
		var tthis 		= this;
		this.offsets 	= [{ start:0,index:0,count:tthis.drawLength}];
	}

	var error = gl.getError();

	if (error > 0) {
		console.error("[/scene/Geometry.js:129] Error when building geometry: " + error);
	}

	this.needsToRebuild = false;

};

PXF.Geometry.prototype.BuildSubBuffers = function( buffers, offset ) {
	var minBufLen 	= this.drawLength || Number.MAX_VALUE;
	var minBufCalc 	= false;

	// this.usage = gl.DYNAMIC_DRAW;
	var gl = this.gl;
	this.usage = gl.STATIC_DRAW;

	for( var b in buffers )
	{
		if ( !this.buffers[b] ) this.buffers[b] = extend({},buffers);

		if ( !this.glBuffers[b] ) {

			this.glBuffers[b] = gl.createBuffer();
			gl.bindBuffer( gl.ARRAY_BUFFER, this.glBuffers[b] );
			gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( buffers[b].datasize ), this.usage );
		}

		if (!("format" in this.buffers[b]))	this.buffers[b].format = gl.FLOAT;
		else {
			if (this.buffers[b].format == "int")
					this.buffers[b].format = gl.INT;
			else 	this.buffers[b].format = gl.FLOAT;
		};

		if (this.buffers[b].elements) console.error("Geometry.BuildSubBuffers not implemented for geometry type 'elements'");
		else {
			var typefun = Float32Array;

			if (this.buffers[b].format == gl.INT) 
				typefun = Uint16Array;

			gl.bindBuffer( gl.ARRAY_BUFFER, this.glBuffers[b] );

			// console.log("building",minBufLen,(buffers[b].datasize / buffers[b].size),buffers[b].datasize,buffers[b].size);

			// see if this is the shortest data array
			if ( minBufLen > (buffers[b].datasize / buffers[b].size) )
			{
				minBufLen = buffers[b].datasize / buffers[b].size;
				minBufCalc = true;
			}

			gl.bufferSubData( gl.ARRAY_BUFFER, offset, buffers[b].data );
		}
	}

	this.drawLength = minBufLen;

	if ( this.offsets === undefined && minBufCalc )
	{
		var tthis 		= this;
		this.offsets 	= [{ start:0,index:0,count:tthis.drawLength}];
	}

	var error = gl.getError();

	if (error > 0) {
		console.error("[/scene/Geometry.js:195] Error when building geometry.subbuffers: " + error);
	}

	this.needsToRebuild = false;
	this.triangleCount 	= this.drawLength / 3; // this is not really the correct assumption, but meh
}


////////////////////////////////////////////////////////////
// iterate triangles and create new attribute buffer
PXF.Geometry.prototype.BuildWireframeBuffer = function(buf_size) {

	console.log(buf_size);
	// if (this.buffers.position == undefined || this.buffers.position.data == undefined)
		// return;

	// attribute buffer
	this.buffers.wireframe = {
		size : 3,
		format : "float"
	}



	if ( this.buffers.faces ) {
		// TODO: convert buffers to non-element geometry
		console.log("geometry has elements, dunno wat to do.. ");
	} else {
		// var posbuf = this.buffers.position;
		// var numtris = posbuf.data.length / 9;
		var numtris = buf_size / 9;
		this.buffers.wireframe.data = new Float32Array( buf_size );

		console.log("Building wireframe buffer of size: ", numtris);
		for( var v = 0; v < numtris; v++ ) {
			// var v0 = [1,0,0];
			// var v1 = [0,1,0];
			// var v2 = [0,0,1];
			this.buffers.wireframe.data[v*9]   = 1;
			this.buffers.wireframe.data[v*9+1] = 0;
			this.buffers.wireframe.data[v*9+2] = 0;

			this.buffers.wireframe.data[v*9+3] = 0;
			this.buffers.wireframe.data[v*9+4] = 1;
			this.buffers.wireframe.data[v*9+5] = 0;

			this.buffers.wireframe.data[v*9+6] = 0;
			this.buffers.wireframe.data[v*9+7] = 0;
			this.buffers.wireframe.data[v*9+8] = 1;

			// this.buffers.wireframe.data = this.buffers.wireframe.data.concat(v0,v1,v2);
		}
	}

	this.BuildSpecificBuffer("wireframe");

}


/**
 * Iterates all buffers and checks if they need to be built.
 * @param {boolean} [force=false] Force a rebuild, even if the buffer has associated OpenGL handles.
 */

// force : force buffer update
PXF.Geometry.prototype.BuildBuffers = function( force ) {

	// create webgl buffers
	var minBufLen 	= this.drawLength || Number.MAX_VALUE;
	if (force)
		minBufLen = Number.MAX_VALUE;

	var gl 			= this.gl;
	var minBufCalc 	= false;
	var usage;

	for (var b in this.buffers)
	{
		if(this.glBuffers[b] && !force) continue;

		if(!this.glBuffers[b])
		{
			this.glBuffers[b] = gl.createBuffer();
		}

		if (!("format" in this.buffers[b]))
		{
			this.buffers[b].format = gl.FLOAT;
		} else {

			if (this.buffers[b].format == "int")
			{
				this.buffers[b].format = gl.INT;
			} else {
				this.buffers[b].format = gl.FLOAT;
			}
		}

		if (this.buffers[b].usage != undefined)
			usage = this.buffers[b].usage;
		else
			usage = gl.STATIC_DRAW;

		if (this.buffers[b].elements)
		{

			this.staticBuffers[b] = new Uint16Array(this.buffers[b].data);
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.glBuffers[b] );
			this.useFaceBuffer  = true;
			this.faceBufferName = b;
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, this.staticBuffers[b], usage );

		} else {

			if (this.buffers[b].format == gl.INT)
				this.staticBuffers[b] = new Uint16Array(this.buffers[b].data);
			else
				this.staticBuffers[b] = new Float32Array(this.buffers[b].data);

			gl.bindBuffer( gl.ARRAY_BUFFER, this.glBuffers[b] );

			// see if this is the shortest data array
			if (minBufLen > this.buffers[b].data.length / this.buffers[b].size)
			{
				minBufLen 	= this.buffers[b].data.length / this.buffers[b].size;
				minBufCalc 	= true;
			}

			gl.bufferData( gl.ARRAY_BUFFER, this.staticBuffers[b], usage );
		}
	}

	this.drawLength = minBufLen;

	if (this.useFaceBuffer)
	{
		this.drawLength = this.buffers[this.faceBufferName].data.length; // TODO This only works for triangles atm...
	}

	// if ( this.offsets === undefined && minBufCalc )
	if ( minBufCalc )
	{
		var tthis 		= this;
		this.offsets 	= [{ start:0,index:0,count:tthis.drawLength}];
	}

	var error = gl.getError();

	if (error > 0) {
		console.error("[/scene/Geometry.js:344] Error when building geometry: " + error);
	}

	this.needsToRebuild = false;
	this.triangleCount 	= this.drawLength / 3; // this is not really the correct assumption, but meh
}

/**
 * Generate vertex normals 
 */
PXF.Geometry.prototype.GenerateNormals = function() {
	// normal(A,B,C) = AxB + BxC + CxA

	this.buffers["normal"] = {
		data : [],
		size : 3,
		type : "float"
	}

	var faceCount = this.buffers["position"].data.length / 3.0 / 3.0;
	var pos = this.buffers["position"].data;
	var norm = this.buffers["normal"].data;
	var v_i = 0;
	var A, B, C, N;
	var t1 = vec3.create();
	var t2 = vec3.create();
	var t3 = vec3.create();

	for (var fi = 0; fi < faceCount; fi += 1 )
	{
		
		A = vec3.create([pos[v_i  ], pos[v_i+1], pos[v_i+2]]);
		B = vec3.create([pos[v_i+3], pos[v_i+4], pos[v_i+5]]);
		C = vec3.create([pos[v_i+6], pos[v_i+7], pos[v_i+8]]);

		vec3.cross(A, B, t1);
		vec3.cross(B, C, t2);
		vec3.cross(C, A, t3);

		vec3.add(t1, t2, t1);
		vec3.add(t1, t3, t1);

		N = vec3.create(t1);
		vec3.normalize(N);


		norm[v_i  ] = N[0];
		norm[v_i+1] = N[1];
		norm[v_i+2] = N[2];

		norm[v_i+3] = N[0];
		norm[v_i+4] = N[1];
		norm[v_i+5] = N[2];

		norm[v_i+6] = N[0];
		norm[v_i+7] = N[1];
		norm[v_i+8] = N[2];

		v_i += 3 * 3;
	}

	this.BuildBuffers( true );
}

/**
 * Automatic geometry unwrap.
 * @param {string} method Unrwap method identified, currently only "grid" is implemented.
 * @param {number} border UV Border.
 * @param {string} bufferName Name for this buffer.
 */
PXF.Geometry.prototype.UVUnwrap = function(method, border, buffername) {

	if (border == undefined)
		border = 0.0;
	
	// Simple grid layout
	if (method == undefined || method == "grid")
	{

		var faceCount = this.buffers["position"].data.length / 3.0 / 3.0;
		var cellCount = Math.ceil(faceCount / 2.0);
		var gridCount = Math.ceil(Math.sqrt(cellCount));
		var triangleGridCount = gridCount * 2;

		//console.log("faceCount", faceCount, "cellCount", cellCount, "gridCount", gridCount);

		// triangle size/step in UV space
		var uvdelta = 1.0 / gridCount;

		// two trianles
		var invborder = 1.0 - border;
		var invborder2 = 1.0 - border * 2.0;
		/*var ab = [ [[border, uvdelta - border], [border,            border * 2.0], [uvdelta - border*2.0, uvdelta - border]] ,

				   [[border,            border], [uvdelta*invborder, border], [uvdelta*invborder, uvdelta*invborder]] ];
		var ab = [ [[border, uvdelta*invborder + border], [border,            border], [uvdelta*invborder + border, uvdelta*invborder + border]] ,
		           [[border,            border], [uvdelta*invborder, border], [uvdelta*invborder, uvdelta*invborder]] ];
		*/
		
		/*var ab = [ [[ 0.0, uvdelta], [    0.0,     0.0], [ uvdelta, uvdelta]] ,
		           [[ 0.0,     0.0], [uvdelta,     0.0], [ uvdelta, uvdelta]] ];*/

		/*var ab = [ [[ border, uvdelta - border], [ border, border*2], [ uvdelta - border*2, uvdelta - border]] ,
		           [[ border*2, border], [uvdelta - border, border], [ uvdelta - border, uvdelta - border*2]] ];*/

		var ab = [ [[ border, border*2], [ uvdelta - border*2, uvdelta - border], [ border, uvdelta - border]] ,
		           [[ uvdelta - border, uvdelta - border*2], [ border*2, border], [uvdelta - border, border]] ];

		var t_i = 0; // triangle counter
		var uvs = this.buffers[buffername].data;
		var uv_i = 0;
		for (var vi = 0; vi < faceCount; vi += 1 )
		{
			var cur_triangle = ab[t_i % 2];

			// v0
			uvs[uv_i  ] = cur_triangle[0][0] + Math.floor((t_i % triangleGridCount) / 2) * uvdelta;
			uvs[uv_i+1] = cur_triangle[0][1] + Math.floor(t_i / triangleGridCount) * uvdelta;

			// v1
			uvs[uv_i+2] = cur_triangle[1][0] + Math.floor((t_i % triangleGridCount) / 2) * uvdelta;
			uvs[uv_i+3] = cur_triangle[1][1] + Math.floor(t_i / triangleGridCount) * uvdelta;

			// v2
			uvs[uv_i+4] = cur_triangle[2][0] + Math.floor((t_i % triangleGridCount) / 2) * uvdelta;
			uvs[uv_i+5] = cur_triangle[2][1] + Math.floor(t_i / triangleGridCount) * uvdelta;

			t_i  += 1;
			uv_i += 2 * 3;
		}

		this.buffers[buffername].data = uvs;

		this.BuildBuffers(true);

		return true;

	} else {

		console.log("[/scene/Geometry.js:483] Unkown unwrapping method.");
		return false;

	}

	return false;
};

/**
 * Converts a geometry specified with face elements to un-indexed raw position buffers.
 * @param {boolean} clear Removes old buffers.
 */
PXF.Geometry.prototype.BuildFromFaces = function(clear)
{
	if (!this.useFaceBuffer || this.faceBufferName == "")
	{
		return;
	}

	var new_buffers = {};
	for (var k in this.buffers)
	{
		if (!this.buffers[k].elements)
		{
			new_buffers[k] = [];
		}
	}

	// loop through all elements
	for (var f in this.buffers[this.faceBufferName].data)
	{
		var i = this.buffers[this.faceBufferName].data[f];

		for (var k in new_buffers)
		{
			
			// get start index
			var indx = i * this.buffers[k].size;

			for (var subi = 0; subi < this.buffers[k].size; subi += 1)
			{
				var ni = indx + subi;

				// store old value
				new_buffers[k].push( this.buffers[k].data[ni] );
			}
		}
	}

	if (clear)
	{
		delete this.buffers[ this.faceBufferName ];

		this.gl.deleteBuffer(this.glBuffers[ this.faceBufferName ]);
		delete this.glBuffers[ this.faceBufferName ];

		this.useFaceBuffer = false;
		this.faceBufferName = "";
	}

	for (var k in new_buffers)
	{
		this.buffers[k].data = new_buffers[k];
	}

	this.BuildBuffers(true);


}

PXF.Geometry.prototype.Begin = function( idx )
{
	this.__renderIndex = -1;

	// force index
	if ( idx !== undefined ) {
		if ( typeof(idx) == "string" ) {
			var foundM = false;
			for( o in this.offsets )
			{
				if ( this.offsets[o].tag == idx )
				{
					this.__renderIndex 	= Number(o);
					foundM 				= true;
					break;
				};
			};

			if (!foundM) return false;

		} else if ( this.offsets[idx] !== undefined )
			this.__renderIndex = Math.max( idx, this.__renderIndex );
		else return false;
	};

	var tthis 	= this;
	var iter 	= { 
		geo  : tthis,
		next : function() {
			var geo = this.geo;

			if ( geo.offsets && geo.__renderIndex < ( geo.offsets.length-1) ) 
			{
				geo.__renderIndex++;
				return true;
			};

			geo.__renderIndex = 0; 
			return false;
		}
	}

	return iter;
}

/**
 * Binds the geometry buffer handles to vertex attrib pointers in the shader.
 * @param {PXF.Shader} shader Binds the buffer to this shaders vertex attributes.
 * @param {JSON} bindBuffers Table that contains buffer names and a boolean that tells this function wether or not those buffers should be bound. 
 * E.g: var bindBuffers = { position : true, uv0 : false, normals : true } will bind those buffers if they are found.
 */
PXF.Geometry.prototype.BindBuffers = function(shader, bindBuffers)
{
	var gl 		= this.gl;
	var offset  = this.offsets !== undefined ? this.offsets[this.__renderIndex] : undefined ;

	for (var b in this.buffers)
	{
		if ( this.glBuffers[b] === undefined )
			 this.glBuffers[b] = gl.createBuffer();

		// override binds
		var obind = true;
		if (bindBuffers && b in bindBuffers)
		{
			obind = bindBuffers[b];
		}

		if (!this.buffers[b].elements && obind && offset !== undefined )
		{
			var attributeSize 	= this.buffers[b].size;
			var startIndex 		= offset.index;

			var attrloc = shader.GetAttribLocation( b );
      		if ( attrloc < 0 ) continue;

			gl.enableVertexAttribArray( attrloc );
			gl.bindBuffer( gl.ARRAY_BUFFER, this.glBuffers[b] );
			// shader.VertexAttrib("p", b, this.buffers[b].size, this.buffers[b].format, false, 0, 0 );
			shader.VertexAttrib("p", b, attributeSize, this.buffers[b].format, false, 0, startIndex * attributeSize * 4 );
		}
	};

	if (this.useFaceBuffer)
	{
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.glBuffers[this.faceBufferName] );
	}
}

/**
 * Same as BindBuffers, but unbinds them from the shader.
 */
PXF.Geometry.prototype.UnbindBuffers = function(shader,bindBuffers) {
	var gl = this.gl;

	for (var b in this.buffers)
	{
		// override binds
		var obind = true;
		if (bindBuffers && b in bindBuffers)
		{
			obind = bindBuffers[b];
		}

		if (!this.buffers[b].elements && obind )
		{
			var attrloc = shader.GetAttribLocation( b );
			if ( attrloc < 0 ) continue;

			gl.disableVertexAttribArray( attrloc );
		}
	};
}

/**
 * Issues the draw call for this geometry object.
 */
PXF.Geometry.prototype.DrawBuffers = function()
{
	var drawIndexedLength = this.offsets !== undefined ? this.offsets[this.__renderIndex].count : undefined;
	var drawIndexedOffset = this.offsets !== undefined ? this.offsets[this.__renderIndex].start : undefined;
	var drawType 		  = PXF.DRAW_NONE;

	if ( drawIndexedOffset !== undefined ) 
		if ( this.useFaceBuffer )
		{
			this.gl.drawElements(this.primitiveType, drawIndexedLength, this.gl.UNSIGNED_SHORT, drawIndexedOffset * 2 );
			drawType = PXF.DRAW_ELEMENTS;
		} else {
			this.gl.drawArrays(this.primitiveType, 0, drawIndexedLength);
			drawType = PXF.DRAW_ARRAYS;
		}

	this.ctx.UpdateFrameInfo( { type : drawType, drawLength : drawIndexedLength, primitiveType : this.primitiveType } );
}

/**
 * Render a subpart of the geometry
 * NOTE: does not work for geometry with element buffers
 */
PXF.Geometry.prototype.SubDraw = function( shader, part, parts, bindBuffers ) {

	var gl 		= this.gl;
	var offset  = this.offsets !== undefined ? this.offsets[this.__renderIndex] : undefined ;

	////////////////
	// draw section
	var drawIndexedLength = this.offsets !== undefined ? this.offsets[this.__renderIndex].count : undefined;
	var drawIndexedOffset = this.offsets !== undefined ? this.offsets[this.__renderIndex].start : undefined;
	var drawType 		  = PXF.DRAW_NONE;

	if ( drawIndexedOffset !== undefined ) 
		if ( this.useFaceBuffer )
		{
			gl.drawElements(this.primitiveType, drawIndexedLength, gl.UNSIGNED_SHORT, drawIndexedOffset * 2 );
			drawType = PXF.DRAW_ELEMENTS;
		} else {

			// find out how many triangles to render for each part
			var length_per_part = Math.ceil(drawIndexedLength / 3 / parts);
			var tmp_start = length_per_part*part * 3;
			var tmp_count = length_per_part*3;

			if (tmp_start + tmp_count > drawIndexedLength) {
				console.log(tmp_start + tmp_count, drawIndexedLength, tmp_start, tmp_count)
			}


			// console.log(drawIndexedLength, length_per_part);

			// gl.drawArrays(this.primitiveType, 0, drawIndexedLength);
			gl.drawArrays(this.primitiveType, tmp_start, tmp_count );
			drawType = PXF.DRAW_ARRAYS;
		}

	this.ctx.UpdateFrameInfo( { type : drawType, drawLength : drawIndexedLength, primitiveType : this.primitiveType } );

};

/**
 * Clears the buffer data.
 */
PXF.Geometry.prototype.Reset = function()
{
	for (var b in this.buffers)
	{
		this.buffers[b].data = [];
	};
}

/**
 * Deletes/removes the OpenGL handles.
 */
PXF.Geometry.prototype.Destroy = function() 
{
	var gl = this.gl;
	this.Reset();

	for (var b in this.glBuffers) {
		gl.deleteBuffer(this.glBuffers[b]);
		delete this.glBuffers[b];
	}
}

/**
 * Calculates tangent space vectors and stores these in a new buffer.
 * @param {string} [bufferName=undefined] Optional ID for the generated buffer.
 */
PXF.Geometry.prototype.CalculateTangent = function( bufferName ) {
	if ( this.useFaceBuffer ) this.BuildFromFaces();
	if ( bufferName == undefined ) bufferName = "tangent";

	var vertices, normals, uv, 
		tan1, tan2,
		tangents,
		num_vertices, num_triangles,
		gl = this.gl;

	try {
		vertices = this.buffers["position"].data;
	} catch ( e ) {
		console.log("[/scene/Geometry.js:774] Unable to get position coordinates."); return;
	}

	try {
		normals = this.buffers["normal"].data;
	} catch ( e ) {
		console.log("[/scene/Geometry.js:780] Unable to get normal coordinates"); return;
	}

	try {
		uv 	= this.buffers["uv0"].data;
	} catch ( e ) {
		console.log("[/scene/Geometry.js:786] Unable to get UV coordinates"); return;
	}

	num_vertices 	= vertices.length / 3;
	num_triangles 	= num_vertices / 3;

	tangents 		= new Float32Array( num_vertices * 4 );
	tan1 			= [];
	tan2 			= [];

	var X=0,Y=1,Z=2;

	for( var t = 0; t < num_triangles; t++ ) {

		var i1 =  t * 9;
		var i2 = i1 + 3;
		var i3 = i2 + 3;

		var wi1 =  t * 6;
		var wi2 = wi1 + 2;
		var wi3 = wi2 + 2;

		var v1 = [ vertices[ i1 ], vertices[ i1 + 1 ], vertices[ i1 + 2 ] ];
		var v2 = [ vertices[ i2 ], vertices[ i2 + 1 ], vertices[ i2 + 2 ] ];
		var v3 = [ vertices[ i3 ], vertices[ i3 + 1 ], vertices[ i3 + 2 ] ];

		var w1 = [ uv[ wi1 ], uv[ wi1 + 1 ] ];
		var w2 = [ uv[ wi2 ], uv[ wi2 + 1 ] ];
		var w3 = [ uv[ wi3 ], uv[ wi3 + 1 ] ];

		var x1 = v2[X] - v1[X];
        var x2 = v3[X] - v1[X];
        var y1 = v2[Y] - v1[Y];
        var y2 = v3[Y] - v1[Y];
        var z1 = v2[Z] - v1[Z];
        var z2 = v3[Z] - v1[Z];
        
        var s1 = w2[X] - w1[X];
        var s2 = w3[X] - w1[X];
        var t1 = w2[Y] - w1[Y];
        var t2 = w3[Y] - w1[Y];
        
        var r = 1.0 / (s1 * t2 - s2 * t1);

        r = Math.abs(r) != Infinity ? r : 0;

        var sdir = [ (t2 * x1 - t1 * x2) * r, 
        			 (t2 * y1 - t1 * y2) * r,
        			 (t2 * z1 - t1 * z2) * r ];

        var tdir = [ (s1 * x2 - s2 * x1) * r, 
        			 (s1 * y2 - s2 * y1) * r,
                	 (s1 * z2 - s2 * z1) * r];

        tan1.push( sdir[X], sdir[Y], sdir[Z] );
        tan1.push( sdir[X], sdir[Y], sdir[Z] );
        tan1.push( sdir[X], sdir[Y], sdir[Z] );

        tan2.push( tdir[X], tdir[Y], tdir[Z] );
        tan2.push( tdir[X], tdir[Y], tdir[Z] );
        tan2.push( tdir[X], tdir[Y], tdir[Z] );
	}

	// console.log(tan1,tan2);

	for( var v = 0; v < num_vertices; v++ ) {	
		var ix =  v * 3;
		var iy = ix + 1;
		var iz = iy + 1;

		var n 	= [ normals[ ix ], normals[ iy ], normals[ iz ] ];
		var t 	= [    tan1[ ix ],    tan1[ iy ],    tan1[ iz ] ];
		var t2 	= [    tan2[ ix ],    tan2[ iy ],    tan2[ iz ] ];
		
        // Gram-Schmidt orthogonalize
        var a 			= vec3.dot( n,t ); 					// dot(n,t)
        var a_times_n 	= vec3.scale( n,a ); 				// n * dot(n,t)
        var t_sub_a 	= vec3.subtract( t, a_times_n );	// t - n * dot(n,t)
        var tang_xyz	= vec3.normalize( t_sub_a );		// (t - n * dot(n,t)).Normalize()

       	var b 			= vec3.cross(n,t);
       	var b_dot_t2	= vec3.dot( b, t2 );

        // Calculate handedness
       	var w 			= b_dot_t2 < 0 ? -1 : 1;

       	var tix 		=   v * 4;
       	var tiy 		= tix + 1;
       	var tiz 		= tiy + 1;
       	var tiw 		= tiz + 1;

       	tangents[ tix ] = tang_xyz[X];
       	tangents[ tiy ] = tang_xyz[Y];
       	tangents[ tiz ] = tang_xyz[Z];
       	tangents[ tiw ] = w;
	}

	this.buffers[bufferName] = { "size" : 4, "type" : "float", "data" : tangents, "bind": true };
	this.BuildBuffers(true);

	this.hasTangents = true;

	return this;
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/Animation.js: */

// DEPENDENCIES: /pxf.js

/*

 "ArmatureAction": {
            "Duration": 150.0, 
            "Bones": [
                "Bone.001", 
                "Bone.002"
            ], 
            "Skeleton": "Armature", 
            "Keyframes": [
                [
                    
                        {
                            "Position": [
                                0.0, 
                                0.0, 
                                0.0
                            ], 
                            "Frame": 2, 
                            "Rotation": [
                                0.7013645768165588, 
                                1.5573422036764458e-16, 
                                9.283697730179899e-24, 
                                0.7128027081489563
                            ]
                        }, 

*/

/**
 * DEPRECATED
 */
PXF.Animation = function(name, scene, data)
{
	this.name      = name;
	this.duration  = data.Duration;
	this.skeleton  = scene.skeletons[data.Skeleton];
	this.bones     = data.Bones;
	this.keyframes = data.Keyframes;

	this.keyframeMatrices = [];

	this.framerate        = data.Framerate || 24;
	this.animationFreq    = 1000.0 / this.framerate;
	this.animationMaxtime = this.animationFreq * this.duration;

	this.boneHash = {};
	for (b in this.bones) {
		this.boneHash[this.bones[b]] = b;
	};

	//this.matrices = [];
	this.matrices = new Float32Array(16 * this.skeleton.maxBones);
};

/*
PXF.Animation.prototype.BuildMatrices = function() {
	
	// keyframes are stored on a per bone basis
	for (var b_id in this.keyframes)
	{
		var bone_keyframes          = this.keyframes[b_id];
		var bone_keyframes_matrices = [];

		// loop through each keyframe for each bone
		for (var key_id in bone_keyframes)
		{
			// create a matrix for this keyframe
			var keyframe    = bone_keyframes[key_id];
			var bone_matrix = mat4.create();

			mat4.fromRotationTranslation( keyframe.Rotation, keyframe.Position, bone_matrix);

			bone_keyframes_matrices.append(bone_matrix);
		};

		this.keyframeMatrices.append(bone_keyframes_matrices);
	};

};
*/
/**
 * DEPRECATED
 */
PXF.Animation.prototype.GetKeyframePair = function(bone_id, frame) {
	var keyframes = this.keyframes[bone_id];
	var prev, next;
	var kf;

	if(frame >= keyframes[keyframes.length-1].Frame) {
		kf = keyframes[keyframes.length-1];
		return [kf,kf];
	} else if (frame < keyframes[0].Frame) {
		kf = keyframes[0];
		return [kf,kf];
	}
		
	// loop through keyframes for this bone
	for (var k = 1; k < keyframes.length; k++) {
		kf = keyframes[k];

		// exact keyframe match?
		if (kf.Frame == frame) {
			prev = kf
			next = kf

			return [prev, next];

		} else if (kf.Frame > frame) {
			var pIdx = k - 1 < 0 ? 0 : k - 1;
			var nIdx = k;

			var previousKF 	= keyframes[ pIdx ];
			var nextKF 		= keyframes[ nIdx ];

			return [previousKF, nextKF];
		}
	}

	return [keyframes[0],keyframes[0]];
}
/**
 * DEPRECATED
 */
PXF.Animation.prototype.GetBoneMatrices = function(time) {
	
	//this.skeleton
	var bones = this.skeleton.bones;

	var frame = Math.floor( time / this.animationFreq);

	for (var i=0; i < bones.length; i++) {
		var b      = bones[i];
		var mtx    = mat4.identity();
		var parent = b.Parent;

		var p      = vec3.create(b.Position);
		var r      = quat4.create(b.Rotation);

		
		if (b && this.boneHash[b.Name] != undefined) {
			var keyframes = this.GetKeyframePair(this.boneHash[b.Name], frame);

			if (keyframes) {

				var previousKF  = keyframes[0];
				var nextKF      = keyframes[1];

				var prevTime 	= previousKF.Frame * this.animationFreq;
				var nextTime 	= nextKF.Frame * this.animationFreq;
				var diffTime 	= nextTime - prevTime;

				var relTime 	= diffTime ? (time - prevTime) / diffTime : 0;
				var relPos      = vec3.create();
				var relRot      = quat4.create();

				quat4.slerp( previousKF.Rotation, nextKF.Rotation, relTime, relRot);
				vec3.lerp( previousKF.Position, nextKF.Position, relTime, relPos);

				quat4.multiply(r, relRot, r);

				vec3.add(relPos, p, p);
				//if (frame == 0)	console.log(time, frame, previousKF.Frame, nextKF.Frame, relTime, relRot);
			}
		}


		b.WorldPosition = p;
		b.WorldRotation = r;

		if (parent != undefined) {
			var parent = bones[parent];

			quat4.multiplyVec3(parent.WorldRotation, b.WorldPosition, b.WorldPositions);
			vec3.add(parent.WorldPosition, b.WorldPosition, b.WorldPosition);
			quat4.multiply(parent.WorldRotation, b.WorldRotation, b.WorldRotation);
		}

		var inv_pose_mtx = this.skeleton.bindInvPoseArray.subarray(16 * i, 16 * i + 16);
		mat4.fromRotationTranslation(b.WorldRotation, b.WorldPosition, mtx);
		mat4.multiply(mtx, inv_pose_mtx, mtx);

		//console.log(b.Name,b.WorldPosition);

		/*var inv_pose_mtx = this.skeleton.bindInvPoseArray.subarray(16 * i, 16 * i + 16);

		//this.boneMtxArray_wut.set(mtx, i*16);

		mat4.multiply(inv_pose_mtx, mtx, mtx);

		if (parent != undefined) {
			var pMtx = this.matrices.subarray(16 * parent, 16 * parent + 16);
			var inv_pose_pmtx = this.skeleton.bindInvPoseArray.subarray(16 * parent, 16 * parent + 16);
			mat4.multiply(inv_pose_pmtx, pMtx, pMtx);
			//console.log(parent,pMtx);

			mat4.multiply(pMtx, mtx, mtx);
		}*/

		

		//console.log(b.Name,mtx);

		this.matrices.set(mtx, i * 16);
	}

	return this.matrices;
};


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/resource/Texture.js: */

// DEPENDENCIES: /pxf.js
/**
 * Constructor for the Texture class.
 * @constructor
 * @param {WebGLContext} gl WebGL context.
 * @param {string} [url=undefined] Create texture from this image url. 
 * @param {JSON} [settings=undefined] Texture settings, such as filter modes, data types etc.
 * @param {function} [onComplete=undefined] Function that will be called when the texture creation process is complete.
 
 * @returns {PXF.Texture} Returns a PXF.Texture, on failure returns false.
 * 
 * @class Simple Texture class.
 * @property {GL_UINT} texture Internal WebGL texture reference.
 * @property {GL_UINT} [minFilter=gl.LINEAR] OpenGL minification filter.
 * @property {GL_UINT} [magFilter=gl.LINEAR] OpenGL magnification filter.
 * @property {GL_UINT} [format=gl.RGBA] OpenGL format specification, see documentation for gl.TexImage2D for further details.
 * @property {GL_UINT} [internalFormat=gl.RGBA] OpenGL internalFormat specification, see documentation for gl.TexImage2D for further details.
 * @property {GL_UINT} [dataType=gl.UNSIGNED_BYTE] OpenGL dataType specification, see documentation for gl.TexImage2D for further details.
 * @property {number} width Width of texture. 
 * @property {number} height Height of texture. 
 */

PXF.Texture = function(ctx, url, settings, onComplete)
{
	var gl = ctx.gl;
	this.ctx = ctx;
	this.gl  = ctx.gl;

	// console.log(gl, url, settings, onComplete);
	// sample settings

	this.minFilter 	= gl.LINEAR;
	this.magFilter 	= gl.LINEAR;
	this.wrapS     	= gl.CLAMP_TO_EDGE;
	this.wrapT     	= gl.CLAMP_TO_EDGE;

	this.format 		= gl.RGBA;
	this.internalFormat = gl.RGBA;
	this.dataType 		= gl.UNSIGNED_BYTE;

	this.target 		= gl.TEXTURE_2D;
	this.face 		    = gl.TEXTURE_2D;

	this.autoFill 		     = false;
	this.autoGenerateMipmaps = true;

	this.url 		= url;	
	this.loaded 	= false;
	this.err 		= "";

	this.width 		= 0;
	this.height 	= 0;
	this.onComplete = onComplete;
	this.dataType;

	extend(this,settings);

	this.Create();
	
	if (this.base64) {
		this.UploadBase64( url );
	} else if (typeof(url) == "string" && !this.UpdateFromUrl(url))	{
		console.error("[/resource/Texture.js:63] Failed while creating texture from URL: " + this.err);
	} else if (typeof(url) == "object" && !this.Upload(url)) {
		console.error("[/resource/Texture.js:65] Failed while creating texture from object: " + this.err);
	}
}

PXF.Texture.prototype.UploadBase64 = function( data ) {

	// try to load base64 encoded image using DOM image element
	// will fail on current Ludei version
	var gl = this.gl;
	try {
		var _image_elem = new Image();
		_image_elem.src = "data:image/png;base64," + data;
		this.url = "data:image/png;base64," + data;
		return this.Upload( _image_elem );
		
	} catch (e) {
		// decode base64 image data
		var _raw_data = decodeBase64_array(data);
		var _data, _png;

		// decode raw png data array into raw image data
		_data = new Uint8Array(_raw_data);
		_png = new PNG(_data);
		_data = new Uint8Array(_png.width * _png.height * 4);
		_png.copyToImageData ({ data: _data}, _png.decodePixels());

		// upload raw image data
		return this.Upload( _data, _png.width, _png.height );

	}

};

PXF.Texture.prototype.ImageHandlers = {};
PXF.Texture.prototype.ImageHandlers["default"] = function( url )
{
	var texobj = this;

	PXF.LoadImage( url, function(event) {
				
		texobj.Upload(this);

		console.log("[/resource/Texture.js:107] Texture loaded: " + url);

		texobj.onComplete && texobj.onComplete( this );
	});
}

/**
 * Loads an external image into the WebGL texture. 
 * @param {url} Image path.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.UpdateFromUrl = function(url) {
	var ext,texobj,gl = this.gl;

	if(!url) return;

	// get image extension
	this.url 	= url;
	texobj		= this;
	ext 		= url.substring(url.lastIndexOf(".")+1);
	ext 		= ext.toLowerCase();

	if ( ext in this.ImageHandlers )
		 this.ImageHandlers[ext].bind(this)( url );
	else this.ImageHandlers["default"].bind(this)( url );

	/*
	// TODO: Move to image loader-class
	switch(ext) {
		// todo: add other image formats
		case 'dds' : 
			// load DXT-compressed images

			// 1. check EXT support
			var s3 	= PXF.CheckDXTSupport();

			if(!s3) {
				console.error("[/resource/Texture.js:144] DDS Not supported."); return;
			}

			// 2. load image data
			loadDDSTexture( s3, url, function(t) { 

				// 2.b auto-flip?

				// 3. mipmaps??????
				var data 				= t.data[0];
				texobj.compressed 		= true;
				texobj.internalFormat 	= t.internalFormat;
				texobj.SetBytesPerPixel();

				// 3. upload compressed data
				texobj.Upload( data,t.width,t.height);

				console.log("[/resource/Texture.js:161] Texture loaded: " + url);

				texobj.onComplete && texobj.onComplete( this );
			});

			break;
		case 'bin' : 

			var old_autofill = this.autoFill;
			this.autoFill = true;
			this.Upload( null, this.width, this.height );
			this.autoFill = old_autofill;

			var buffer = PXF.LoadBuffer( url, function( data ) {
				var typedData;

				if ( texobj.dataType == gl.FLOAT ) 
						typedData = new Float32Array( data );
				else 	typedData = new Uint8Array( data );

				texobj.Upload( typedData, texobj.width, texobj.height );

				console.log("[/resource/Texture.js:183] Texture loaded: " + url);

				texobj.onComplete && texobj.onComplete( this );
			});


			break;
		default : 
			// load native
			PXF.LoadImage( url, function(event) {
				
				texobj.Upload(this);

				console.log("[/resource/Texture.js:196] Texture loaded: " + url);

				texobj.onComplete && texobj.onComplete( this );
			});

			break;
	}
	*/

	return this;
}

/**
 * Update a cube map side
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.UploadFace = function( face, data, w, h, mipmap ) {

	this.face = face;
	this.Upload( data, w, h, mipmap );
}

/**
 * Main data upload function that sends data to the texture object. When data argument is null, an empty texture will be created.
 * @param {buffer} data Data pointer, can be data from Image DOM object, or raw data from array buffers (Float32Array etc). If data == null, empty texture will be created.
 * @param {number} w Texture width.
 * @param {number} h Texture height.
 * @param {number} [mipmap=undefined] If specified, the data will be uploaded to this mipmap.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.Upload = function( data, w, h, mipmap ) {
	var gl = this.gl;

	mipmap = mipmap == undefined ? 0 : mipmap;

	// optional args (will break if not already created texture with height at some point earlier)
	w = w || this.width;
	h = h || this.height;

	// gl.bindTexture(this.target, this.texture);

	this.Bind();

	if ( !data || data.buffer )
	{
		// dimensions
		this.width 	= w;
		this.height = h;

		// buffers
		var size 	= w * h * this.bpp;

		// crashes tabs if we sent to much data when creating empty textures :C
		if ( this.autoFill ) {
			data = data || (this.dataType == gl.FLOAT) ? new Float32Array() : new Uint8Array();

			var bufLen 	= data.length;

			// check data size
			if( size - bufLen > 0 ) {
				var buf = new data.constructor(size);
				buf.set( data );	
				data 	= buf;
			}
		}

		if ( this.compressed ) {
			if(!data) {
				data = new Uint8Array( size );
				gl.compressedTexImage2D( this.face, mipmap, this.internalFormat, this.width, this.height, 0, data);  
				// flag for GC 
				data = undefined;
			} else {
				gl.compressedTexImage2D( this.face, mipmap, this.internalFormat, this.width, this.height, 0, data);  
			}
		} else {
			// console.log("JG TEST", this.internalFormat, this.format, this.dataType );
			gl.texImage2D( this.face, mipmap, this.internalFormat, w, h, 0, this.format, this.dataType, data );
		}
	} else {

	// DOM Image obj.
	// if ( data && ( data.constructor == Image || data.constructor == HTMLImageElement|| HTMLVideoElement && data.constructor == HTMLVideoElement ) ) {
		gl.texImage2D( this.face, 0, this.internalFormat, this.format, this.dataType, data );

		this.width 	= data.width  || data.videoHeight;
		this.height = data.height || data.videoWidth;
	} 
	// gl.bindTexture(this.target, null);

	this.Unbind();

	this.loaded = true;

	return this;
}

/**
 * Function that updates a square segment of a texture.
 * @param {buffer} data Texture data, same as PXF.Texture.Upload.
 * @param {number} x X coordinate for sub square.
 * @param {number} y Y coordinate for sub square.
 * @param {number} w Width coordinate for sub square.
 * @param {number} h Height coordinate for sub square.
 * @param {number} [mipmap=undefined] When specified, the data will be uploaded to this mipmap.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.UploadSub = function( data, x, y, w, h, mipmap ) {
	var gl = this.gl;

	mipmap = mipmap == undefined ? 0 : mipmap;

	// gl.bindTexture(this.target, this.texture);
	this.Bind();

	if ( this.compressed ) 
		 gl.compressedTexSubImage2D( this.target, mipmap, x,y,w,h, this.internalFormat, data);
	else
	{
    	if ( data.buffer ) 
    		 gl.texSubImage2D( this.target, mipmap, x, y, w, h, this.format, this.dataType, data );
        else gl.texSubImage2D( this.target, mipmap, x, y, this.format, this.dataType, data );
	}

	// gl.bindTexture(this.target, null);
	this.Unbind();

	return this;
}

/**
 * Update a cube map side
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.UploadCubeSub = function( face, data, x, y, w, h, mipmap ) {
	var gl = this.gl;

	mipmap = mipmap == undefined ? 0 : mipmap;

	this.Bind();

	if ( this.compressed ) 
		 gl.compressedTexSubImage2D( face, mipmap, x,y,w,h, this.internalFormat, data);
	else
	{
    	if ( data.buffer )		
			 gl.texSubImage2D( face, mipmap, x, y, w, h, this.format, this.dataType, data );
      	else gl.texSubImage2D( face, mipmap, x,y,this.format, this.dataType, data );
	}

	this.Unbind();

	return this;
}

/**
 * Utility function that binds this texture to a shader uniform and a OpenGL texture unit.
 * @param {PXF.Shader} shader Binds the texture to this shader.
 * @param {string} samplerName Uniform name in shader.
 * @param {number} [textureSlot=0] Bind texture to specified texture unit.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.Bind = function(shader, samplerName, textureSlot)
{
	this.textureSlot = textureSlot || isInt(shader) && shader || 0;

	if ( shader instanceof PXF.Shader )
		shader.SetUniform(samplerName, this.textureSlot);

	if ( this.texture === undefined ) 
		this.Create();

	// bind texture to slot
	this.gl.activeTexture(this.gl.TEXTURE0 + this.textureSlot);
	this.gl.bindTexture(this.target, this.texture);

	return this;
}

/**
 * Unbind this texture from the OpenGL texture unit.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.Unbind = function() {
	var gl = this.gl;

	gl.activeTexture(gl.TEXTURE0 + this.textureSlot);
	gl.bindTexture(this.target, null);

	return this;
}

/**
 * Internal function
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.SetBytesPerPixel = function() {
	var gl = this.gl;
	var bpp;

	// build an enum list
	if( !PXF.interalFormatByteList ) {
		var enums 	= {};
		var s3 		= this.ctx.CheckDXTSupport();

		if ( s3 ) {
			enums[s3.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 1;
			enums[s3.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
			enums[s3.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;
			enums[s3.COMPRESSED_RGB_S3TC_DXT1_EXT]  = 0.5;	
		}

		enums[gl.ALPHA] 			= 1;
		enums[gl.LUMINANCE] 		= 1;
		enums[gl.LUMINANCE_ALPHA] 	= 2;
		enums[gl.RGB] 			  	= 3;
		enums[gl.RGBA] 				= 4;

		PXF.interalFormatByteList = enums;
	}

	// dont worry mam, im from the internet
	for(var e in PXF.interalFormatByteList) if ( e == this.internalFormat ) {
		bpp = PXF.interalFormatByteList[e];
		break;
	} 
	
	this.bpp = bpp;

	return this;
}

/**
 * Set OpenGL texture state based on this textures parameters.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.SetTextureParameters = function() {
	var gl = this.gl;
	
	gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, this.magFilter);
	gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, this.minFilter);

	gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, this.wrapS);
	gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, this.wrapT);

	// generate mipmap if needed
	if ((this.minFilter == gl.NEAREST_MIPMAP_NEAREST ||
		 this.minFilter == gl.LINEAR_MIPMAP_NEAREST  ||
		 this.minFilter == gl.NEAREST_MIPMAP_LINEAR  ||
		 this.minFilter == gl.LINEAR_MIPMAP_LINEAR) &&
		 this.autoGenerateMipmaps
		)
	{
		gl.generateMipmap(this.target);
	}

	this.SetBytesPerPixel();

	return this;
}

/**
 * Creates a texture handle and sets all the texture parameters. 
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.Create = function() {
	var gl 	= this.gl;
	var s3 	= PXF.CheckDXTSupport();


	if( this.compressed && s3 ) {
		var internalFormat;

		switch(this.compressed.toUpperCase()) {
			case("DXT1") 	  : internalFormat = s3.COMPRESSED_RGB_S3TC_DXT1_EXT;  break;
			case("DXT1_RGBA") : internalFormat = s3.COMPRESSED_RGBA_S3TC_DXT1_EXT; break;
			case("DXT3") 	  : internalFormat = s3.COMPRESSED_RGBA_S3TC_DXT3_EXT; break;
			case("DXT5") 	  : internalFormat = s3.COMPRESSED_RGBA_S3TC_DXT5_EXT; break;
			default		   	  : internalFormat = s3.COMPRESSED_RGB_S3TC_DXT1_EXT;  break;
		}

		this.internalFormat = internalFormat;
	};

	if ( this.texture === undefined) 
	{
		this.texture = gl.createTexture();
		this.ctx.AllTextures.push( this );
	};

	this.Bind();
	this.SetTextureParameters();
	this.Unbind();

	// PXF.AllTextures.push( this );

	return this;
}

/**
 * Deletes the opengl texture object.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.Destroy = function()
{
	this.gl.deleteTexture(this.texture);
	this.texture = undefined;

	return this;
};

/**
 * Downloads the texture data from OpenGL and opens up a save-as dialog.
 * @returns {PXF.Texture} Returns the texture object.
 */
PXF.Texture.prototype.Save = function()
{
	// FIXME: WebGL readPixels can only get RGBA+UNSIGNED_BYTE pixels.

	// read pixels from texture via a temporary fbo
	var tfbo = new PXF.Framebuffer( this.gl, this );
	tfbo.Bind();
	var pixels = new Uint8Array(this.width * this.height * 4);
	this.gl.readPixels( 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	tfbo.Unbind();
	//tfbo.Destroy();

	// create a temporary canvas element and update its pixels
	var tcanvas    = document.createElement('canvas');
	var c = tcanvas.getContext("2d");
	var canvasData = c.getImageData(0, 0, this.width, this.height);
	tcanvas.width  = this.width;
	tcanvas.height = this.height;

	//canvasData.data.set(pixels);
	for (var y = 0; y < this.height; y++)
	{
		var ty = this.height - 1 - y;
		for (var x = 0; x < this.width; x++)
		{
			var id1 = (y * this.width) + x;
			var id2 = (ty * this.width) + x;
			canvasData.data[id1*4 + 0] = pixels[id2*4 + 0];
			canvasData.data[id1*4 + 1] = pixels[id2*4 + 1];
			canvasData.data[id1*4 + 2] = pixels[id2*4 + 2];
			canvasData.data[id1*4 + 3] = pixels[id2*4 + 3];
		}
	}

	c.putImageData(canvasData, 0, 0);

	// convert canvas element to png data and update in a new window
	window.open(tcanvas.toDataURL("image/png"));

	tcanvas = null;

	return this;
};


PXF.Texture.prototype.Resize = function( width, height ) {
	var gl 	= this.gl;

	this.Create();

	/////// create texture and FBO
	var tmp_tex = new PXF.Texture( gl, undefined, {
			dataType : this.dataType,
			minFilter : this.minFilter,
			magFilter : this.magFilter,
			wrapS : this.wrapS,
			wrapT : this.wrapT,
			format : this.format,
			internalFormat : this.internalFormat,
			target : this.target,
			face : this.face,
			autoFill : this.autoFill,
			autoGenerateMipmaps : this.autoGenerateMipmaps
		});
	tmp_tex.Upload( null, width, height );

	if (this.width != 0)
	{

		if ( this.ctx.TextureResizeFBO == undefined)
		{
			this.ctx.TextureResizeFBO = new PXF.Framebuffer( gl, tmp_tex, undefined, false, false );

			/////// create a "fullscreen" (viewspace?) quad
			this.ctx.TextureResizeQB = new PXF.QuadBatch( gl );
			this.ctx.TextureResizeQB.Reset();
			this.ctx.TextureResizeQB.SetCoords(0,0, 1, 0, 1, 1, 0, 1);
			this.ctx.TextureResizeQB.depth = 0;
			this.ctx.TextureResizeQB.AddCentered( 0, 0, 2, 2 );
			this.ctx.TextureResizeQB.End();
		} else {
			this.ctx.TextureResizeFBO.Rebuild( tmp_tex );
		}

		/////// bind fbo, setup gl specifics and clear buffer
		this.ctx.TextureResizeFBO.Bind();
		gl.viewport( 0, 0, width, height );

		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.CULL_FACE);
		gl.disable(gl.BLEND);
		gl.clearColor(0,1,0,1);
		gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );


		/////// bind shader, previous texture and draw qb buffers
		var shader = this.ctx.Shaderlib["textureCopy"];
		shader.Bind();

		this.Bind(shader, "tex0", 0);
		this.ctx.TextureResizeQB.BindBuffers(shader, { "position" : true, "normal" : false, "uv0" : true } );
		this.ctx.TextureResizeQB.DrawBuffers(shader);
		this.ctx.TextureResizeQB.UnbindBuffers(shader, { "position" : true, "normal" : false, "uv0" : true } );

		/////// unbind
		shader.Unbind();
		this.ctx.TextureResizeFBO.Unbind();

	} else {
		console.warn("Can't resize a texture with invalid width or height.");
	}

	// delete "old" webgl texture
	gl.deleteTexture( this.texture );
	this.texture = tmp_tex.texture;
	this.width   = width;
	this.height  = height;
	tmp_tex = undefined;

};


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/Shaderlib.js: */

// DEPENDENCIES: /resource/Shader.js

var forwardVSraw = [
	"precision highp float; ",
	"attribute vec3 position; ",
	"attribute vec3 normal; ",
	"attribute vec2 uv0; ",
	"uniform mat4 uMVMatrix; ",
	"uniform mat4 uPMatrix; ",
	"uniform mat4 uNMatrix; ",
	"varying vec2 vUv; ",
	"varying vec3 vPosition; ",
	"varying vec4 vNormal; ",
	"void main(void) { ",
		"vUv 		 = uv0; ",
		"vNormal	 = uNMatrix * vec4(normal,0.0); ",
		"vPosition	 = position;",
		"gl_Position = uPMatrix * uMVMatrix * vec4(position,1.0); ",
	"}"
].join("\n");

var forwardFSraw = [
	"precision highp float;",
	"uniform sampler2D tex0;",
	"uniform float uFlipHorizontal;",
	"",
	"varying vec2 vUv;",
	"varying vec4 vNormal;",
	"",
	"void main(void) {",
		"gl_FragColor = texture2D( tex0, vec2( vUv.s, (1.0-vUv.t) * uFlipHorizontal + vUv.t * (1.0-uFlipHorizontal) ));",
	"}",
].join("\n");

var bitmapFontVSraw = [
	"precision mediump float; ",
	"attribute vec3 position; ",
	"attribute vec3 normal; ",
	"attribute vec2 uv0; ",
	"uniform mat4 uMtx; ",
	"varying vec2 vUv; ",
	"varying vec3 vColor; ",
	"void main(void) { ",
		"vUv 		 = uv0; ",
		"vColor	     = normal; ",
		"gl_Position = uMtx * vec4(position.xy, 0.0,1.0); ",
	"}"
].join("\n");

var bitmapFontFSraw = [
	"precision mediump float;",
	"uniform sampler2D tex0;",
	"",
	"varying vec2 vUv;",
	"varying vec3 vColor;",
	"",
	"void main(void) {",
		"gl_FragColor = vec4(vColor, 1.0) * texture2D( tex0, vUv );",
	"}",
].join("\n");

var textureCopyVSraw = [
	"precision mediump float; ",
	"attribute vec3 position; ",
	"attribute vec2 uv0; ",
	"varying vec2 vUv; ",
	"void main(void) { ",
		"vUv 		 = uv0.st; ",
		"gl_Position = vec4(position.xyz,1.0); ",
	"}"
].join("\n");

var textureCopyFSraw = [
	"precision mediump float;",
	"uniform sampler2D tex0;",
	"",
	"varying vec2 vUv;",
	"",
	"void main(void) {",
		"gl_FragColor = vec4(texture2D( tex0, vUv ).rgb, 1.0);",
	"}",
].join("\n");

var forwardSolidColorFSraw = [
	"precision mediump float;",
	"uniform vec3 color;",
	"",
	"varying vec2 vUv;",
	"varying vec4 vNormal;",
	"",
	"void main(void) {",
		"gl_FragColor = vec4(color,1.0);",
	"}",
].join("\n");

var forwardNormalFSraw = [
	"precision mediump float;",
	"uniform vec3 color;",
	"",
	"varying vec2 vUv;",
	"varying vec4 vNormal;",
	"",
	"void main(void) {",
		"vec3 n = normalize((vNormal.xyz + 1.0) * 0.5);",
		"gl_FragColor = vec4( n,1.0);",
	"}",
].join("\n");

var forwardUVFSraw = [
	"precision mediump float;",
	"uniform vec3 color;",
	"",
	"varying vec2 vUv;",
	"varying vec4 vNormal;",
	"",
	"void main(void) {",
		"gl_FragColor = vec4( vUv,0.0,1.0);",
	"}",
].join("\n");

var forwardPositionFSraw = [
	"precision mediump float;",
	"uniform vec3 color;",
	"",
	"varying vec2 vUv;",
	"varying vec3 vPosition;",
	"varying vec4 vNormal;",
	"",
	"void main(void) {",
		"gl_FragColor = vec4( vPosition.xyz,1.0);",
	"}",
].join("\n");

var cubemapVSraw = [
	"attribute vec3 position; ",
	"attribute vec3 normal; ",
	"attribute vec2 uv0; ",
	"uniform vec3 uCamerapos;",
	"uniform mat4 uMVMatrix; ",
	"uniform mat4 uPMatrix; ",
	"uniform mat4 uNMatrix; ",
	"varying vec2 vUv; ",
	"varying vec4 vNormal; ",
	"varying vec3 vEye; ",
	"void main(void) { ",
		"vec4 tEye   = uMVMatrix * vec4(position,1.0);",
		"vEye        = uCamerapos-position;",
		"vUv 		 = uv0;",
		"vNormal	 = vec4(normal,0.0);",
		"gl_Position = uPMatrix * tEye;",
	"}"
].join("\n");

var cubemapFSraw = [
	"precision mediump float;",
	"uniform samplerCube tex0;",
	"varying vec2 vUv; ",
	"varying vec4 vNormal; ",
	"varying vec3 vEye; ",
	"",
	"void main(void) {",
		"vec3 treflect = reflect( normalize(-vEye), normalize(vNormal.rgb) );",
		"vec4 sample  = textureCube( tex0, treflect );",
		"gl_FragColor = vec4( sample.rgb,1.0);",
	"}"
].join("\n");

var cubemapLonglatFSraw = [
	"#define PI 3.14159265359",
	"precision mediump float;",
	"uniform sampler2D tex0;",
	"varying vec2 vUv; ",
	"varying vec4 vNormal; ",
	"varying vec3 vEye; ",
	"",
	"vec2 get_uv(vec3 tvec)",
	"{",
	"vec2 uv;",
	"",
	"// atan2 yields result in the [-PI,PI] range",
	"float yaw 	= atan( tvec.z, tvec.x );",
	"float pitch = atan( tvec.y, length(tvec.xz));",
	"",
	"yaw		/=2.0*PI; // normalize it to [-0.5,0.5]",
	"pitch	/=PI; // normalize it to [-1.0,1.0]",
	"",
	"yaw += 0.5; // move up to 0 .. 1 ",
	"pitch += 0.5; // --||--",
	"",
	"uv.s = yaw;",
	"uv.t = pitch;",
	"",
	"return uv;",
	"}",
	"void main(void) {",
		"vec3 treflect = reflect( normalize(vEye), normalize(vNormal.rgb) );",
		"vec4 sample  = texture2D( tex0, get_uv(treflect) );",
		"gl_FragColor = vec4( sample.rgb,1.0);",
	"}"
].join("\n");

var lambertVSraw = [
	"precision mediump float; ",
	"attribute vec3 position; ",
	"attribute vec3 normal; ",
	"attribute vec2 uv0; ",
	"uniform mat4 uMVMatrix; ",
	"uniform mat4 uPMatrix; ",
	"uniform mat4 uNMatrix; ",
	"varying vec2 vUv; ",
	"varying vec3 vPosition; ",
	"varying vec4 vNormal; ",
	"void main(void) { ",
		"vUv 		 = uv0; ",
		"vNormal	 = uNMatrix * vec4(normal,0.0); ",
		"vPosition	 = (uMVMatrix * vec4(position,1.0)).xyz;",
		"gl_Position = uPMatrix * vec4(vPosition,1.0); ",
	"}"
].join("\n");

var lambertFSraw = [
	"precision mediump float;",
	"uniform float uStrength;",
	"",
	"varying vec2 vUv;",
	"varying vec3 vPosition;",
	"varying vec4 vNormal;",
	"",
	"void main(void) {",
		"vec3 tlambert = mix( vec3( dot(-normalize(vPosition),vNormal.xyz)),vec3(1.0), uStrength );",
		"gl_FragColor = vec4( tlambert, 1.0);",
	"}",
].join("\n");

// todo: deferred building
PXF.Shaderlib = { 
	forward 			: { vsRaw : forwardVSraw, 		fsRaw : forwardFSraw 		    },
	textureCopy			: { vsRaw : textureCopyVSraw, 	fsRaw : textureCopyFSraw	    },
	forwardSolidColor 	: { vsRaw : forwardVSraw, 		fsRaw : forwardSolidColorFSraw 	},
	forwardNormal 		: { vsRaw : forwardVSraw, 		fsRaw : forwardNormalFSraw 		},
	forwardPosition		: { vsRaw : forwardVSraw, 		fsRaw : forwardPositionFSraw 	},
	bitmapFont          : { vsRaw : bitmapFontVSraw,	fsRaw : bitmapFontFSraw			},
	lambert             : { vsRaw : lambertVSraw,       fsRaw : lambertFSraw            },
	cubemap             : { vsRaw : cubemapVSraw,	    fsRaw : cubemapFSraw			},
	cubemapLonglat      : { vsRaw : cubemapVSraw,	    fsRaw : cubemapLonglatFSraw 	},
};


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/Object.js: */

// DEPENDENCIES: /pxf.js, /core/Utils.js

function _pxfObjectFactory(ctx, scene, json, parent)
{
	// peek child type
	if ("type" in json)
	{
		if (json.type == "mesh") {
			return new PXF.MeshObject(ctx, scene, json, parent);
		} else if (json.type == "lodmesh") {
			return new PXF.StaticLODMeshObject( ctx, scene, json, parent );
		} else if (json.type == "camera") {
			return new PXF.Camera(ctx, scene, json, parent);
		} 
	}

	return new PXF.Object(ctx, scene, json, parent);
}

/**
 * Constructor for the Object class.
 * @constructor
 * @param {string} id Name identifier.
 * 
 * @class Base class for scene nodes.
 * @property {string} id The id of the object.
 * @property {PXF.AABB} boundingBox Axis-aligned bounding box of an object.
 */
PXF.Object = function(ctx, scene, json, parent) {
	json = json || {};

	var defaultProperties = {
		"rotation" 			 : vec4.create( [0,0,0,1] ),
		"position" 			 : vec3.create(),
		"scale" 			 : vec3.create([1,1,1]),
		"worldtransform" 	 : mat4.identity(),
		"invworldtransform"  : mat4.identity(),
		"normaltransform"    : mat4.identity(),
		"invnormaltransform" : mat4.identity(),
		"children" 			 : {},
		"touched" 			 : 0
	};

	extend( this, defaultProperties );
	extend( this, json );

	this.parent = parent;

	if( !( "transform" in json ) ) {
		this.transform = mat4.create();
		mat4.fromRotationTranslation(this.rotation, this.position, this.transform);
	} else {
		var rotmat = mat3.create();
		mat4.toMat3(this.transform, rotmat);
		quat4.fromRotationMatrix(rotmat, this.rotation);

		this.position = getPositionFromMatrix(this.transform);
	}

	this.Scale( this.scale );

	// create children
	for (var k in this.children) {
		this.children[k] = _pxfObjectFactory(ctx, scene, this.children[k], this);
	}

	this.Update(1.0);
}

/**
 * Updates the transform matrices from a lookat point.
 * @param {vec3} lookat Lookat position in world space coordinates.
 */
PXF.Object.prototype.UpdateMatricesFromLookAt = function(lookat)
{
	if(!this.position) return;

	this.lookat 	= lookat || this.lookat;
		
	this.Identity();
	mat4.lookAt(this.position, this.lookat, [0.0, 1.0, 0.0], this.transform);
}

/**
 * Updates and sets all the transform matrices for this object.
 * @param {number} delta Time difference from last frame.
 */
PXF.Object.prototype.Update = function(delta) {

	// update objects own world matrix, from the local matrix
	this.invtransform = mat4.create(this.transform); mat4.inverse(this.invtransform);
	if (this.parent)
	{
		mat4.multiply(this.parent.worldtransform ,this.transform, this.worldtransform);
	} else {
		this.worldtransform = mat4.create(this.transform);
	}

	// update inverse world transform
	mat4.inverse(this.worldtransform, this.invworldtransform, this.invworldtransform);

	// update normal mtx
	mat4.transpose(this.invworldtransform, this.normaltransform, this.normaltransform);

	mat4.transpose(this.worldtransform, this.invnormaltransform, this.invnormaltransform);
	
	for (var c in this.children)
	{
		// update childrens world matrix from our world matrix
		this.children[c].Update(delta);
	}

	// update position
	this.worldposition 	= getPositionFromMatrix(this.worldtransform);
	// this.invworldposition 	= getPositionFromMatrix(this.invworldtransform);
	//this.position 		= getPositionFromMatrix(this.transform);

	this.touched++;
};

/**
 * Scales object according to a specific vector.
 * @function 
 * @param {float} x Scale component x.
 * @param {float} y Scale component y.
 * @param {float} z Scale component z.
 */
PXF.Object.prototype.Scale = function(x,y,z) {
	if ( typeof(x) == "object" && x.length >= 2 ) {
		var tmp = x;
		x 		= tmp[0];
		y 		= tmp[1];
		z 		= tmp[2];
	} 

	mat4.scale( this.transform, [x,y,z], this.transform );
}

/**
 * Translates object according to a specific vector.
 * @function 
 * @param {float} x Translate component x.
 * @param {float} y Translate component y.
 * @param {float} z Translate component z.
 */
PXF.Object.prototype.Translate = function(x,y,z) {
	if ( typeof(x) == "object" && x.length >= 2 ) {
		var tmp = x;
		x 		= tmp[0];
		y 		= tmp[1];
		z 		= tmp[2];
	} 

	mat4.translate( this.transform, [x,y,z], this.transform );
}

/**
 * Set object transform to identity.
 * @function 
 */
PXF.Object.prototype.Identity = function()
{
	mat4.identity( this.transform );
}


/**
 * Rotates object according to a specific vector and angle.
 * @function 
 * @param {float} angle Rotation angle.
 * @param {float} x Rotate component x.
 * @param {float} y Rotate component y.
 * @param {float} z Rotate component z.
 */
PXF.Object.prototype.Rotate = function(angle,x,y,z) {
	if ( typeof(x) == "object" && x.length >= 2 ) {
		var tmp = x;
		x 		= tmp[0];
		y 		= tmp[1];
		z 		= tmp[2];
	} 

	mat4.rotate( this.transform, angle, [x,y,z], this.transform );
}



/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/core/Input.js: */

// DEPENDENCIES: /pxf.js

/**
 * Input state table that stores a table with properties for the current input.
 * @property {boolean} mouseDown Mouse button currently being pressed.
 * @property {boolean} mouseMoved Mouse moved since last we sampled the state.
 */
PXF.Input = {};
PXF.Input.State = function() {

	// create new state w/ default parameters
	var _state = { "mouseDown" : false,
					"mouseMoved" : false,
					"mouseButton" : 0,
					"mousePos" : [0.0, 0.0],
					"mouseDelta" : [0.0, 0.0],
					"mouseWheelDelta" : 0,
					"mouseAwaitingDblClick" : false,
					"mouseDoubleClicked" : false,
					"keyGlobal" : undefined,
					"keyCallbacks" : {},
					"mouseButtonEnum" : { "LEFT" : 0, "MIDDLE" : 1, "RIGHT" : 2},
					"specialKeys" : {
						    "TAB"       : 9,
							"ESC"       : 27,
							"CTRL"      : 17,
							"SHIFT"     : 16,
							"ALT"       : 18,
							"SPACE"     : 32,
							"ENTER"     : 13,
							"BACKSPACE" : 8,
							"WIN"       : 91,
							"CAPSLOCK"  : 20,
							"UP"        : 38,
							"DOWN"      : 40,
							"LEFT"      : 37,
							"RIGHT"     : 39
							},
					"keyState" : {},
					"callbackOnUpdate" : true,
					"touches" : {}
				  };

	// TODO Solve this nicer...
	_state.specialKeysReverse = {};
	for (var k in _state.specialKeys)
	{
		_state.specialKeysReverse[_state.specialKeys[k]] = k;
	};

	return _state;
};

/**
 * @function
 * Register a function callback for specific keyboard keys.
 * @param {Array} keys An array of keys to which the callback should be registered.
 * @param {function} fun A function that will be called when the keys are pressed/released.
 */
PXF.Instance.prototype.RegisterKeyCallback = function(keys, fun)
{
	for (var k in keys)
	{
		var i = 0;

		if ( typeof keys[k] != "string" ) {
			continue;
		}

		// check if key is a special key
		if (this._inputState.specialKeys[keys[k]])
			i = this._inputState.specialKeys[keys[k]];
		else
			i = keys[k].toUpperCase().charCodeAt();

		if (this._inputState.keyCallbacks[i])
		{
			this._inputState.keyCallbacks[i].push(fun);
		} else {
			this._inputState.keyCallbacks[i] = [fun];
		}
	}
};

/**
 * @function
 * Unregister a function callback for specific keyboard keys.
 * @param {Array} keys An array of keys to which the callback should be unregistered.
 * @param {function} fun Function that will be unregistered (ie should previously have been registered).
 */
PXF.Instance.prototype.UnregisterKeyCallback = function(keys, fun)
{
	for (var k in keys)
	{
		var i = 0;

		// check if key is a special key
		if ( this._inputState.specialKeys[keys[k]])
			i = this._inputState.specialKeys[keys[k]];
		else
			i = keys[k].charCodeAt();

		// find callback reference in keyCallback list and reset it
		for (var c in this._inputState.keyCallbacks[i])
		{
			var idx = this._inputState.keyCallbacks[i].indexOf(fun);
			this._inputState.keyCallbacks[i].splice(idx, 1);
		};

	}
};


/**
 * Internal aux and input callback functions.
 */

PXF._touchStart = function(event)
{
	var lastEvent = {};

	for ( var t in event.touches )
	{
		var touch   = event.touches[t];
		var touchId = touch.identifier;

		lastEvent.clientX = touch.clientX;
		lastEvent.clientY = touch.clientY;

		this._inputState.touches[touchId] = touch;
	};

	var wrappedEvent = {
		mouseButton : event.touches.length,
		clientX : lastEvent.clientX,
		clientY : lastEvent.clientY
	};

	PXF._inputMouseDown.bind(this)(wrappedEvent);

	return false;
}

PXF._touchEnd = function(event)
{
	var wrappedEvent = {
		mouseButton : event.touches.length,
		clientX : 0,
		clientY : 0
	};

	PXF._inputMouseUp.bind(this)(wrappedEvent);	
}

PXF._touchMove = function(event)
{
	var lastEvent = {};

	for ( var t in event.touches )
	{

		var touch   = event.touches[t];
		var touchId = touch.identifier;

		lastEvent.clientX = touch.clientX;
		lastEvent.clientY = touch.clientY;

		this._inputState.touches[touchId] = touch;

		// console.log(t + " has touch id " + touchId);
	};

	var wrappedEvent = {
		clientX : lastEvent.clientX,
		clientY : lastEvent.clientY,
	}

	PXF._inputMouseMove.bind(this)( wrappedEvent );
}

 PXF._translateKeyCodeToString = function(keyCode)
{
	// check if key is a special key
	if (this._inputState.specialKeysReverse[keyCode])
	{
		return this._inputState.specialKeysReverse[keyCode];
	}
	
	return String.fromCharCode(keyCode);
};

PXF._inputMouseClick = function(event)
{

    if ( !this._inputState.mouseAwaitingDblClick )
    {
        this._inputState.mouseAwaitingDblClick = Date.now();
    } else {
        var awaitok = (Date.now() - this._inputState.mouseAwaitingDblClick) / 1000;

        if (  awaitok < 0.25 )
        {
            this._inputState.mouseDoubleClicked = true;
            this._inputState.mouseAwaitingDblClick = false;
        } else {
            this._inputState.mouseAwaitingDblClick = Date.now();
        }
    };

};

PXF._inputMouseDown = function(event)
{
	this._inputState.mouseDown = true;
	this._inputState.mouseButton = event.button;
	this._inputState.mousePos = [event.clientX, event.clientY];
	this._inputState.mouseDelta = [0.0, 0.0];
	return false;
};

PXF._inputMouseUp = function(event)
{

	this._inputState.mouseDown = false;
	this._inputState.mouseDelta = [0.0, 0.0];
	this._inputState.mousePos = [event.clientX, event.clientY];

	return false;
};

PXF._inputMouseMove = function(event)
{
	this._inputState.mouseMoved = true;
	var prev_pos = this._inputState.mousePos;
	var glcanvas = glcanvas || undefined;

	if (glcanvas && !!(glcanvas.webkitRequestPointerLock))
	{
		event.movementX = event.movementX || event.mozMovementX || event.webkitMovementX;
		event.movementY = event.movementY || event.mozMovementY || event.webkitMovementY;
		this._inputState.mouseDelta = [this._inputState.mouseDelta[0] + event.movementX, this._inputState.mouseDelta[1] + event.movementY];
	}
	else
  	{
		this._inputState.mouseDelta = [event.clientX - prev_pos[0], event.clientY - prev_pos[1]];  	  
  	};

	this._inputState.mousePos = [event.clientX, event.clientY];

	return false;
};

PXF._inputMouseWheel = function(event)
{	
	// todo: cross-platform support!
	if ('wheelDelta' in event)	{	
		this._inputState.mouseWheelDelta += event.wheelDelta;
	} else if ( 'detail' in event ) {
		this._inputState.mouseWheelDelta -= event.detail * 120;
	}
};

PXF._inputKeyPress = function(event)
{
	// set internal key state
	//if (this._inputState.keyState[event.keyCode])
	// {
		// console.log(this._inputState.keyState[event.keyCode].state);
	// }

	this._inputState.keyState[event.keyCode] = { "state" : "press", "event" : event };
	//this._inputState.keyState[event.keyCode].event = event;

	// should we forward this event directly?
	if (!this._inputState.callbackOnUpdate)
	{
		if (this._inputState.keyGlobal)
		{
			// TODO Make "up"/"press" constants
			this._inputState.keyGlobal("press", event);
		}

		if (this._inputState.keyCallbacks)
		{
			if (this._inputState.keyCallbacks[event.keyCode])
			{
				event.preventDefault();
				
				var c = (PXF._translateKeyCodeToString.bind(this))(event.keyCode);

				for (var i in this._inputState.keyCallbacks[event.keyCode])
				{
					this._inputState.keyCallbacks[event.keyCode][i]("press", c, event);
				}
			}
		}
	}

	return false;
};

PXF._inputKeyUp = function(event)
{
	//if (this._inputState.keyState[event.keyCode])
	this._inputState.keyState[event.keyCode] = { "state" : "up", "event" : event };
	//else
	//	this._inputState.keyState[event.keyCode] = [{ "state" : "up", "event" : event }];
	//this._inputState.keyState[event.keyCode] = "up";
	//this._inputState.keyState[event.keyCode].event = event;

	if (!this._inputState.callbackOnUpdate)
	{
		if (this._inputState.keyGlobal)
		{
			// TODO Make "up"/"press" constants
			this._inputState.keyGlobal("up", event);
		}

		if (this._inputState.keyCallbacks)
		{
			if (this._inputState.keyCallbacks[event.keyCode])
			{
				event.preventDefault();

				var c = PXF._translateKeyCodeToString.bind(this)(event.keyCode);
				for (var i in this._inputState.keyCallbacks[event.keyCode])
				{
					this._inputState.keyCallbacks[event.keyCode][i]("up", c, event);
				}

			}
		}
	}


	return false;
};




/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/resource/Framebuffer.js: */

// DEPENDENCIES: /pxf.js
/**
 * Constructor for the FrameBuffer class.
 * @constructor
 * @param {WebGLContext} gl WebGL context.
 * @param {PXF.Texture} colorTexture Texture that should be bound as color attachement.
 * @param {PXF.Texture} [depthTexture=undefined] Texture that should be bound as depth attachement. (NOTE: Does not work in WebGL 1.0).
 * @returns {PXF.FrameBuffer} Returns a PXF.Texture, on failure returns false.
 *
 * @class Simple FrameBuffer class.
 */
PXF.Framebuffer = function ( ctx, colorTexture, depthTexture, autocheck, autoCreateDepth ) {
	
	this.ctx = ctx;
	this.gl  = ctx.gl;
	this.fbo = undefined;

	this.attachments 		= {};
	this.attachments.color 	= colorTexture ? [colorTexture] : [];
	this.attachments.depth 	= (depthTexture === undefined ? undefined : depthTexture);// || undefined;

	this.bound 				= false;
	this.built 				= false;
	this.autocheck 			= autocheck;
	this.autoCreateDepth 	= autoCreateDepth;

	// build only if FBO is created with a color texture
	if( colorTexture )
		this.Build();
};

PXF.Framebuffer.prototype.Validate = function() {
	if ( this.fbo === undefined )
	{
		// create handle
		this.fbo = this.gl.createFramebuffer();

		this.ctx.AllFramebuffers.push( this );
	}
}

/**
 *  Check FrameBuffer OpenGL status, and pretty-prints the error msg. Returns false if failed, true otherwise.
 */
PXF.Framebuffer.prototype.CheckStatus = function() {

	if (!this.autocheck)
		return true;

	var gl 		= this.gl;
	var status 	= gl.checkFramebufferStatus(gl.FRAMEBUFFER);

	switch (status) {
		case gl.FRAMEBUFFER_COMPLETE:

			console.log("[/resource/Framebuffer.js:56] Framebuffer complete.");
			return true;
		case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
			console.error("[/resource/Framebuffer.js:59] Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
			break;
		case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
			console.error("[/resource/Framebuffer.js:62] Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
			break;
		case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
			console.error("[/resource/Framebuffer.js:65] Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
			break;
		case gl.FRAMEBUFFER_UNSUPPORTED:
			console.error("[/resource/Framebuffer.js:68] Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
			break;
		default:
			console.error("[/resource/Framebuffer.js:71] Incomplete framebuffer: " + status);
			break;
	}

	return false;
};

/**
 *  Set viewport from color attachment 0
 */
PXF.Framebuffer.prototype.SetViewport = function() {

	// console.log("framebuffer setting viewport to:", this.attachments.color[0].width, this.attachments.color[0].height);
	this.gl.viewport( 0, 0, this.attachments.color[0].width, this.attachments.color[0].height );

};

/**
 * Internal function to attach buffers to framebuffer.
 */
PXF.Framebuffer.prototype.Build = function() {

	
	var gl = this.gl;

	this.Bind();

	// loop through all textures that should be bound as color attachments
	// note: webgl only supports one color attachment right now
	for (var i in this.attachments.color)
	{
		this.w = this.attachments.color[i].width;
    	this.h = this.attachments.color[i].height;
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0/* + i*/, gl.TEXTURE_2D, this.attachments.color[i].texture, 0);
	}

	// if there was a supplied depth texture, use this as depth attachment
	// otherwise create a renderbuffer...
	// NOTE: This does not seem to work in WebGL 1.0
	if (this.attachments.depth)
	{
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.attachments.depth.texture, 0);
	} else if (this.depthBuffer === undefined && this.autoCreateDepth === true) {
		this.depthBuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer( gl.RENDERBUFFER, this.depthBuffer );
		gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.attachments.color[0].width, this.attachments.color[0].height );
		gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer );
	}

	if(this.CheckStatus()) this.built = true;

	this.Unbind();
};

// FIXME This does not seem to work! Getting type errors when I try to detach either the depth och color texture
/*
PXF.Framebuffer.prototype.DetachAll = function()
{
	// Detach everything first
	for (var ak in this.attachments.color)
	{
		var a = this.attachments.color[ak];
		//console.log("asd1");
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, 0, 0);
		//console.log("asd2");

	}

	if (this.depthBuffer)
	{
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, 0);
		gl.deleteRenderbuffer(this.depthBuffer);
	}
};
*/

/**
 * Rebuilds the FBO from a color texture and an (optional) depth texture.
 * @param {PXF.Texture} colorTexture Color texture that will be used as primary attachment.
 * @param {PXF.Texture} [depthTexture=undefined] Depth texture that will be used as depth buffer attachment.
 */
PXF.Framebuffer.prototype.Rebuild = function( colorTexture, depthTexture )
{
	var gl = this.gl;

	this.Bind();

	/*if (this.depthBuffer)
	{
		//gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, 0);
		gl.deleteRenderbuffer(this.depthBuffer);
	}*/

	//if (this.depthBuffer && (this.attachments.color[0].width != colorTexture.width || this.attachments.color[0].height != colorTexture.height))
	if (this.depthBuffer && (this.attachments.color[0].width != this.w || this.attachments.color[0].height != this.h))
	{
		//gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, 0);
		console.log("Buffer resized, removing old depth render buffer.");
		gl.deleteRenderbuffer(this.depthBuffer);
		this.depthBuffer = undefined;
	}

	//this.depthBuffer = this.depthBuffer || undefined;
	this.attachments.color = colorTexture ? [colorTexture] : [];
	this.attachments.depth = depthTexture != undefined ? depthTexture : this.attachments.depth;
	this.bound = false;
	this.built = false;

	// build only if FBO is created with a color texture
	if( colorTexture )
		this.Build();

	this.Unbind();
};

/**
 * Bind framebuffer. All WebGL commands after the bind will be to
 * newly bound framebuffer object.
 */
PXF.Framebuffer.prototype.Bind = function( set_viewport ) {
	
	this.Validate();

	if (this.bound)
		return;

	if (set_viewport !== undefined && set_viewport == true)
	{
		this.SetViewport();
	}

	this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
	this.bound = true;
};

/**
 * Unbind framebuffer (ie bind the backbuffer).
 */
PXF.Framebuffer.prototype.Unbind = function() {
	
	if (!this.bound)
		return;

	this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
	this.bound = false;
};

/**
 * Detaches a texture from the framebuffer.
 * @param {PXF.Texture} tex Texture to be detached (should have been attached earlier as either a color or depth attachment).
 */
PXF.Framebuffer.prototype.DetachTexture = function(tex) {
	var gl = this.gl;

	this.Bind();

	for (var i in this.attachments.color)
	{
		if (this.attachments.color[i] == tex)
		{
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0/* + i*/, gl.TEXTURE_2D, 0, 0);
		}
	}

	this.Unbind();
};

/**
 * Detaches a texture from the framebuffer by color attachment number.
 * @param {PXF.Texture} tex Texture to be detached (should have been attached earlier as either a color or depth attachment).
 */
PXF.Framebuffer.prototype.DetachById = function(index) {
	var gl = this.gl;

	this.Bind();

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0/* + index*/, gl.TEXTURE_2D, 0, 0);
	this.attachments.color[i] = undefined;

	this.Unbind();
};

/**
 * Attaches a texture as a color attachment to the framebuffer.
 * If there is a previously attached texture to the affected color attachment, it will be detached.
 * @param {PXF.Texture} tex Texture to be detached (should have been attached earlier as a color attachment).
 * @param {int} attachmentIndex Color attachment index.
 */
PXF.Framebuffer.prototype.AttachColorTexture = function(tex, attachmentIndex) {
	var gl = this.gl;
	attachmentIndex = attachmentIndex ? attachmentIndex : 0;
	this.attachments.color[attachmentIndex] = tex;

	if(!this.built) this.Build();

	this.Bind();

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0/* + i*/, gl.TEXTURE_2D, this.attachments.color[attachmentIndex].texture, 0);

	this.CheckStatus();
};

/**
 * Attaches a texture as a depth attachment to the framebuffer.
 * If there is a previously attached texture as depth attachment, it will be detached.
 * @param {PXF.Texture} tex Texture to be detached (should have been attached earlier as a depth attachment).
 */
PXF.Framebuffer.prototype.AttachDepthTexture = function(tex) {
	var gl = this.gl;
	
	this.Bind();

	if (this.attachments.depth)
	{
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.attachments.depth.texture, 0);
	}

	this.attachments.depth = tex;	
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.attachments.depth.texture, 0);

	this.Unbind();
	this._Build();
};


PXF.Framebuffer.prototype.Destroy = function() {
	this.gl.deleteFramebuffer(this.fbo);
	delete this.fbo;
};


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/Skeleton.js: */

// DEPENDENCIES: /pxf.js

/** 
 * DEPRECATED
 */
PXF.Skeleton = function(id, data, maxBones) {
	this.maxBones 		  = maxBones || 40;
	this.name 			  = id;
	this.bones 			  = data;
	this.bindPoseArray 	  = new Float32Array(16 * this.maxBones);
	this.bindInvPoseArray = new Float32Array(16 * this.maxBones);

	for (var j =0; j < data.length; j++) {
		var jointMatrix = mat4.identity();
		var invMatrix   = mat4.identity();
		var rotation    = data[j].Rotation;
		var position    = data[j].Position;
		var parent      = data[j].Parent;


		mat4.fromRotationTranslation(rotation, position, jointMatrix);

		if(parent != undefined) {
			var pMtx = this.bindPoseArray.subarray(16 * parent,16 * parent + 16);
			mat4.multiply(pMtx, jointMatrix, jointMatrix);	
		}

		mat4.inverse(jointMatrix, invMatrix);

		this.bindPoseArray.set(jointMatrix, 16*j);
		this.bindInvPoseArray.set(invMatrix, 16*j);
	} 
}



/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/core/Intersect.js: */

// DEPENDENCIES: /pxf.js

// define constants
PXF.NEGATIVE_HALFSPACE 	= -1;
PXF.POSITIVE_HALFSPACE 	= 1;
PXF.ON_PLANE 			= 0;

/** 
 * Inersection test: Sphere-Sphere function ( NOT IMPLEMENTED )
 */

// helper functions for shape intersections
PXF.IntersectSphereSphere = function(o1,r1,o2,r2) {
	
}

/**
 * Inersection test: Ray - Sphere
 * @property {vec3} o  ray origin
 * @property {vec3} d  ray direction
 * @property {number} r  sphere radius
 * @property {vec3} p0  sphere origin 
 * @property {number} radius Sphere radius.
 */
PXF.IntersectRaySphere = function(o,d,r,p0) {
	var L = vec3.create();

	vec3.normalize(d);
	vec3.subtract(p0,o,L);

	var t_ca = vec3.dot(L,d);

	if(t_ca < 0) return false;

	var LdotL = vec3.dot(L,L);
	var dpow2 = LdotL - t_ca * t_ca;
	var rpow2 = r*r;

	if(dpow2 > rpow2) return false;

	var t_hc = Math.sqrt(rpow2 - dpow2);
	var t0 = t_ca - t_hc;
	var t1 = t_ca + t_hc;

	return Math.min(t0,t1);
}

/**
 * Intersection test: Ray - Triangle ( NOT IMPLEMENTED )
 * @property {vec3} o Ray origin
 * @property {vec3} d Ray direction
 * @property {vec3} v0 Triangle vertex 0
 * @property {vec3} v1 Triangle vertex 1
 * @property {vec3} v2 Triangle vertex 2
 */
PXF.IntersectRayTriangle = function(o,d,v0,v1,v2) {

}

/** 
 * Intersection test: Ray - Plane
 * @property {vec3} o  Ray origin
 * @property {vec3} d  Ray dir
 * @property {vec3} p0 Point on plane
 * @property {vec3} n  Plane normal
 */
PXF.IntersectRayPlane = function( o,d,p0,n) {
	var tmp = vec3.create(),tmpdir = vec3.create();
	vec3.subtract(p0,o,tmp);

	var nominator = vec3.dot(tmp,n);
	var denom = vec3.dot(n,d);

	// ray is parallell to plane / on the plane
	if (denom == 0) return;

	var scaleFactor = nominator / denom;

	vec3.scale(d,scaleFactor,tmpdir);
	vec3.add(o,tmpdir,tmp);

	return tmp;
}

PXF.PointInPlane = function( plane, pt )
{
	var d = plane[0] * pt[0] + plane[1] * pt[1] + plane[2] * pt[2] + plane[3];

	if ( d < 0 ) return PXF.NEGATIVE_HALFSPACE;
	if ( d > 0 ) return PXF.POSITIVE_HALFSPACE;
	return PXF.ON_PLANE;
};

PXF.PointInAABB = function( aabb, pt )
{
	var min = aabb.min;
	var max = aabb.max;

	if ( pt[0] < min[0] || pt[0] > max[0] ) return false;
	else if ( pt[1] < min[1] || pt[1] > max[1] ) return false;
	else if ( pt[2] < min[2] || pt[2] > max[2] ) return false;

	return true;
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/Gesture.js: */

// DEPENDENCIES: /pxf.js,/core/Input.js

PXF.Gesture = {};
PXF.Gesture._defaultEvents = [
	"touch","drag","release",
    "dragstart", "dragend", "dragup", "dragdown", "dragleft", "dragright",
    "swipe", "swipeup", "swipedown", "swipeleft", "swiperight",
    "rotate", "pinch", "pinchin", "pinchout", "tap", "doubletap", "hold",
    "transform", "transformstart", "transformend" ];

PXF.Gesture.Reset = function()
{
	for( var k in this._gestureState.active )
	{
		delete this._gestureState[k];
	};

	this._gestureState.active = {};
};

PXF.Gesture.CreateEvent = function( type,x,y,id )
{
	var evt 	  = this._gestureState.NewEvent(type); 
	evt.type      = type;
	evt.clientX   = x;
	evt.clientY   = y;
	evt.pageX     = x;
	evt.pageY     = y;
	evt.which     = 1;
	evt.pointerId = id;
	evt.target 	  = this._gestureState.element;

	return evt;
}


PXF.Gesture.State = function( ctx )
{
	var st = { active : {} };

	st.Reset       = PXF.Gesture.Reset.bind(ctx);
	st.Update      = PXF.Gesture.Update.bind(ctx);
	st.CreateEvent = PXF.Gesture.CreateEvent.bind(ctx);
	st.Dispatch    = PXF.Gesture.Dispatch.bind(ctx);
	st.NewEvent    = PXF.Gesture.NewEvent.bind(ctx);

	return st;
};

PXF.Gesture.Dispatch = function( evt )
{
	if( this._gestureState.dispatcher )
	{
		this._gestureState.dispatcher.dispatchEvent.apply( this._gestureState.element, [evt] );
	}
}

PXF.Gesture.NewEvent = function(type)
{
	var evt = {};

	// todo: overshadow this function in ludei wrapper..!
	// if ( PXF.IsIOSContext() ) return evt;

	evt = this._gestureState.dispatcher.createEvent("Event");
	evt.initEvent(type, true, true );
	return evt;
}

PXF.Gesture.Update = function()
{
	var newEvent      = { timestamp : Date.now() };
	var numtouches    = dictLength( this._inputState.touches);

	var gestureStart  = false;
	var gestureEnd    = false;
	var gestureMove   = false;

	// detect gesture on/off flank
	if ( this._inputState.mouseDown )
	{
		if ( !this._gestureState.gestureStart )
		{
			this._gestureState.gestureStart = newEvent;
			gestureStart = newEvent;
		}

		if ( vec2.length( this._inputState.mouseDelta) > 0 )
		{
			gestureMove = true;
		}

	} else {
		if ( this._gestureState.gestureStart )
		{
			this._gestureState.gestureStart = undefined;
			gestureEnd = newEvent;
		};
	}

	var touchId = 0;

	// touch
	if ( gestureStart )
	{
		if ( numtouches > 0 )
		{
			for ( var t in this._inputState.touches )
			{
				var touch = this._inputState.touches[t];
				var touchEvt = this._gestureState.CreateEvent("pointerdown", touch.clientX,touch.clientY,touchId++ );

				this._gestureState.Dispatch(touchEvt);
			};
		} else this._gestureState.Dispatch(this._gestureState.CreateEvent("pointerdown", this._inputState.mousePos[0],this._inputState.mousePos[1],1)); 
		
	} else if ( gestureEnd ) {
		if ( numtouches > 0 )
		{
			for ( var t in this._inputState.touches )
			{
				var touch = this._inputState.touches[t];
				var touchEvt = this._gestureState.CreateEvent("pointerup", touch.clientX,touch.clientY,touchId++);

				this._gestureState.Dispatch(touchEvt);
			};
		} else this._gestureState.Dispatch(this._gestureState.CreateEvent("pointerup", this._inputState.mousePos[0],this._inputState.mousePos[1],1)); 
	} else if ( gestureMove ) {
		if ( numtouches > 0 )
		{
			for ( var t in this._inputState.touches )
			{
				var touch = this._inputState.touches[t];
				var touchEvt = this._gestureState.CreateEvent("pointermove", touch.clientX,touch.clientY, touchId++ );

				this._gestureState.Dispatch(touchEvt);
			};
		} else this._gestureState.Dispatch(this._gestureState.CreateEvent("pointermove", this._inputState.mousePos[0],this._inputState.mousePos[1],1)); 
	}
}

PXF.Instance.prototype.GetGestures = function()
{
	var _g = {};

	for ( var g in this._gestureState.active )
	{
		_g[g] = this._gestureState[g];
	};

	return _g;
}

PXF.Instance.prototype.SetGesture = function( listenTo, element, dispatcher, bindTo )
{
	if ( typeof Hammer == "undefined" ) console.error("[/extra/Gesture.js:156] Lib 'Hammer' not found, gesturing not available..");	
	else {
		if ( this._gestureState ) 
		{
			console.warn("[/extra/Gesture.js:160] Gesture events already bound to context");			
			return;
		};

		listenTo = listenTo || PXF.Gesture._defaultEvents;
		bindTo   = bindTo || this.canvas;

		this._gestureState = PXF.Gesture.State( this );

		// more setup code!
		this._gestureState.element    = element || document, 
		this._gestureState.dispatcher = dispatcher || document;
		this._gestureState.handler    = function(e)
		{
			this._gestureState.active[e.type] = e.gesture;
			this._gestureState[e.type]        = e.gesture;
		}.bind(this);

		// create Hammer instance and bind event listeners
		this._gestureState.hammer = Hammer(this._gestureState.element).on( listenTo.join(" "), this._gestureState.handler );

		// inject input update function
		(function(){
      		var _superReset = this.ResetInput;
			var _superUpdate = this.UpdateInput;

			this.ResetInput = function()
			{
				_superReset.apply(this,arguments);
				this._gestureState.Reset();
			};

			this.UpdateInput = function()
			{
				_superUpdate.apply(this,arguments);
				this._gestureState.Update();
			};

		}.bind(this))();
	};
};


/*
PXF.Gesture._gestureState = {};
PXF.Gesture._gestureState.active = {};

PXF.Gesture.Reset = function()
{
	for ( var k in PXF.Gesture._gestureState.active )
	{
		delete PXF.Gesture[k];
	};

	PXF.Gesture._gestureState.active = {};
}

PXF.Gesture.Set = function(element,listenTo)
{
	if (!Hammer) console.error("[/extra/Gesture.js:219] Lib 'Hammer' not found, gesture not available..");
	else {
		PXF.Gesture._gestureState.element    = element;
		PXF.Gesture._gestureState.dispatcher = element;
		PXF.Gesture._gestureState.handler    = function(e)
		{
			PXF.Gesture._gestureState.active[e.type] = e.gesture;
			PXF.Gesture[e.type]                      = e.gesture;
		};

		PXF.Gesture._gestureState.hammer = Hammer(element).on(listenTo.join(" ") || "", PXF.Gesture._gestureState.handler );
	}
}

PXF.Gesture.Dispatch = function( evt )
{
	if(PXF.Gesture._gestureState.dispatcher )
	{
		// console.log("Dispatching " + evt.type,evt);
		PXF.Gesture._gestureState.dispatcher.dispatchEvent.apply( PXF.Gesture._gestureState.element, [evt] );
	}
}

PXF.Gesture.NewEvent = function(type)
{
	var evt = {};

	if ( PXF.IsIOSContext() ) return evt;

	evt = PXF.Gesture._gestureState.element.createEvent("Event");
	evt.initEvent(type);
	return evt;
}

PXF.Gesture.CreateEvent = function( type,x,y,id )
{
	var evt 	  = PXF.Gesture.NewEvent(type); 
	evt.type      = type;
	evt.clientX   = x;
	evt.clientY   = y;
	evt.pageX     = x;
	evt.pageY     = y;
	evt.which     = 1;
	evt.pointerId = id;
	evt.target 	  = PXF.Gesture._gestureState.element;

	return evt;
}

PXF.Gesture.Update = function()
{
	PXF.Gesture.Reset();

	var newEvent      = { timestamp : Date.now() };
	var numtouches    = dictLength(PXF._inputState.touches);

	var gestureStart  = false;
	var gestureEnd    = false;
	var gestureMove   = false;

	// detect gesture on/off flank
	if ( PXF._inputState.mouseDown )
	{
		if ( !PXF.Gesture._gestureState.gestureStart )
		{
			PXF.Gesture._gestureState.gestureStart = newEvent;
			gestureStart = newEvent;
		}

		if ( vec2.length(PXF._inputState.mouseDelta) > 0 )
		{
			gestureMove = true;
		}

	} else {
		if ( PXF.Gesture._gestureState.gestureStart )
		{
			PXF.Gesture._gestureState.gestureStart = undefined;
			gestureEnd = newEvent;
		};

	}

	var touchId = 0;

	// touch
	if ( gestureStart )
	{
		if ( numtouches > 0 )
		{
			for ( var t in PXF._inputState.touches )
			{
				var touch = PXF._inputState.touches[t];
				var touchEvt = PXF.Gesture.CreateEvent("pointerdown", touch.clientX,touch.clientY,touchId++ );

				PXF.Gesture.Dispatch(touchEvt);
			};
		} else PXF.Gesture.Dispatch(PXF.Gesture.CreateEvent("pointerdown", PXF._inputState.mousePos[0],PXF._inputState.mousePos[1],1)); 
		
	} else if ( gestureEnd ) {
		if ( numtouches > 0 )
		{
			for ( var t in PXF._inputState.touches )
			{
				var touch = PXF._inputState.touches[t];
				var touchEvt = PXF.Gesture.CreateEvent("pointerup", touch.clientX,touch.clientY,touchId++);

				PXF.Gesture.Dispatch(touchEvt);
			};
		} else PXF.Gesture.Dispatch(PXF.Gesture.CreateEvent("pointerup", PXF._inputState.mousePos[0],PXF._inputState.mousePos[1],1)); 
	} else if ( gestureMove ) {
		if ( numtouches > 0 )
		{
			for ( var t in PXF._inputState.touches )
			{
				var touch = PXF._inputState.touches[t];
				var touchEvt = PXF.Gesture.CreateEvent("pointermove", touch.clientX,touch.clientY, touchId++ );

				PXF.Gesture.Dispatch(touchEvt);
			};
		} else PXF.Gesture.Dispatch(PXF.Gesture.CreateEvent("pointermove", PXF._inputState.mousePos[0],PXF._inputState.mousePos[1],1)); 
	}
}
*/


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/PlaneGeometry.js: */

// DEPENDENCIES: /scene/Geometry.js

/**
 * Creates a simple plane mesh object.
 * @constructor
 * @augments PXF.Camera
 * @param {params} Table with build parameters. Set params.segmentsWidth / params.segmentsHeight to set number of segments. Set params.width / params.height to set world-space size of plane.
 */
PXF.PlaneGeometry = function(ctx, params)
{
	var params 			= params || {};
	this.segmentsWidth 	= params.segmentsWidth 	|| 1;
	this.segmentsHeight = params.segmentsHeight || 1;

	// width / depth more accurate?
	this.width 			= params.width 	|| 1;
	this.height 		= params.height || 1;

	PXF.Geometry.call( this, ctx, params );
	this._Build();
}

PXF.PlaneGeometry.prototype = new PXF.Geometry();
PXF.PlaneGeometry.prototype.constructor = PXF.PlaneGeometry;

PXF.PlaneGeometry.prototype._Build = function() {

	var gl = this.gl;

	var vertex_buffer 	= [];
	var uv_buffer 		= [];
	var face_buffer 	= [];

	var sw = this.segmentsWidth;
	var sh = this.segmentsHeight;

	var w = this.width;
	var h = this.height;

	var w_inc = w / sw;
	var h_inc = h / sh;

	var num_verts = (sw + 1) * (sh + 1);
	var face_counter = 0;

	function set_vx(ix,x,y,z) {
		vertex_buffer[ ix     ] = x;
		vertex_buffer[ ix + 1 ] = y;
		vertex_buffer[ ix + 2 ] = z;

		ix = (ix / 3) * 2;

		uv_buffer[ ix 	  ] = x / w;
		uv_buffer[ ix + 1 ] = z / h;
	}

	// todo: center around origin
	for(var y = 0; y < sh; y++) {
		for(var x = 0; x < sw; x++) {
			var s,t;
			var f1,f2;

			// get four corners
			var top_left 	= face_counter + y;
			var top_right 	= top_left + 1;

			var bot_left 	= top_left + sw + 1;
			var bot_right 	= bot_left + 1;

			// calculate top left vertex
			var tl_ix 		= top_left * 3;
			var tr_ix 		= top_right * 3;

			var bl_ix 		= bot_left * 3;
			var br_ix 		= bot_right * 3;

			// well, you know..
			if (vertex_buffer[tl_ix] == undefined) set_vx(tl_ix,x * w_inc,0,y * h_inc);
			if (vertex_buffer[tr_ix] == undefined) set_vx(tr_ix, (x + 1) * w_inc,0,y * h_inc);

			if (vertex_buffer[bl_ix] == undefined) set_vx(bl_ix, x * w_inc,0, (y + 1) * h_inc);
			if (vertex_buffer[br_ix] == undefined) set_vx(br_ix, (x + 1) * w_inc,0, (y + 1) * h_inc);

			// face 1 
			face_buffer.push(top_left,top_right,bot_right);
			// face 2
			face_buffer.push(top_left,bot_right,bot_left);

			face_counter++;
		}		
	}

	// set buffers
	this.buffers["position"] 	= { "size" : 3, "format" : this.gl.FLOAT, "data" : vertex_buffer };
	this.buffers["uv"]       	= { "size" : 2, "format" : this.gl.FLOAT, "data" : uv_buffer };
	this.buffers["faces"]    	= { "size" : 1, "format" : this.gl.FLOAT, "elements" : true, "data" : face_buffer };

	this.BuildBuffers();
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/FullscreenPass.js: */

// DEPENDENCIES: /pxf.js

// ctx.FullscreenPass( PXF.ShaderLib.forward, { uColor : [..], uTex0 :  textureObject0 } )
PXF.Instance.prototype.FullscreenPass = function( shader, uniforms, bindbuffers ) 
{
	// setup a fs qb that will remain throughout runtime
	if(!this.__fullscreenQB)
	{
		this.__fullscreenQB = new PXF.QuadBatch( this );
		this.__fullscreenQB.Reset();
		this.__fullscreenQB.depth = -1;
		this.__fullscreenQB.AddCentered(0,0,2,2);
		this.__fullscreenQB.End();
		this.__fullscreenQB.width = this.ctxWidth;
		this.__fullscreenQB.height = this.ctxHeight;
	}

	shader.Bind();
	shader.SetUniforms( uniforms );

	this.__fullscreenQB.BindBuffers( shader, bindbuffers );
	this.__fullscreenQB.DrawBuffers( );
	this.__fullscreenQB.UnbindBuffers( shader, bindbuffers );

	shader.Unbind();
};


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/loaders/CtmLoader.js: */

// DEPENDENCIES: /pxf.js, /scene/Geometry.js, /loaders/ctm/ctm.js, /loaders/ctm/lzma.js

/**
 * Base function for loading CTM geometry (Compressed Triangle Meshes format by Marcus Geelnard)
 * @function
 * @param {WebGLContext} gl WebGL context.
 * @param {string} url Path to external file.
 * @param {function} [onComplete=undefined] Callback function that is called when the geometry has finished loading.
 */
PXF.LoadCTMGeometry = function(ctx, url, onComplete) {
    var url         = url.url || url;
    var geometry    = new PXF.Geometry( ctx );

    // callback to execute on the loaded data whenever it's finished

    var worker = PXF.GetResourceWorker();

    if ( worker !== undefined)
    {
        console.log("Dispatching worker " + worker.id);

        worker.Run( function(path) {
            console.log("CTM Loader : " + path);

            var req = new XMLHttpRequest();
            req.open("GET", path, false);
            req.responseType = "arraybuffer";
            req.send(null);

            var buffer;

            if ((req.status == 200 || req.status == 0 ) && req.response)
            {
                buffer = req.response;
            } else {
                console.error("Error while downloading file. Response: " + req.responseText);
                return;
            }

            var binarybuffer = new Uint8Array(buffer);
            console.log( "binary buffer size is " +  binarybuffer.length );


            var stream       = new CTM.Stream( binarybuffer );
            var ctmFile      = new CTM.File( stream );


            return ctmFile;
        }, function( ctmFile ) {

            PXF.LoadCTMGeometry.CreateModelBuffers( ctmFile, geometry );
            onComplete && onComplete(geometry);
            
        }, [url] );
    } else {
        console.warn("[/loaders/CtmLoader.js:56] TODO!");
    };

    /*
    var loadCallback = function( buffer ) {

        // binarybuffer = new Uint8Array(buffer);

        for ( var k in buffer ) 
        {
            console.log(k, buffer[k] );
        }

        if ( PXF.__resourceWorker )
        {
            PXF.__resourceWorker.Run( function( buffer ){
                console.log("Converting to CTM");

                for ( var k in buffer ) 
                {
                    console.log(k,buffer[k]);
                }

                var binarybuffer = new Uint8Array(buffer);
                var stream  = new CTM.Stream( binarybuffer );

                console.log(stream);

                var ctmFile = new CTM.File( stream );

            }, function() {
                console.log("Conversion complete..");
            }, [buffer] );
        } else {
            console.warn("[/loaders/CtmLoader.js:90] TODO!");
        };
        return geometry;
    }

    // PXF.LoadCTMFile( url, loadCallback );
    PXF.LoadBuffer( url, loadCallback );
    */

    return geometry;
}

/*
* Loads everything we get from file into the geo.buffers[] array.
* Then it's up to Geometry.BuildBuffers to decide what data to use.
*/
PXF.LoadCTMGeometry.CreateModelBuffers = function ( file, geo ) {
    // init GL buffers
    var vertexIndexArray    = file.body.indices,
        vertexPositionArray = file.body.vertices,
        vertexNormalArray   = file.body.normals;

    var vertexUvArray, vertexColorArray;
    var boundingMin = vec3.create( [ Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE ] ),
        boundingMax = vec3.create( [ -Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE ] );

    if ( file.body.uvMaps !== undefined && file.body.uvMaps.length > 0 ) {
        vertexUvArray = file.body.uvMaps[ 0 ].uv;
    }

    // attributes
    var attributes = {};

    attributes[ "index" ]    = { itemSize: 1, array: vertexIndexArray };
    attributes[ "position" ] = { itemSize: 3, array: vertexPositionArray };

    if ( vertexNormalArray !== undefined ) 
        attributes[ "normal" ] = { itemSize: 3, array: vertexNormalArray };

    if ( vertexUvArray !== undefined ) 
        attributes[ "uv" ] = { itemSize: 2, array: vertexUvArray };

    var reorderBuffers = function(indexBuffer, indexMap, vertexCount) {

        /* Create a copy of all attributes for reordering. */
        var sortedAttributes = {};
        var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
        for( var attr in attributes ) {
            if(attr == 'index')
                continue;
            var sourceArray = attributes[attr].array;
            for ( var i = 0, il = types.length; i < il; i++ ) {
                var type = types[i];
                if (sourceArray instanceof type) {
                    sortedAttributes[attr] = new type( attributes[attr].itemSize * vertexCount );
                    break;
                }
            }
        }

        /* Move attribute positions based on the new index map */
        for(var new_vid = 0; new_vid < vertexCount; new_vid++) {
            var vid = indexMap[new_vid];
            for ( var attr in attributes ) {
                if(attr == 'index')
                    continue;
                var attrArray = attributes[attr].array;
                var attrSize = attributes[attr].itemSize;
                var sortedAttr = sortedAttributes[attr];
                for(var k = 0; k < attrSize; k++)
                    sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
            }
        }

        /* Carry the new sorted buffers locally */
        attributes['index'].array = indexBuffer;
        for ( var attr in attributes ) {
            if(attr == 'index')
                continue;
            attributes[attr].array = sortedAttributes[attr];
            attributes[attr].numItems = attributes[attr].itemSize * vertexCount;
        }
    }

    var computeOffsets = function(indexBufferSize) {

        var size = indexBufferSize;
        if(indexBufferSize === undefined)
            size = 65535; //WebGL limits type of index buffer values to 16-bit.

        var s = Date.now();

        var indices = attributes['index'].array;
        var vertices = attributes['position'].array;

        var verticesCount = (vertices.length/3);
        var facesCount = (indices.length/3);

        var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
        var indexPtr = 0;
        var vertexPtr = 0;

        var offsets = [ { start:0, count:0, index:0 } ];
        var offset = offsets[0];

        var duplicatedVertices = 0;
        var newVerticeMaps = 0;
        var faceVertices = new Int32Array(6);
        var vertexMap = new Int32Array( vertices.length );
        var revVertexMap = new Int32Array( vertices.length );

        for(var j = 0; j < vertices.length; j++) { 
          vertexMap[j] = -1; revVertexMap[j] = -1;

          var componentId = j % 3;
          boundingMin[ componentId ] = Math.min( vertices[j], boundingMin[ componentId ] );
          boundingMax[ componentId ] = Math.max( vertices[j], boundingMax[ componentId ] );
        }

        /*
            Traverse every face and reorder vertices in the proper offsets of 65k.
            We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
        */
        for(var findex = 0; findex < facesCount; findex++) {
            newVerticeMaps = 0;

            for(var vo = 0; vo < 3; vo++) {
                var vid = indices[ findex*3 + vo ];
                if(vertexMap[vid] == -1) {
                    //Unmapped vertice
                    faceVertices[vo*2] = vid;
                    faceVertices[vo*2+1] = -1;
                    newVerticeMaps++;
                } else if(vertexMap[vid] < offset.index) {
                    //Reused vertices from previous block (duplicate)
                    faceVertices[vo*2] = vid;
                    faceVertices[vo*2+1] = -1;
                    duplicatedVertices++;
                } else {
                    //Reused vertice in the current block
                    faceVertices[vo*2] = vid;
                    faceVertices[vo*2+1] = vertexMap[vid];
                }
            }

            var faceMax = vertexPtr + newVerticeMaps;
            if(faceMax > (offset.index + size)) {
                var new_offset = { start:indexPtr, count:0, index:vertexPtr };
                offsets.push(new_offset);
                offset = new_offset;

                //Re-evaluate reused vertices in light of new offset.
                for(var v = 0; v < 6; v+=2) {
                    var new_vid = faceVertices[v+1];
                    if(new_vid > -1 && new_vid < offset.index)
                        faceVertices[v+1] = -1;
                }
            }

            //Reindex the face.
            for(var v = 0; v < 6; v+=2) {
                var vid = faceVertices[v];
                var new_vid = faceVertices[v+1];

                if(new_vid === -1)
                    new_vid = vertexPtr++;

                vertexMap[vid] = new_vid;
                revVertexMap[new_vid] = vid;
                sortedIndices[indexPtr++] = new_vid - offset.index; //XXX overflows at 16bit
                offset.count++;
            }
        }

        /* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
        reorderBuffers(sortedIndices, revVertexMap, vertexPtr);

        return offsets;
    }

    geo.offsets = computeOffsets();

    // recast CTM 32-bit indices as 16-bit WebGL indices.
    var vertexIndexArray16 = new Uint16Array( vertexIndexArray );

    // Set all buffers[] elements
    geo.buffers["index"]      = { "size" : 1, "format" : this.gl.INT, "data" : attributes["index"].array, "elements" : true};

    geo.buffers["position"]   = { "size" : 3, "format" : this.gl.FLOAT, "data" : attributes["position"].array };

    if ( vertexNormalArray !== undefined )
        geo.buffers["normal"] = { "size" : 3, "format" : this.gl.FLOAT, "data" : attributes["normal"].array };

    if ( vertexUvArray !== undefined )
        geo.buffers["uv0"]     = { "size" : 2, "format" : this.gl.FLOAT, "data" : attributes["uv"].array };

    geo.BuildBuffers( true );

    geo.boundingVolume = new PXF.BoundingVolume();
    geo.boundingVolume.min = boundingMin;
    geo.boundingVolume.max = boundingMax;
    geo.boundingVolume.SetInternals();

    vertexIndexArray16  = null;
    vertexPositionArray = null;
    vertexNormalArray   = null;
    vertexUvArray       = null;

    for ( var k in attributes )
    {
        attributes[k].array = null;
    }
};



/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/Scene.js: */

// DEPENDENCIES: /pxf.js


/**
 * Constructor for the Scene class.
 * @constructor
 * @param {WebGLContext} gl WebGL context.
 * @param {JSON} [json=undefined] Json table that describes the geometry.
 * 
 * @class Base class for Scene containers.
 * @property {JSON} geometry Geometry Objects.
 * @property {JSON} textures Texture Objects.
 * @property {JSON} materials Material Objects.
 * @property {JSON} cameras Camera Objects.
 * @property {PXF.Object} root Scene tree root object.
 */
PXF.Scene = function(ctx, json) {
	var scene 		= {}
	scene.geometry 	= {};
	scene.textures 	= {};

	extend(scene, json);

	scene.root = scene.root || new PXF.Object(ctx, scene );


	scene.Add = function( name, node ) {
		if ( typeof name == "object" ) 
		{
			node = name;
			name = guid("NewNode");
		};

		if ( node instanceof PXF.Geometry )
			this.geometry[name] = node;
		else if ( node instanceof PXF.MeshObject )
			this.root.children[name] = node;
		else if ( node instanceof PXF.Texture || node instanceof PXF.TextureCube )
			this.textures[name] = node;
		else if ( node instanceof PXF.Camera ) 
			this.cameras[name] = node;
		else if ( node instanceof PXF.Object )
			this.root.children[name] = node;
	};

	// decorate scene with functions
	scene.Walk = function( onnode, walktype ) {
		if ( !this.root ) console.warn("[/scene/Scene.js:48] PXF.Scene.Walk : No root in scene."); 
		else if ( onnode === undefined ) console.warn("[/scene/Scene.js:49] PXF.Scene.Walk : Function called with no callback");
		else {

			var __walkFunction = undefined;
			var __walkFunctionDepth = function( name, node, depth ) {
				for( var n in node.children )
					__walkFunctionDepth( n, node.children[n], depth + 1 );

				if ( onnode( name, node, depth ) ) return;
			};

			// algo from http://en.wikipedia.org/wiki/Breadth-first_search 
			var __walkFunctionBreadth = function( name, node, depth ) {
				var graphQueue = [];
					graphQueue.unshift( [name,node,depth] );

				while( graphQueue.length > 0 ) {
					var n = graphQueue.pop();

				 	if ( onnode( n[0],n[1],n[2] ) ) break;
				 	
				 	depth++;

				 	for ( var c in n[1].children ) {
				 		graphQueue.unshift( [c,n[1].children[c],depth] );
				 	}
				}
			};

			// select walk function
			switch(walktype) {
				case(PXF.BREADTH_FIRST):
					__walkFunction = __walkFunctionBreadth;
					break;
				case(PXF.DEPTH_FIRST):
				default:
					__walkFunction = __walkFunctionDepth;
					break;
			};

			__walkFunction( "root", this.root || {}, 0 );
		}
	}




	return scene;
}



/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/PrimitiveBatch.js: */

// DEPENDENCIES: /scene/Geometry.js

/**
 * Creates a PrimitiveBatch object. See subclasses {@link PXF.QuadBatch} and {@link PXF.LineBatch}.
 * @constructor
 * @augments PXF.Geometry
 * @param {WebGLContext} gl WebGL context.
 * @param {string} id Identifying string.
 * @returns {PXF.PrimitiveBatch} Returns a PXF.PrimitiveBatch, on failure returns false.
 * 
 * @class Simple PrimitiveBatch class.
 */
PXF.PrimitiveBatch = function(ctx, json)
{
	if ( !ctx ) return;

	PXF.Geometry.call( this, ctx, json );
}

PXF.PrimitiveBatch.prototype = new PXF.Geometry();
PXF.PrimitiveBatch.prototype.constructor = PXF.PrimitiveBatch;

PXF.PrimitiveBatch.prototype.Reset = function()
{
	PXF.Geometry.prototype.Reset.call(this); 
	this.depth = -5.0;
}

PXF.PrimitiveBatch.prototype.End = function()
{
	this.BuildBuffers(true);
}

PXF.PrimitiveBatch.prototype.Draw = function(shader, bindBuffers) {
	this.BindBuffers(shader, bindBuffers);
	this.DrawBuffers();
	this.UnbindBuffers(shader,bindBuffers);
};



/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/core/BoundingVolumes.js: */

// DEPENDENCIES: /pxf.js
/**
 * Calculate min/max points for a geometry object.
 * @param {PXF.Geometry} geometry Geometry object to calculate extents for.
 */
PXF.GetGeometryExtents = function( geometry ) {
	var position;

	if ( geometry instanceof PXF.Geometry )
		 position 	= geometry.buffers.position.data;
	else position 	= geometry;

	var numVerts 	= position.length / 3;

	var _min =  vec3.create([ 1e100, 1e100, 1e100]); //position.slice(0,3);
	var _max =  vec3.create([-1e100,-1e100,-1e100]); //vec3.create(_min);

	// iterate through vertices and find min and max coordinates
	for(var v = 0; v < numVerts; v++) {
		var index = v * 3;
		var x,y,z;

		x = position[index];
		y = position[index+1];
		z = position[index+2];

		_max[0] = Math.max(_max[0],x);
		_max[1] = Math.max(_max[1],y);
		_max[2] = Math.max(_max[2],z);

		_min[0] = Math.min(_min[0],x);
		_min[1] = Math.min(_min[1],y);
		_min[2] = Math.min(_min[2],z);
	}

	delete position;

	return [_max,_min];
}

PXF.BoundingVolume = function( positionData ) {
	if ( positionData !== undefined ) {
		var extents = PXF.GetGeometryExtents( positionData );
		this.min 	= extents[0];
		this.max 	= extents[1];
	}

	this.GetBoundingBox 	= function() { return { min : this.min, max : this.max, center : this.center } };
	this.GetBoundingSphere 	= function() { return { center : this.center, radius : this.radius } };

	this.SetInternals 		= function() {
		if ( !this.min || !this.max ) return;
		if ( !this.center ) this.center = vec3.create();

		var tmp = vec3.create();

		vec3.subtract( this.max,this.min,tmp);
		vec3.scale( tmp ,0.5);

		this.halfWidth 	= vec3.negate( vec3.create( tmp ) );
		this.radius 	= vec3.length( tmp );
		vec3.add(this.min,tmp,this.center);

		return this;
	};

	this.Concat	= function(other) {
		var o_min = other.min; 
		var o_max = other.max;

		var new_max = vec3.create();
		var new_min = vec3.create();

		new_min[0] 	= Math.min( this.min[0], o_min[0] );
		new_min[1] 	= Math.min( this.min[1], o_min[1] );
		new_min[2] 	= Math.min( this.min[2], o_min[2] );

		new_max[0] 	= Math.max( this.max[0], o_max[0] );
		new_max[1] 	= Math.max( this.max[1], o_max[1] );
		new_max[2] 	= Math.max( this.max[2], o_max[2] );

		return this.SetInternals();
	};

	this.Copy = function(other) {
		if ( !other || !other.min || !other.max ) return this;

		this.min = vec3.create(other.min);
		this.max = vec3.create(other.max);

		return this.SetInternals();
	}

	return this.SetInternals();
}




/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/loaders/GeometryLoader.js: */

// DEPENDENCIES: /pxf.js, /scene/Geometry.js

/**
 * Base function for loading external (JSON) geometry.
 * @function
 * @param {WebGLContext} gl WebGL context.
 * @param {string} url Path to external file.
 * @param {function} [onComplete=undefined] Callback function that is called when the geometry has finished loading.
 */
PXF.LoadGeometry = function(ctx, url, onComplete ) {
	var geometry = new PXF.Geometry( ctx );
	var loadCallback = function ( data ) {
		onComplete ? onComplete(geometry) : null;

		return geometry;
	}

	onComplete ? PXF.LoadJson( url, loadCallback ) : loadCallback(PXF.LoadJson( url ));

	return geometry;
};

/**
 * Base function for loading external (binary) geometry.
 * @function
 * @param {WebGLContext} gl WebGL context.
 * @param {JSON} json Geometry object description.
 * @param {function} [onComplete=undefined] Callback function that is called when the geometry has finished loading.
 */
PXF.LoadBinaryGeometryInterleaved = function(ctx, json, onComplete) {
	var url 		= json.url;
	var geometry 	= new PXF.GeometryInterleaved( ctx );
	var args 		= {};

	var loadCallback = function( buffer, args ) {
		// extract path
		var externalUrl = url.split(".");	
		var ext = externalUrl.length > 1 ? "." + externalUrl[1] : ""
		var base = externalUrl[0]; //.split("/").pop();

		// reconstruct new entry path
		var data 	= { getExternalPath : function(name,subBuffer) { return base + "_" + name + "_" + subBuffer + ext; } };
		var offset  = PXF.LoadBinaryGeometry.GetBinaryGeometry( ctx, buffer, data, geometry, args );

		// callback function
		onComplete ? onComplete(geometry) : null;

		return geometry;
	}


	PXF.LoadBuffer( url, loadCallback, json );

	return geometry;
}

/**
 * Base function for loading external (binary) geometry.
 * @function
 * @param {WebGLContext} gl WebGL context.
 * @param {JSON} json Geometry object description.
 * @param {function} [onComplete=undefined] Callback function that is called when the geometry has finished loading.
 */
PXF.LoadBinaryGeometry = function(ctx, json, onComplete) {
	var url 		= json.url;
	var geometry 	= new PXF.Geometry( ctx );
	var args 		= {};

	var loadCallback = function( buffer, args ) {
		// extract path
		var externalUrl = url.split(".");	
		var ext = externalUrl.length > 1 ? "." + externalUrl[1] : ""
		var base = externalUrl[0]; //.split("/").pop();

		// reconstruct new entry path
		var data 	= { getExternalPath : function(name,subBuffer) { return base + "_" + name + "_" + subBuffer + ext; } };
		var offset  = PXF.LoadBinaryGeometry.GetBinaryGeometry( ctx, buffer, data, geometry, args );

		// callback function
		onComplete ? onComplete(geometry) : null;

		return geometry;
	}


	PXF.LoadBuffer( url, loadCallback, json );

	return geometry;
}

/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.GetBinaryGeometry = function( ctx, buffer, data, geometry, json ) {
	// load header into header ptr
	var offset 	= PXF.LoadBinaryGeometry.GetBinaryHeader( buffer, data );

	// data setup
	data.entries = {};

	for ( var e = 0; e < data.entry_count; e++ ) {
		// new geometry entry
		var entry = { 
			geometry : geometry, 
			dataPtr : data 
		};

		offset += PXF.LoadBinaryGeometry.GetEntry( ctx, buffer, entry, offset, json );

		data.entries[entry.name] = entry;
	}

	return offset;
}
/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.SetEntryFromBuffer = function( buffer, entry ) {
	if (buffer.data_size <= 0) return;

	var subbufferobj 				= {};
		subbufferobj[ entry.name ]  = { 
			data 	 	: buffer.data, 
			size 	 	: entry.cmp_size,
			datasize 	: entry.num_components
		};

	// this will break if we are using other formats than float
	entry.geometry.BuildSubBuffers( subbufferobj, buffer.offset * 4);

	if ( entry.name == "position" )
	{
		var boundingVolume 	= new PXF.BoundingVolume( buffer.data );

		if ( entry.geometry.boundingVolume === undefined )
			 entry.geometry.boundingVolume = boundingVolume;
		else entry.geometry.boundingVolume.Concat( boundingVolume );
	}

	// cleanup time
	delete subbufferobj[ entry.name ].data;
	delete buffer.data;
}
/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.GLTypeLUT = function(gl, t) {
	switch(t) {
		case( this.TYPE_FLOAT16 ) : 
		case( this.TYPE_FLOAT32 ) : return gl.FLOAT;
		case( this.TYPE_INT32 ) : return gl.INT;
	}

	return 0;
}
/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.GetEntry = function( ctx, buffer, entry, offset, json ) {
	var bytesRead 	 = 0;
	var bufferOffset = 0;

	// read entry header 
	bytesRead	   	   += this.GetEntryHeader( buffer, entry, offset );
	var geometry 		= entry.geometry;

	// set geometry params
	// TODO: set params from entry dict
	var params = { 
		"size" : entry.cmp_size, 
		"format" : PXF.LoadBinaryGeometry.GLTypeLUT( ctx.gl, entry.type ), 
		"bind" : true, 
		"elements" : entry.elements ? entry.elements : false
	};

	// create buffer dict
	if ( geometry.buffers[entry.name] == undefined )
	{
		geometry.buffers[entry.name] = {};
	}

	extend(geometry.buffers[entry.name],params);

	var comp_func  		= this.COMPONENT_FUNCTION[entry.type];
	var comp_byte_cnt 	= comp_func.BYTES_PER_ELEMENT;
	var dataPtr 		= entry.dataPtr;

	// setup entry data
	entry.buffers  = [];
	entry.num_components = entry.data_size / comp_byte_cnt;

	
	
	// read all sub buffers
	for ( var b = 0; b < entry.sub_buffers; b++ ) {
		var geometryBuffer   = { };

		// read buffer header
		bytesRead 	   			+= this.GetBufferHeader( buffer, geometryBuffer, offset + bytesRead);

		// subtract header size from data size to get actual buffer data size
		geometryBuffer.read_size = geometryBuffer.data_size / comp_byte_cnt;
		geometryBuffer.offset 	 = bufferOffset;

		bufferOffset 		    += geometryBuffer.read_size;

		// extract json data
		var meta 				= json && json.meta ? json.meta[ geometryBuffer.name ] : null;

		// if (geometryBuffer.name == "position")
			// geometry.BuildWireframeBuffer(geometryBuffer.read_size);

		// handle data
		if ( geometryBuffer.external ) {
			var url = dataPtr.getExternalPath( entry.name, geometryBuffer.sub_buffer );

			( function() {
				var bufferPtr = geometryBuffer;

				var LoadBufferCallback = function(b) {
					bufferPtr.data = new comp_func( b, 0, b.byteLength / comp_byte_cnt, meta );

					PXF.LoadBinaryGeometry.SetEntryFromBuffer( bufferPtr, entry );	
					// we're done, its fun
					bufferPtr.data = undefined;
				}

				PXF.LoadBuffer( url, LoadBufferCallback );
			} )();

		} else {
			// read it like a boss
			geometryBuffer.data = new comp_func( buffer, offset + bytesRead, geometryBuffer.read_size, meta );

			// set entry data
			this.SetEntryFromBuffer( geometryBuffer, entry );

			// it's done
			geometryBuffer.data = undefined;

			// set offset pointer
			bytesRead 		 	+= geometryBuffer.data_size;
		}

		// set buffer data
		var buffer_idx 				= geometryBuffer.sub_buffer;
		entry.buffers[buffer_idx] 	= geometryBuffer;
	}

	return bytesRead;
}


/*
	BUFFER
	field:			type	value		size 	offset 		comment

	data_size		uint32 						0
	sub_buffer 		uint32  					4

	external 		uint16 						8

	name_size 		uint16						10
	name 			char[] 						12 

	data 			mixed[]						12 + name_size
*/
/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.GetBufferHeader = function( buffer, header, offset ) {
	//console.log("[/loaders/GeometryLoader.js:277] buffer header offset " + offset);

	header.data_size  = this.parseValue( Uint32Array, buffer, offset);
	header.sub_buffer = this.parseValue( Uint32Array, buffer, offset + 4);
	header.external   = this.parseValue( Uint16Array, buffer, offset + 8);
	header.name_size  = this.parseValue( Uint16Array, buffer, offset + 10);
	header.name 	  = this.parseString( buffer, offset + 12, header.name_size );
	header.size 	  = 12 + header.name_size;

	return header.size;
}

/*
DATA_ENTRY
field:			type	value		size 	offset 		comment
data_size		uint16						0
sub_buffers 	uint16						2
type 			uint16 						4
name_size 		uint16						6
name 			char[]						8

data_blob      	BUFFER[]					8 + name_size
*/
/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.GetEntryHeader = function( buffer, header, offset ) {
	header.data_size 	= this.parseValue( Uint32Array, buffer, offset);
	header.sub_buffers 	= this.parseValue( Uint32Array, buffer, offset + 4);

	header.cmp_size 	= this.parseValue( Uint16Array, buffer, offset + 8);
	header.elements 	= this.parseValue( Uint16Array, buffer, offset + 10);

	header.type 		= this.parseValue( Uint16Array, buffer, offset + 12);
	header.name_size 	= this.parseValue( Uint16Array, buffer, offset + 14);

	header.name 		= this.parseString( buffer, offset + 16 , header.name_size );
	header.size 	    = 16 + header.name_size;

	return header.size;
}
/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.GetBinaryHeader = function( buffer, header ) {
	header.pxf_identifier = this.parseString( buffer, 0, 4 );
	header.format_version = this.parseValue( Float32Array, buffer, 4);
	header.entry_count	  = this.parseValue( Uint32Array, buffer, 8 );
	header.size 	  	  = 12;

	return header.size;
}



// helper function that extracts a string

/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.parseString = function (d,offset,length) {
	var str = new Uint8Array(d,offset,length);
	var s = "";

	for(var i = 0; i < str.length; i++) {
		var c = String.fromCharCode( str[i] );

		// dont include nulls
		if( str[i] > 0)
			s += c;
	}

	return s;
}

/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.parseValue = function(fun,buffer,offset) {
	var a = this.parseArray(fun,buffer,offset,1);

	return a ? a[0] : undefined;
}

/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
PXF.LoadBinaryGeometry.parseArray = function(fun,buffer,offset,length) {
	if (!fun) {
		console.error("[/loaders/GeometryLoader.js:371] No function passed to parseArray");
		return;
	}

	offset = offset || 0;

	return length ? new fun(buffer,offset,length) : new fun(buffer,offset);
}

// type enums
PXF.LoadBinaryGeometry.TYPE_INT8 = 0;
PXF.LoadBinaryGeometry.TYPE_INT16 = 1;
PXF.LoadBinaryGeometry.TYPE_INT32 = 2;

PXF.LoadBinaryGeometry.TYPE_UINT8 = 3;
PXF.LoadBinaryGeometry.TYPE_UINT16 = 4;
PXF.LoadBinaryGeometry.TYPE_UINT32 = 5;

PXF.LoadBinaryGeometry.TYPE_FLOAT16 = 6;
PXF.LoadBinaryGeometry.TYPE_FLOAT32 = 7;
PXF.LoadBinaryGeometry.TYPE_FLOAT64 = 8;

/**
 * Internal function used by PXF.LoadBinaryGeometry
 * @function
 */
var Float16Array = function(buffer,offset,length, json) {
	var data   = new Uint16Array(buffer,offset,length);
	var f_data = new Float32Array( data.length );

	// expand to 0..1 range
    for (var i = 0; i < data.length; i++) {
        var component   = data[i];
        f_data[i]       = component / (256 * 256 - 1);

        // only expand if we are supposed to
        if ( json ) {
        	var cix = i % json.size;
			f_data[i] = f_data[i] * json.scale + json.min[cix]
        }
    };

	return f_data;
}

//Float16Array.constructor = Float16Array;
Float16Array.BYTES_PER_ELEMENT = 2;

PXF.LoadBinaryGeometry.COMPONENT_FUNCTION = [
	Int8Array,Int16Array,Int32Array,
	Uint8Array,Uint16Array,Uint32Array,
	Float16Array,Float32Array/*,Float64Array*/
]


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/GeometryInterleaved.js: */

// DEPENDENCIES: /pxf.js, /core/Utils.js

PXF.GeometryInterleaved = function(ctx, json)
{
	this.ctx = ctx;
	this.gl  = ctx.gl;
	extend(this,json);
	extend(this,{
		buffers 	  : {},
		glBuffers     : {},
		usage         : this.gl.STATIC_DRAW,
		primitiveType : this.gl.TRIANGLES,
		faceBuffer    : "",
	})

	this.ctx.AllGeometry.push(this);

	this.BuildBuffers();
};

PXF.GeometryInterleaved.prototype.constructor = PXF.GeometryInterleaved;

PXF.GeometryInterleaved.prototype.BuildSubBuffers = function( buffers, offset )
{
	console.warn("[/scene/GeometryInterleaved.js:25] GeometryInterleaved.BuildSubbuffers has not been implemented yet");

}

PXF.GeometryInterleaved.prototype.BuildBuffers = function()
{
	// allocate an arraybuffer 
	var byteArray,byteArrayViews = {},vertexbuffers = {};
	var totalByteLength = 0;
	var vertexByteLength = 0;
	var vertexCount;

	var getDataViewSetterFromType = function(t)
	{
		var stringtype = t.toString();
		var typefunc = null;

		switch(t)
		{
			case(this.gl.INT):            typefunc = DataView.prototype.setInt32; break;
			case(this.gl.UNSIGNED_INT):   typefunc = DataView.prototype.setUint32; break;
			case(this.gl.FLOAT):          typefunc = DataView.prototype.setFloat32; break;
			case(this.gl.UNSIGNED_SHORT): typefunc = DataView.prototype.setUint16; break;
			case(this.gl.SHORT):          typefunc = DataView.prototype.setInt16; break;
			case(this.gl.UNSIGNED_BYTE):  typefunc = DataView.prototype.setUint8; break;
			case(this.gl.BYTE):           typefunc = DataView.prototype.setInt8; break;
			default: console.warn("[/scene/GeometryInterleaved.js:51] Unknown gl-enum format when getting view type");
			break;
		};

		return typefunc;
	}

	var getComponentByteCount = function(e)
	{
		switch(e)
		{
			case(this.gl.INT):
			case(this.gl.UNSIGNED_INT):
			case(this.gl.FLOAT): 
				return 4;
			case(this.gl.UNSIGNED_SHORT):
			case(this.gl.SHORT):
				return 2;
			case(this.gl.UNSIGNED_BYTE):
			case(this.gl.BYTE):
				return 1;
			default:
				console.warn("[/scene/GeometryInterleaved.js:73] Unknown gl-enum format when building geometry : " + e);
				break;
		};
	};

	//////////////////////////////////////////////////////
	// prepare buffers and gather info about vertex layout
	for ( var bufferID in this.buffers ) 
	{
		if ( !this.buffers[bufferID].elements )
		{
			if(!this.glBuffers.vertexbuffer)
				this.glBuffers.vertexbuffer = this.gl.createBuffer();

			var bpp;
			var format = this.buffers[bufferID].format;
			var glFormat = format || this.gl.FLOAT;

			if ( typeof format == "string" )
				glFormat = this.gl[format.toUpperCase()];

			bpp = getComponentByteCount(glFormat);

			var componentByteLength = this.buffers[bufferID].size * bpp;
			var componentPadding    = 0;
			var componentCount 		= this.buffers[bufferID].data.length / this.buffers[bufferID].size;

			if ( componentByteLength % 4 != 0 )
			{
				componentPadding = 4 - componentByteLength % 4;
				componentByteLength += componentPadding;
			};

			var bufferByteLength = this.buffers[bufferID].data.length * componentByteLength;

			this.buffers[bufferID].bpp 				= bpp;
			this.buffers[bufferID].componentPadding = componentPadding;
			this.buffers[bufferID].glFormat 		= glFormat;
			this.buffers[bufferID].componentStart 	= vertexByteLength;

			if (!vertexCount) vertexCount = componentCount;
			if (componentCount!=vertexCount) 
				console.warn("[/scene/GeometryInterleaved.js:115] Insufficient amount of data when building interleaved geometry..");

			totalByteLength     += bufferByteLength;
			vertexByteLength 	+= componentByteLength;

			vertexbuffers[bufferID] = this.buffers[bufferID];
		} else {
			this.glBuffers.faceBuffer = this.gl.createBuffer();
			this.faceBuffer = bufferID;
		}
	};

	console.log("Total byte length will be", totalByteLength);
	console.log("Component byte length will be", vertexByteLength);

	byteArray         = new ArrayBuffer(totalByteLength);
	var uintByteArray = new Uint8Array(byteArray);
	var vertexDataView 	= new DataView(byteArray);

	////////////////////////////////////////
	// compile buffer data into array buffer
	for ( var vertexID=0;vertexID<vertexCount; vertexID++)
	{
		var vertexOffset = vertexID * vertexByteLength;

		// commit vertex data to array buffer
		for( var bufferID in vertexbuffers )
		{
			var componentSize 	= vertexbuffers[bufferID].size;
			var componentStride = vertexbuffers[bufferID].componentStart;
			var data            = vertexbuffers[bufferID].data;
			var bpp 			= vertexbuffers[bufferID].bpp;
			var dataSliceOffset = vertexID * vertexbuffers[bufferID].size;
			var dataSlice 		= data.subarray(dataSliceOffset, dataSliceOffset + componentSize); //data.slice( dataSliceOffset, dataSliceOffset + componentSize );
			var dataViewSetter 	= getDataViewSetterFromType( vertexbuffers[bufferID].glFormat );

			for ( var k =0; k<dataSlice.length; k++ )
			{
				// console.log("Setting data ", componentStride + k * bpp, dataSlice[k], dataViewSetter );
				dataViewSetter.call( vertexDataView, vertexOffset + componentStride + k * bpp, dataSlice[k] ,littleEndian );
			};
		}
	};

	if ( this.glBuffers.vertexbuffer )
	{
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.glBuffers.vertexbuffer);
		this.gl.bufferData(this.gl.ARRAY_BUFFER, uintByteArray, this.usage );
		this.drawLength = vertexCount;
	};

	if ( this.glBuffers.faceBuffer )
	{	
		var facebufferData = new Uint16Array(this.buffers[this.faceBuffer].data);
		this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.glBuffers.faceBuffer );
		this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, facebufferData, this.usage );
		this.drawLength = this.buffers[this.faceBuffer].data.length;
	};

	this.totalByteLength  = totalByteLength;
	this.vertexByteLength = vertexByteLength;
	this.vertexCount      = vertexCount;

	this.offsets = [{ start:0,index:0,count:this.drawLength}];
}

PXF.GeometryInterleaved.prototype.BindBuffers = function(shader,bindBuffers)
{
	if ( this.glBuffers.vertexbuffer )
	{
		this.gl.bindBuffer( this.gl.ARRAY_BUFFER, this.glBuffers.vertexbuffer );

		for ( var b in bindBuffers )
		{
			if ( this.buffers[b] )
			{
				shader.VertexAttrib("p", b, this.buffers[b].size, this.buffers[b].glFormat, false, this.vertexByteLength, this.buffers[b].componentStart );
			}
		}
	};

	if ( this.glBuffers.faceBuffer )
	{
		this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.glBuffers.faceBuffer);
	}
}

PXF.GeometryInterleaved.prototype.DrawBuffers = function()
{
	var drawIndexedLength = this.offsets !== undefined ? this.offsets[this.__renderIndex].count : undefined;
	var drawIndexedOffset = this.offsets !== undefined ? this.offsets[this.__renderIndex].start : undefined;
	var drawType  = PXF.DRAW_NONE;

	if ( this.glBuffers.faceBuffer )
	{
		this.gl.drawElements(this.primitiveType, drawIndexedLength, this.gl.UNSIGNED_SHORT, drawIndexedOffset );
		drawType = PXF.DRAW_ELEMENTS;
	} else {
		this.gl.drawArrays(this.primitiveType, 0, drawIndexedLength);
		drawType = PXF.DRAW_ARRAYS;
	}

	this.ctx.UpdateFrameInfo( { type : drawType, drawLength : this.drawLength, primitiveType : this.primitiveType } );		
};

PXF.GeometryInterleaved.prototype.UnbindBuffers = function(shader,bindBuffers)
{
	
};

PXF.GeometryInterleaved.prototype.Begin = function( idx )
{
	this.__renderIndex = -1;

	// force index
	if ( idx !== undefined ) {
		if ( typeof(idx) == "string" ) {
			var foundM = false;
			for( o in this.offsets )
			{
				if ( this.offsets[o].tag == idx )
				{
					this.__renderIndex 	= Number(o);
					foundM 				= true;
					break;
				};
			};

			if (!foundM) return false;

		} else if ( this.offsets[idx] !== undefined )
			this.__renderIndex = Math.max( idx, this.__renderIndex );
		else return false;
	};

	var tthis 	= this;
	var iter 	= { 
		geo  : tthis,
		next : function() {
			var geo = this.geo;

			if ( geo.offsets && geo.__renderIndex < ( geo.offsets.length-1) ) 
			{
				geo.__renderIndex++;
				return true;
			};

			geo.__renderIndex = 0; 
			return false;
		}
	}

	return iter;
}


PXF.GeometryInterleaved.prototype.Destroy = function()
{
	for ( var bufferID in this.glBuffers )
	{
		this.gl.deleteBuffer( this.glBuffers[bufferID] );
		delete this.glBuffers[bufferID];
	};
};	


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/ImageHandlers.js: */

// DEPENDENCIES: /resource/Texture.js

PXF.Texture.prototype.ImageHandlers["dds"] = function( url )
{
	// load DXT-compressed images

	var texobj = this;

	// 1. check EXT support
	var s3 	= this.ctx.CheckDXTSupport();

	if(!s3) {
		console.error("[/extra/ImageHandlers.js:13] DDS Not supported."); return;
	}

	// 2. load image data
	loadDDSTexture( s3, url, function(t) { 

		// 2.b auto-flip?

		console.log( "huh", t );

		// 3. mipmaps??????
		var data 				= t.data[0];
		texobj.compressed 		= true;
		texobj.internalFormat 	= t.internalFormat;
		texobj.SetBytesPerPixel();

		// 3. upload compressed data
		texobj.Upload( data,t.width,t.height);

		console.log("[/extra/ImageHandlers.js:32] Texture loaded: " + url);

		texobj.onComplete && texobj.onComplete( this );
	});
};


PXF.Texture.prototype.ImageHandlers["crn"] = function( url )
{
	var CRUNCH_DECODE_IN_WORKER = false;

    // Taken from crnlib.h
    var cCRNFmtInvalid = -1;

    var cCRNFmtDXT1 = 0;
    var cCRNFmtDXT3 = 1;
    var cCRNFmtDXT5 = 2;

    // Various DXT5 derivatives
    var cCRNFmtDXT5_CCxY = 3;    // Luma-chroma
    var cCRNFmtDXT5_xGxR = 4;    // Swizzled 2-component
    var cCRNFmtDXT5_xGBR = 5;    // Swizzled 3-component
    var cCRNFmtDXT5_AGBR = 6;    // Swizzled 4-component

    // ATI 3DC and X360 DXN
    var cCRNFmtDXN_XY = 7;
    var cCRNFmtDXN_YX = 8;

    // DXT5 alpha blocks only
    var cCRNFmtDXT5A = 9;
    var arrayBufferCopy = function(src, dst, dstByteOffset, numBytes) {
        var dst32Offset = dstByteOffset / 4,
            tail = (numBytes % 4),
            src32 = new Uint32Array(src.buffer, 0, (numBytes - tail) / 4),
            dst32 = new Uint32Array(dst.buffer),
            i;

        for (i = 0; i < src32.length; i++) {
            dst32[dst32Offset + i] = src32[i];
        }
        for (i = numBytes - tail; i < numBytes; i++) {
            dst[dstByteOffset + i] = src[i];
        }
    };

    var texobj = this;
    var ext = this.ctx.CheckDXTSupport();
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = "arraybuffer";
    xhr.onreadystatechange = function()
    {
    	if ((xhr.status == 200 || xhr.status == 0 ) && xhr.response)
    	{
    		var arrayBuffer = xhr.response;
            var bytes = new Uint8Array(arrayBuffer),
                srcSize = arrayBuffer.byteLength,
                src = Module._malloc(srcSize),
                format, internalFormat, dst, dstSize,
                width, height, levels, dxtData, rgb565Data, i,_width,_height;
            
            arrayBufferCopy(bytes, Module.HEAPU8, src, srcSize);

            format = Module._crn_get_dxt_format(src, srcSize);
            
            switch(format) {
                case cCRNFmtDXT1:
                    internalFormat = ext ? ext.COMPRESSED_RGB_S3TC_DXT1_EXT : null;
                    break;

                case cCRNFmtDXT3:
                    internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT3_EXT : null;
                    break;

                case cCRNFmtDXT5:
                    internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT5_EXT : null;
                    break;

                default:
                    console.error("Unsupported image format");
                    return 0;
            }

            width   = Module._crn_get_width(src, srcSize);
            height  = Module._crn_get_height(src, srcSize);
            _width  = width;
            _height = height;

            levels  = Module._crn_get_levels(src, srcSize);
            dstSize = Module._crn_get_uncompressed_size(src, srcSize, 0);
            dst 	= Module._malloc(dstSize);

            var all_data = [];

            // console.log(width+ "," + height + "," + levels);

            if(ext) {
                // Module._crn_decompress(src, srcSize, dst, dstSize);
                // dxtData = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);
                // gl.compressedTexImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, dxtData);

                // for(i = 0; i < levels; ++i) {

                    var i = 0;

                    if(i) {
                        dstSize = Module._crn_get_uncompressed_size(src, srcSize, i);
                    }

                    Module._crn_decompress(src, srcSize, dst, dstSize, i);
                    // dxtData = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);

                    all_data[i] = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);

                    // gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, width, height, 0, dxtData);
                    _width *= 0.5;
                    _height *= 0.5;
                // }
            } else {
                console.error("NOT IMPLEMENTED...");
                // if(format == cCRNFmtDXT1) {
                //     Module._crn_decompress(src, srcSize, dst, dstSize, 0);
                //     rgb565Data = dss.dxtToRgb565(Module.HEAPU16, dst / 2, width, height);
                //     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_SHORT_5_6_5, rgb565Data);
                //     if(loadMipmaps) {
                //         gl.generateMipmap(gl.TEXTURE_2D);
                //     }
                // } else {
                //     console.error("No manual decoder for format and no native support");
                //     return 0;
                // }
            }
            
            Module._free(src);
            Module._free(dst);

            texobj.compressed 		= true;
			texobj.internalFormat 	= internalFormat;
			texobj.SetBytesPerPixel();

			// 3. upload compressed data
			texobj.Upload( all_data[0], width, height );

			console.log("[/extra/ImageHandlers.js:175] Texture loaded: " + url);

			texobj.onComplete && texobj.onComplete( this );

    	};
    };

    xhr.send(null);

        // if ((xhr.status == 200 || xhr.status == 0 ) && xhr.response)
        // {   
        //     var arrayBuffer = xhr.response;
        //     var bytes = new Uint8Array(arrayBuffer),
        //         srcSize = arrayBuffer.byteLength,
        //         src = Module._malloc(srcSize),
        //         format, internalFormat, dst, dstSize,
        //         width, height, levels, dxtData, rgb565Data, i;
            
        //     arrayBufferCopy(bytes, Module.HEAPU8, src, srcSize);

        //     format = Module._crn_get_dxt_format(src, srcSize);
            
        //     switch(format) {
        //         case cCRNFmtDXT1:
        //             internalFormat = ext ? ext.COMPRESSED_RGB_S3TC_DXT1_EXT : null;
        //             break;

        //         case cCRNFmtDXT3:
        //             internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT3_EXT : null;
        //             break;

        //         case cCRNFmtDXT5:
        //             internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT5_EXT : null;
        //             break;

        //         default:
        //             console.error("Unsupported image format");
        //             return 0;
        //     }

        //     width = Module._crn_get_width(src, srcSize);
        //     height = Module._crn_get_height(src, srcSize);
        //     levels = Module._crn_get_levels(src, srcSize);
        //     dstSize = Module._crn_get_uncompressed_size(src, srcSize, 0);
        //     dst = Module._malloc(dstSize);

        //     var all_data = [];

        //     // console.log(width+ "," + height + "," + levels);

        //     if(ext) {
        //         // Module._crn_decompress(src, srcSize, dst, dstSize);
        //         // dxtData = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);
        //         // gl.compressedTexImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, dxtData);

        //         // for(i = 0; i < levels; ++i) {

        //             var i = 0;

        //             if(i) {
        //                 dstSize = Module._crn_get_uncompressed_size(src, srcSize, i);
        //             }

        //             Module._crn_decompress(src, srcSize, dst, dstSize, i);
        //             // dxtData = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);

        //             all_data[i] = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);

        //             // gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, width, height, 0, dxtData);
        //             width *= 0.5;
        //             height *= 0.5;
        //         // }
        //     } else {
        //         console.error("NOT IMPLEMENTED...");
        //         // if(format == cCRNFmtDXT1) {
        //         //     Module._crn_decompress(src, srcSize, dst, dstSize, 0);
        //         //     rgb565Data = dss.dxtToRgb565(Module.HEAPU16, dst / 2, width, height);
        //         //     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_SHORT_5_6_5, rgb565Data);
        //         //     if(loadMipmaps) {
        //         //         gl.generateMipmap(gl.TEXTURE_2D);
        //         //     }
        //         // } else {
        //         //     console.error("No manual decoder for format and no native support");
        //         //     return 0;
        //         // }
        //     }
            
        //     Module._free(src);
        //     Module._free(dst);

        //     // return all_data;

        //     // postMessage( { msgType : "requestComplete", data : all_data, batch : batch, timestamp : Date.now() } );

        //     // return all_data;

        // } else {
        //     console.error("Error while downloading file. Response: " + xhr.responseText);
        //     return;
        // }



	/*
	
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = "arraybuffer";
        xhr.send(null);

        if ((xhr.status == 200 || xhr.status == 0 ) && xhr.response)
        {   
            var arrayBuffer = xhr.response;
            var bytes = new Uint8Array(arrayBuffer),
                srcSize = arrayBuffer.byteLength,
                src = Module._malloc(srcSize),
                format, internalFormat, dst, dstSize,
                width, height, levels, dxtData, rgb565Data, i;
            
            arrayBufferCopy(bytes, Module.HEAPU8, src, srcSize);

            format = Module._crn_get_dxt_format(src, srcSize);
            
            switch(format) {
                case cCRNFmtDXT1:
                    internalFormat = ext ? ext.COMPRESSED_RGB_S3TC_DXT1_EXT : null;
                    break;

                case cCRNFmtDXT3:
                    internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT3_EXT : null;
                    break;

                case cCRNFmtDXT5:
                    internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT5_EXT : null;
                    break;

                default:
                    console.error("Unsupported image format");
                    return 0;
            }

            width = Module._crn_get_width(src, srcSize);
            height = Module._crn_get_height(src, srcSize);
            levels = Module._crn_get_levels(src, srcSize);
            dstSize = Module._crn_get_uncompressed_size(src, srcSize, 0);
            dst = Module._malloc(dstSize);

            var all_data = [];

            // console.log(width+ "," + height + "," + levels);

            if(ext) {
                // Module._crn_decompress(src, srcSize, dst, dstSize);
                // dxtData = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);
                // gl.compressedTexImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, dxtData);

                // for(i = 0; i < levels; ++i) {

                    var i = 0;

                    if(i) {
                        dstSize = Module._crn_get_uncompressed_size(src, srcSize, i);
                    }

                    Module._crn_decompress(src, srcSize, dst, dstSize, i);
                    // dxtData = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);

                    all_data[i] = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);

                    // gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, width, height, 0, dxtData);
                    width *= 0.5;
                    height *= 0.5;
                // }
            } else {
                console.error("NOT IMPLEMENTED...");
                // if(format == cCRNFmtDXT1) {
                //     Module._crn_decompress(src, srcSize, dst, dstSize, 0);
                //     rgb565Data = dss.dxtToRgb565(Module.HEAPU16, dst / 2, width, height);
                //     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_SHORT_5_6_5, rgb565Data);
                //     if(loadMipmaps) {
                //         gl.generateMipmap(gl.TEXTURE_2D);
                //     }
                // } else {
                //     console.error("No manual decoder for format and no native support");
                //     return 0;
                // }
            }
            
            Module._free(src);
            Module._free(dst);

            // return all_data;

            postMessage( { msgType : "requestComplete", data : all_data, batch : batch, timestamp : Date.now() } );
        } else {
            console.error("Error while downloading file. Response: " + xhr.responseText);
            return;
        }
    }
    */
}



/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/LineBatch.js: */

// DEPENDENCIES: /scene/PrimitiveBatch.js

// TODO: interpolation between points?

/**
 * Creates a LineBatch object, for easily rendering line primitives.
 * @constructor
 * @param {WebGLContext} gl WebGL context.
 * @param {string} id Identifying string.
 * @returns {PXF.LineBatch} Returns a PXF.LineBatch, on failure returns false.
 * 
 * @class Simple LineBatch class.
 */
PXF.LineBatch = function(ctx, params)
{
	var gl = ctx.gl;
	var params = params || {};
	params.primitiveType 	= gl.LINES;

	// extend primitiveBatch
	PXF.PrimitiveBatch.call( this, ctx, params);

	this.pointCounter = 0;
	this.lastPoint = undefined;
	
	this.buffers["position"] = { "size" : 3, "format" : gl.FLOAT, "data" : [], "bind" : true };

	this._Build();
}

PXF.LineBatch.prototype.constructor = PXF.LineBatch;

PXF.LineBatch.prototype.Reset = function()
{
	PXF.PrimitiveBatch.prototype.Reset.call(this);
	this.lastPoint = undefined; //[0,0,0];
}

/**
 * Add a raw line from point p0 to point p1.
 * @param {Object} p0 Point coordinates, should have three values (x, y, z);
 * @param {Object} p1 Point coordinates, should have three values (x, y, z);
 */
PXF.LineBatch.prototype.Add = function(p0, p1)
{
	var vert = this.buffers["position"];
	vert.data.push( p0[0], p0[1], p0[2]);

	if (p1)
	{
		vert.data.push( p1[0], p1[1], p1[2]);
	} else {
		if (this.lastPoint)
		{
			vert.data.push( this.lastPoint[0], this.lastPoint[1], this.lastPoint[2]);
		}
		
		this.lastPoint = p0;
	}
};





/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/loaders/SceneLoader.js: */

// DEPENDENCIES: /pxf.js, /scene/Scene.js, /loaders/GeometryLoader.js

PXF.LoadScene = function( ctx, url, onLoadComplete, onUpdateProgress, relative_content ) {
    console.log("[/loaders/SceneLoader.js:4] Loading scene '" + url + "'.");

    // most basic scene ever created on earth
    var scene  = PXF.Scene(); //{ init : false };
    var worker;
    var _append_path;
    if (relative_content)
    {
        _append_path = url.substring(0,url.lastIndexOf("/")+1);
    }


    if ( !window.Worker )
    {
        console.warn("[/loaders/SceneLoader.js:18] PXF.LoadScene: No Web Woker support detected");

        PXF.LoadRawFile( url, function( s )
        {
            s = s.replace("var scene = ", "");
            s = s.replace("postMessage(scene);","");

            var sceneData = JSON.parse(s);

            if (relative_content)
            {
                sceneData.dataURL = _append_path;
            }

            PXF.LoadScene.__processSceneData( ctx, scene, sceneData, onUpdateProgress );

            if(onLoadComplete) onLoadComplete(scene);
        });

    } else {
        try
        {
            worker = new Worker(url);
        } catch (e) {
            if (e instanceof DOMException) {
                if (e.code == 18) {
                    var tempdata = PXF.LoadRawFile( url );
                    var blobdata = new Blob([tempdata]);
                    worker = new Worker(window.URL.createObjectURL(blobdata));
                }
            } else {
                throw e; // bubble up
            }
        }

        worker.onmessage = function (evt) {

            var sceneData = evt.data;
            if (relative_content)
            {
                sceneData.dataURL = _append_path;
            }
            
            PXF.LoadScene.__processSceneData( ctx, scene, sceneData, onUpdateProgress );

            if(onLoadComplete) onLoadComplete(scene);
        };
    };

    return scene;
};

PXF.LoadScene.__processSceneData = function( ctx, scene, json, onUpdateProgress ) {
    
    // extend our scene-reference with json data
    extend(scene, json);

    // context
    var gl = ctx.gl;

    // resource "generators" / loading functions
    var preloadResources = { "geometry" : { res : []},"texture" : { res : []},"video" : { res : []},"audio" : { res : []} };
        preloadResources.texture.generator = function( texname, do_progress ) {
            var texload = function( texonsuccess ) {
                var onsuccess   = function(t) {
                    if ( do_progress ) {
                        resourceProgress.textures.tick(t, texname);
                    };

                    texonsuccess && texonsuccess(t);
                }

                var thisscene   = scene;
                var thistex     = texname;
                var that        = this;
                var _url        = this.url;
                if ( scene.dataURL )
                {
                    _url = scene.dataURL + _url;
                }
                var tex         = new PXF.Texture( ctx, _url, {}, onsuccess );
                var rp          = resourceProgress;
               
                thisscene.textures[texname] = tex;

                // set material bindings
                for ( var m in thisscene.materials ) 
                {
                    for (var t in thisscene.materials[m])
                    {
                        if ( thisscene.materials[m][t].constructor == Array.prototype.constructor )
                        {
                            for ( var texkey in thisscene.materials[m][t] ) {
                                if ( thisscene.materials[m][t][texkey] == texname )
                                    thisscene.materials[m][t][texkey] = tex;
                            };
                        } else  // single texture slot
                        {
                            if ( thisscene.materials[m][t] == texname )
                                thisscene.materials[m][t] = tex;
                        }
                    }
                };

            };

            return texload;
        }
        preloadResources.geometry.generator = function( geoname ) {
            var geoload = function () {
                var thisscene   = scene;
                var thisgeoname = geoname;
                var that        = this;
                var geo         = null;
                var rp          = resourceProgress;
                
                if ( this.buffers.binary ){

                    var _url = this.buffers.url;
                    if ( scene.dataURL )
                    {   
                        _url = scene.dataURL + _url;
                    }
                    this.buffers.url = _url;

                    geo = PXF.Load( ctx, this.buffers, function(g) { 
                            rp.geometry.tick(g,thisgeoname);
                            g.loaded = true;
                        });

                     // geo = PXF.LoadBinaryGeometry( ctx, this.buffers, );
                }
                else if( this.buffers.external )
                {
                    var _url = this.buffers.url;
                    if ( scene.dataURL )
                    {
                        _url = scene.dataURL + _url;
                    }
                    geo = PXF.LoadGeometry( ctx, _url, function(g) { 
                        rp.geometry.tick(g,thisgeoname); 
                        g.loaded = true;
                    });
                } else {
                    geo = new PXF.Geometry( ctx, this );
                    rp.geometry.tick(geo,thisgeoname);
                    geo.loaded = true;
                }

                thisscene.geometry[geoname]         = geo;
                thisscene.geometry[geoname].loaded  = false;
                
                for (var i = 0; i < this.buffers.length; i++) {
                    delete this.buffers[i].data;
                };
            };

            return geoload;
        }


    var _touchedTextures = {};

    // walk scene tree and flag immediate resources
    // TODO: this is hard-coded right now, but perhaps we would want custom resouce types?
    // TODO: CLEAN UP THIS MESS :()
    scene.Walk( function(name,node,depth) {
        if ( node.type == "mesh" ) {
            if ( node.geometry && scene.geometry[node.geometry] ) {

                var preloadGeometry      = scene.geometry[node.geometry];
                    preloadGeometry.load = preloadResources.geometry.generator( node.geometry );

                preloadResources.geometry.res.push( preloadGeometry );

            } else if ( node.geometry !== undefined ) 
                console.warn("[/loaders/SceneLoader.js:102] PXF.LoadScene: geometry " + node.geometry + " does not exist in scene.");
        } else if ( node.type == "lodmesh" ) {
            // flag preload only for lowest LOD
            if ( node.lodmeshes ) {

                var preloadGeometry = null;
                for( var g in node.lodmeshes ) {
                    var geo = scene.geometry[ node.lodmeshes[g] ];

                    if ( geo ) {
                        geo.load        = preloadResources.geometry.generator( node.lodmeshes[g] );
                        preloadGeometry = preloadGeometry || geo;
                    } 
                }

                // TODO: Should this behaviour always be the case or should we be able to configure how we load lods?
                // peek last lodmesh (coarsest) and set to preload
                if ( preloadGeometry )
                     preloadResources.geometry.res.push( preloadGeometry );
                else console.warn("[/loaders/SceneLoader.js:121] PXF.LoadScene: lodmesh " + name + ".lod " + preloadGeometry + " does not exist in scene.");

            } else console.warn("[/loaders/SceneLoader.js:123] PXF.LoadScene: lodmesh " + name + " does not have any lod-meshes.");
        }

        // touch textures
        if ( node.material )
        {
            for ( var t in scene.materials[node.material] )
            {
                if ( scene.textures[scene.materials[node.material][t]] )
                {
                    _touchedTextures[ scene.materials[node.material][t] ] = true;
                }
            }
        }

        /*
        if ( node.material && scene.materials[node.material]) {
            for(var t in scene.materials[node.material]) {
                var texname = scene.materials[node.material][t];
                var tLoad   = preloadResources.texture.generator( texname );
                preloadResources.texture.res.push( { load : tLoad } );

                console.log("WUT!?", node.material, texname);
            }
            
        } else if ( node.material !== undefined ) 
            console.warn("[/loaders/SceneLoader.js:135] PXF.LoadScene: material " + node.material + " does not exist in scene.");
          */
    });

    var resourceProgress = { 
        textures : { value : 0, max : preloadResources.texture.res.length }, 
        geometry : { value : 0, max : preloadResources.geometry.res.length}, 
    }

    resourceProgress.textures.tick  = function(t,msg) { resourceProgress.textures.value += 1; resourceProgress.msg = msg; onUpdateProgress && onUpdateProgress(t,resourceProgress); };
    resourceProgress.geometry.tick  = function(g,msg) { resourceProgress.geometry.value += 1; resourceProgress.msg = msg; onUpdateProgress && onUpdateProgress(g,resourceProgress); };
    resourceProgress.getProgress    = function() { return (resourceProgress.textures.value + resourceProgress.geometry.value)/(resourceProgress.textures.max + resourceProgress.geometry.max) };

    // hacket.exe :C
    scene.resourceProgress = resourceProgress;

    for ( var t in scene.textures ) {
        var tex  = scene.textures[t];
        var _url = scene.textures[t];
        
        scene.textures[t] = { url : _url, load : preloadResources.texture.generator( t, scene.preloadTextures ) };
    };

    for ( var t in _touchedTextures )
    {
        if ( scene.preloadTextures )
        {
            // console.log("[/loaders/SceneLoader.js:268] Preloading cool texture " + t );

            resourceProgress.textures.max++;

            preloadResources.texture.res.push( scene.textures[t] );
        }
    }

    for ( var m in scene.materials ) {
        var mat = scene.materials[m];
        for ( var t in mat ) {
            if ( mat[t].constructor == Array.prototype.constructor )
            {
                mat[t].end = function() { return this[this.length-1]; };
                mat[t].select = function() {
                    var bestselection = null;
                    for ( var i in this )
                    {
                        var tex = this[i];
                        if ( tex.constructor == PXF.Texture && tex.loaded )
                            bestselection = tex;
                    };

                    return bestselection;
                }
            }
        }
    }
    
    for ( var resType in preloadResources )
        for (var rID in preloadResources[resType].res ) {
            if ( preloadResources[resType].generator )
            {
                        preloadResources[resType].res[rID].load();
                        preloadResources[resType].res[rID] = null;
                delete  preloadResources[resType].res[rID];
            }
        }

    // extend scene root tree, if it exist
    if ("root" in scene) {
        scene.root = new PXF.Object( ctx, scene, scene.root );
    }

    // flag for rendering
    scene.init = true;
};



    /*
    var resourceProgress = { 
        textures : { value : 0, max : dictLength(scene.textures)}, 
        geometry : { value : 0, max : dictLength(scene.geometry)}, 
    }

    resourceProgress.textures.tick  = function(t,msg) { resourceProgress.textures.value += 1; resourceProgress.msg = msg; onUpdateProgress && onUpdateProgress(t,resourceProgress); };
    resourceProgress.geometry.tick  = function(g,msg) { resourceProgress.geometry.value += 1; resourceProgress.msg = msg; onUpdateProgress && onUpdateProgress(g,resourceProgress); };
    resourceProgress.getProgress    = function() { return (resourceProgress.textures.value + resourceProgress.geometry.value)/(resourceProgress.textures.max + resourceProgress.geometry.max) };

    ////////////////////////////////
    // extend standard scene entries

    // extend geometry nodes, if they exist
    if ("geometry" in scene) {

        for (var k in scene.geometry) {
            var geo;

            (function() {
                var geoName = k;

                if ( scene.geometry[k].buffers.binary ) {
                    geo = PXF.LoadBinaryGeometry( gl, scene.geometry[k].buffers, function(g) { resourceProgress.geometry.tick(g, geoName); });
                } else if( scene.geometry[k].buffers.external ) { 
                    geo = PXF.LoadGeometry( gl, scene.geometry[k].url, function(g) { resourceProgress.geometry.tick(g, geoName); });
                } else {
                    geo = new PXF.Geometry( gl, scene.geometry[k] );
                    resourceProgress.geometry.tick(geo, geoName);
                };
            })();

            scene.geometry[k] = geo;
        };

    }

    
    // extend camera nodes, if they exist
    if ("cameras" in scene) {

        for (var k in scene.cameras) {
            var camera = new PXF.Camera( gl, scene, scene.cameras[k] );

            if ( camera.projection == "perspective" ) {
                camera.Perspective( camera.fov, ctx.ctxWidth / ctx.ctxHeight, camera.near, camera.far)
            }

            scene.cameras[k] = camera;
        };
        
    }
    
    // extend texture nodes, if they exist
    if ("textures" in scene) {
        for (var k in scene.textures) {
            (function() {
                // replace this by using a "LoadTexture" function instead?
                var texName     = k;
                var fromScene   = scene;

                scene.textures[k]   = new PXF.Texture(gl, scene.textures[k], {}, function(t) { resourceProgress.textures.tick(t, texName); });
            })();
        };
    }

    if ("materials" in scene) {
        for (var k in scene.materials) {
            var mat = scene.materials[k];

            // set pointers
            if ( "normalmap" in mat && mat["normalmap"] in scene.textures ) {
                mat["normalmap"] = scene.textures[ mat["normalmap"] ];
            }

            if ( "diffusemap" in mat && mat["diffusemap"] in scene.textures ) {
                mat["diffusemap"] = scene.textures[ mat["diffusemap"] ];
            }           
        };
    }

    */


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/QuadBatch3D.js: */

// DEPENDENCIES: /scene/PrimitiveBatch.js

/**
 * Creates a QuadBatch object, for easily rendering quad primitives.
 * @constructor
 * @augments PXF.PrimitiveBatch
 * @param {WebGLContext} gl WebGL context.
 * @param {string} id Identifying string.
 * @returns {PXF.QuadBatch} Returns a PXF.QuadBatch, on failure returns false.
 * 
 * @class Simple QuadBatch class.
 */
PXF.QuadBatch3D = function(ctx, params)
{
	// extend primitiveBatch
	PXF.PrimitiveBatch.call( this, ctx, params);

	this.uv = [[0.0, 1.0],
	           [1.0, 1.0],
	           [1.0, 0.0],
	           [0.0, 0.0]];

	this.buffers["position"] = { "size" : 3, "format" : ctx.gl.FLOAT, "data" : [], "bind" : true };
	this.buffers["uv0"]       = { "size" : 2, "format" : ctx.gl.FLOAT, "data" : [], "bind" : true };

	//this._Build();
}

PXF.QuadBatch3D.prototype = new PXF.PrimitiveBatch();
PXF.QuadBatch3D.prototype.constructor = PXF.QuadBatch3D;

PXF.QuadBatch3D.prototype.Add = function ( v0, v1, v2, v3 )
{
	var vert = this.buffers["position"];
	var uv   = this.buffers["uv0"];

	/*
	 *  v0-v1
	 *  |a\b|
	 *  v3-v2
	 *
	 */

	// a
	vert.data.push( v0[0], v0[1], v0[2] ); // v0
	vert.data.push( v3[0], v3[1], v3[2] ); // v3
	vert.data.push( v2[0], v2[1], v2[2] ); // v2
	

	// b
	vert.data.push( v0[0], v0[1], v0[2] ); // v0
	vert.data.push( v2[0], v2[1], v2[2] ); // v2
	vert.data.push( v1[0], v1[1], v1[2] ); // v1

	// a
	uv.data.push( this.uv[0][0], this.uv[0][1]); // v0
	uv.data.push( this.uv[3][0], this.uv[3][1]); // v3
	uv.data.push( this.uv[2][0], this.uv[2][1]); // v2
	
	// b
	uv.data.push( this.uv[0][0], this.uv[0][1]); // v0
	uv.data.push( this.uv[2][0], this.uv[2][1]); // v2
	uv.data.push( this.uv[1][0], this.uv[1][1]); // v1

};

PXF.QuadBatch3D.prototype.SetCoords = function(s0, t0, s1, t1, s2, t2, s3, t3) {
	this.uv = [[s0, t0],
	           [s1, t1],
	           [s2, t2],
	           [s3, t3]];
};




/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/QuadBatch.js: */

// DEPENDENCIES: /scene/PrimitiveBatch.js

/**
 * Creates a QuadBatch object, for easily rendering quad primitives.
 * @constructor
 * @augments PXF.PrimitiveBatch
 * @param {WebGLContext} gl WebGL context.
 * @param {string} id Identifying string.
 * @returns {PXF.QuadBatch} Returns a PXF.QuadBatch, on failure returns false.
 *
 * @class Simple QuadBatch class.
 */
PXF.QuadBatch = function(ctx, json)
{
	if (ctx === undefined) return;
	
	// extend primitiveBatch
	PXF.PrimitiveBatch.call( this, ctx, json);

	this.normal = [0.0, 0.0, 1.0];
	this.uv = [[0.0, 1.0],
	           [1.0, 1.0],
	           [1.0, 0.0],
	           [0.0, 0.0]];

	if (this.glBuffers)
    {
        this.glBuffers = {};
    }

    this.BuildBuffers();
	// this.buffers["position"] 	= { "size" : 3, "format" : gl.FLOAT, "data" : [] };
	// this.buffers["normal"] 		= { "size" : 3, "format" : gl.FLOAT, "data" : [] };
	// this.buffers["uv0"]       	= { "size" : 2, "format" : gl.FLOAT, "data" : [] };

	//this._Build();
}

PXF.QuadBatch.prototype = new PXF.PrimitiveBatch();
PXF.QuadBatch.prototype.constructor = PXF.QuadBatch;

/**
 * Set QB data buffers to empty list.
 */
PXF.QuadBatch.prototype.Reset = function ()
{
    PXF.PrimitiveBatch.prototype.Reset.call(this);

    if (this.buffers === undefined)
    	this.buffers = {};

    //this.glBuffers = {};
    if (this.buffers["position"] === undefined)
    	this.buffers["position"] = { "size" : 3, "format" : this.gl.FLOAT, "data" : [] };
    else
    	this.buffers["position"].data  = [];

    if (this.buffers["normal"] === undefined)
    	this.buffers["normal"] = { "size" : 3, "format" : this.gl.FLOAT, "data" : [] };
    else
    	this.buffers["normal"].data    = [];

    if (this.buffers["uv0"] === undefined)
    	this.buffers["uv0"]      = { "size" : 2, "format" : this.gl.FLOAT, "data" : [] };
    else
    	this.buffers["uv0"].data = [];

    
    
    
}


/**
 * Add a raw quad.
 * @param {float} x0
 * @param {float} y0
 * @param {float} x1
 * @param {float} y1
 * @param {float} x2
 * @param {float} y2
 * @param {float} x3
 * @param {float} y3
 */
PXF.QuadBatch.prototype.Add = function (x0, y0, x1, y1, x2, y2, x3, y3)
{
	var vert = this.buffers["position"];
	var norm = this.buffers["normal"];
	var uv   = this.buffers["uv0"];
	var d    = this.depth;

	/*
	 *  v0-v1
	 *  |a\b|
	 *  v3-v2
	 *
	 */
	
	if (vert)
	{
		// a
		vert.data.push( x0, y0, d); // v0
		vert.data.push( x3, y3, d); // v3
		vert.data.push( x2, y2, d); // v2
		
	
		// b
		vert.data.push( x0, y0, d); // v0
		vert.data.push( x2, y2, d); // v2
		vert.data.push( x1, y1, d); // v1
	}

	if (norm)
	{
		// Normals
		// a
		norm.data.push( this.normal[0], this.normal[1], this.normal[2]); // n0
		norm.data.push( this.normal[0], this.normal[1], this.normal[2]); // n2
		norm.data.push( this.normal[0], this.normal[1], this.normal[2]); // n3
		// b
		norm.data.push( this.normal[0], this.normal[1], this.normal[2]); // n0
		norm.data.push( this.normal[0], this.normal[1], this.normal[2]); // n1
		norm.data.push( this.normal[0], this.normal[1], this.normal[2]); // n2
	}

	if (uv)
	{

		// UV
		// a
		uv.data.push( this.uv[0][0], this.uv[0][1]); // v0
		uv.data.push( this.uv[3][0], this.uv[3][1]); // v3
		uv.data.push( this.uv[2][0], this.uv[2][1]); // v2
		
		// b
		uv.data.push( this.uv[0][0], this.uv[0][1]); // v0
		uv.data.push( this.uv[2][0], this.uv[2][1]); // v2
		uv.data.push( this.uv[1][0], this.uv[1][1]); // v1
		
	}
};

/**
 * Set texture coordinates for each vertex of a quad.
 * @param {float} s0
 * @param {float} t0
 * @param {float} s1
 * @param {float} t1
 * @param {float} s2
 * @param {float} t2
 * @param {float} s3
 * @param {float} t3
 */
PXF.QuadBatch.prototype.SetCoords = function(s0, t0, s1, t1, s2, t2, s3, t3) {
	this.uv = [[s0, t0],
	           [s1, t1],
	           [s2, t2],
	           [s3, t3]];
};


PXF.QuadBatch.prototype.SetNormal = function(x, y, z) {
	this.normal = [x, y, z];
};

/**
 * Add a quad orientated at its top left corner.
 * @param {float} x
 * @param {float} y
 * @param {float} w
 * @param {float} h
 * @param {float} [r=undefined] Rotation around its top left corner, in radians.
 * @param {float} [s=undefined] Scale.
 */
PXF.QuadBatch.prototype.AddTopLeft = function (x, y, w, h, r, s)
{
	if (r)
	{
		var mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat, [x, y, 0.0]);
		mat4.rotateZ(mat, r);
		if (s)
		{
			mat4.scale(mat, [s, s, s]);
		}

		var v0 = mat4.multiplyVec3(mat, [ 0.0, 0.0, 0.0]);
		var v1 = mat4.multiplyVec3(mat, [   w, 0.0, 0.0]);
		var v2 = mat4.multiplyVec3(mat, [   w,   h, 0.0]);
		var v3 = mat4.multiplyVec3(mat, [ 0.0,   h, 0.0]);

		this.Add(v0[0], v0[1],
			     v1[0], v1[1],
			     v2[0], v2[1],
			     v3[0], v3[1]);
	} else {

		this.Add(x  , y  ,
			     x+w, y  ,
			     x+w, y+h,
			     x  , y+h);

	}
};

/**
 * Add a quad orientated at its center.
 * @param {float} x
 * @param {float} y
 * @param {float} w
 * @param {float} h
 * @param {float} [r=undefined] Rotation around the center, in radians.
 * @param {float} [s=undefined] Scale.
 */
PXF.QuadBatch.prototype.AddCentered = function (x, y, w, h, r, s)
{
	if (r)
	{
		var mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat, [x, y, 0.0]);
		mat4.rotateZ(mat, r);
		if (s)
		{
			mat4.scale(mat, [s, s, s]);
		}

		var v0 = mat4.multiplyVec3(mat, [-w/2.0, -h/2.0, 0.0]);
		var v1 = mat4.multiplyVec3(mat, [ w/2.0, -h/2.0, 0.0]);
		var v2 = mat4.multiplyVec3(mat, [ w/2.0,  h/2.0, 0.0]);
		var v3 = mat4.multiplyVec3(mat, [-w/2.0,  h/2.0, 0.0]);

		this.Add(v0[0], v0[1],
			     v1[0], v1[1],
			     v2[0], v2[1],
			     v3[0], v3[1]);
	} else {
		
		x = x - w / 2.0;
		y = y - h / 2.0;

		this.Add(x  , y  ,
			     x+w, y  ,
			     x+w, y+h,
			     x  , y+h);

	}

};




/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/CameraObject.js: */

// DEPENDENCIES: /scene/Object.js

// fixme: move
// constants
var HALF_ANG2RAD 	= 3.14159265358979323846/360.0;
var OUTSIDE 		= -1;
var INSIDE 			= 0;
var INTERSECT 		= 1;

/**
 * Constructor for the Camera class.
 * @constructor
 * @augments PXF.Object
 * @param {WebGLContext} gl WebGL context.
 * @param {PXF.Scene} scene PXF Scene to add the camera to.
 * @param {JSON} json Table with camera properties
 * 
 * @class Scene node Camera class.
 */
PXF.Camera = function(ctx, scene, json, parent ) {

	var scene = scene || {};
	var json = json || { position : vec3.create(),
	                     rotation : [0,0,0,1]
	                   };

	PXF.Object.call( this, ctx, scene, json, parent );
	
	this.lookat 	= [0, 0, 0];
	this.upVector 	= [0, 1, 0];

	//this.Type 		= "Camera";

	// projection matrix
	this.pMatrix 	= mat4.identity();

	if ( this.projection == "perspective" ) {
		this.Perspective( this.fov, 1.0, this.near, this.far)
	}
}

PXF.Camera.prototype = new PXF.Object();
PXF.Camera.prototype.constructor = PXF.Camera;

/**
 * Unprojection function, get worldspace position from screen space coordinates.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} w Width.
 * @param {number} h Height.
 */
PXF.Camera.prototype.Unproject = function(x,y,w,h) {
	var minVec 	= [x,y,0];
	var maxVec 	= [x,h - y,1];
	var dir 	= [];

	vec3.unproject(minVec,this.worldtransform,this.pMatrix,[0,0,w,h],minVec);
	vec3.unproject(maxVec,this.worldtransform,this.pMatrix,[0,0,w,h],maxVec);
	vec3.subtract(maxVec,minVec,dir);
	vec3.normalize(dir);

	return [minVec,maxVec,dir];
}

PXF.Camera.prototype.PointInFrustum = function( point ) {
	console.error("[/scene/CameraObject.js:66] PointInFrustum doesn't work..");

	var pointsInside = 0;

	for ( var p in this.frustumPlanes ) {
		var plane 	= this.frustumPlanes[p];
		var test	= PXF.PointInPlane( plane, point );
		// all_inside 	= all_inside && ( test != PXF.NEGATIVE_HALFSPACE );

		// if ( test >= 0 ) pointsInside++;

		// if ( PXF.PointInPlane( plane, point ) == PXF.NEGATIVE_HALFSPACE ) 
			// return false;
	};

	return ( pointsInside == 6 );
}


PXF.Camera.prototype.AABBInFrustum = function( aabb ) {
	console.error("[/scene/CameraObject.js:86] AABBInFrustum doesn't work..");

	return true;
}

/**
 * Unprojection function, get worldspace position from screen space coordinates.
 * @param {PXF.BoundingSphere} sphere Bounding volume with a center and a radius.
 */
PXF.Camera.prototype.SphereInFrumstum = function(sphere) {
	if(!sphere) return INSIDE;

	var prop 	= this.frumstumProperties;

	var camPos 	= prop.camPos;
	var r 		= sphere.radius;
	var near 	= this.near;
	var far 	= this.far;
	var aspect 	= this.aspect;
	var tang 	= prop.tang;

	// relative position
	var p 		= [];
	mat4.multiplyVec3(this.invtransform,sphere.center,p);

	var d;
	var az,ax,ay;

	var result = INSIDE;
	az = -p[2];

	if (az > far + r|| az < near - r) {
		return OUTSIDE;
	}

	ax = p[0];
	var x_slice = tang * az * aspect;
	dx = prop.sphereFactorX * r;

	if (ax > x_slice + dx || ax < -x_slice -dx) {
		return OUTSIDE;
	} 
	
	ay = p[1];
	var y_slice = tang * az;
	var dy = prop.sphereFactorY * r; 

	if (ay > y_slice + dy || ay < -y_slice - dy) {
		return OUTSIDE;
	}  

	// test for intersection
	if (az > far - r || az < near + r) {
		result = INTERSECT;
	}

	if (ay > y_slice - dy || ay < -y_slice + dy) {
		result = INTERSECT;
	}

	if(ax > x_slice - dx || ax < -x_slice + dx) {
		result = INTERSECT;
	}

	return result;
}

/**
 * DEPRECATED, use getPositionFromMatrix(mtx) instead.
 */
PXF.Camera.prototype.GetPositionFromMatrix = function() {
	return [this.transform[12], this.transform[13], this.transform[14]];
}

// fixme: clean this mess up
PXF.Camera.prototype.SetInternals = function() {
	// set referentials
	var X = [this.transform[0],this.transform[1],this.transform[2]];
	var Y = [this.transform[4],this.transform[5],this.transform[6]];
	var Z = [this.transform[8],this.transform[9],this.transform[10]];

	var camPos = [this.transform[12],this.transform[13],this.transform[14]];

	var angle = this.fov * HALF_ANG2RAD;
	//var anglex = angle * this.aspect;

	var tang = Math.tan(angle);

	var sphereFactorY = 1.0/Math.cos(angle);
	var tangx = Math.tan(angle * this.aspect);

	var anglex = Math.atan(tang * this.aspect);
	var sphereFactorX = 1.0/Math.cos(anglex);

	this.frumstumProperties = {
		tang: tang,
		tangx: tangx,
		X: vec3.normalize(X),
		Y: vec3.normalize(Y),
		Z: vec3.normalize(Z),
		sphereFactorX : sphereFactorX,
		sphereFactorY : sphereFactorY,
		camPos : camPos
	};
}

/**
 * Set camera to perspective projection.
 * @param {number} fov Field-of-view.
 * @param {number} aspect Camera aspect ratio, w/h of viewport.
 * @param {number} near Near plane distance.
 * @param {number} far Far plane distance.
 */
PXF.Camera.prototype.Perspective = function(fov, aspect, near, far)
{
	this.fov 	= fov;
	this.aspect = aspect;
	this.near 	= near;
	this.far 	= far;

	mat4.perspective(fov, aspect, near, far, this.pMatrix);
	this.needsUpdate = true;
};

PXF.Camera.prototype.PerspectiveSubfrustum = function( x,y,w,h,fullwidth,fullheight )
{
	if ( !this.fov || !this.near || !this.far ) console.warn("[/scene/CameraObject.js:212] PXF.Camera.PerspectiveSubfrustum failed : missing either fov/near/far..")
	else {

		this.x          = x;
		this.y          = y;
		this.fullwidth  = fullwidth;
		this.fullheight = fullheight;
		this.width      = w;
		this.height     = h;

		var aspect      = fullwidth / fullheight;
		var top         = Math.tan( (Math.PI/180) * this.fov * 0.5 ) * this.near;
		var right       = aspect * top;
		var frustumw    = right * 2;
		var frustumh    = top * 2;

		// such math
		mat4.frustum( 
			-right + this.x * frustumw / this.fullwidth, 
			-right + (this.x + this.width) * frustumw / this.fullwidth, 
			top - (this.y + this.height) * frustumh / this.fullheight, 
			top - this.y * frustumh / this.fullheight, 
			this.near, this.far, this.pMatrix );
	}
};

/**
 * Set camera to orthographic projection.
 * @param {number} left Left coordinate.
 * @param {number} right Right coordinate.
 * @param {number} top Top coordinate.
 * @param {number} bottom Bottom coordinate.
 * @param {number} near Near plane distance.
 * @param {number} far Far plane distance.
 */
PXF.Camera.prototype.Ortho = function(left, right, top, bottom, near, far)
{
	this.left 	= left;
	this.right 	= right;
	this.top 	= top;
	this.bottom = bottom;
	this.near 	= near;
	this.far 	= far;

	mat4.ortho(left, right, top, bottom, near, far, this.pMatrix);
	this.needsUpdate = true;
}





/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/MeshObject.js: */

// DEPENDENCIES: /scene/Object.js

/**
 * Constructor for the Mesh class.
 * @constructor
 * @augments PXF.Object
 * @param {string} id Name identifier.
 * @param {object} parent Scene Graph parent
 * 
 * @class Scene node Mesh class.
 */
PXF.MeshObject = function(ctx, scene, json, parent) {
	PXF.Object.call( this, ctx, scene, json, parent );

	if ( !(this.geometry instanceof PXF.Geometry ) )
    {
        // set geometry
        if ( !scene.geometry[this.geometry] )
            console.warn("[/scene/MeshObject.js:19] Could not find mesh " + this.geometry + " in scene..");
        else this.geometry   = scene.geometry[ this.geometry ];
    };

	this.type 		= "mesh";

	// set material
	this.material 	= this.material ? scene.materials[ this.material ] : null;

	// set visibility state
	this.visible 		= true;

	this.cullingTouched = -1;

	// override if we want to
	this.cullingfunction = PXF.Camera.prototype.SphereInFrumstum;
}


PXF.MeshObject.prototype = new PXF.Object();
PXF.MeshObject.prototype.constructor = PXF.MeshObject;

/**
 * Wrapper for drawing the parent geometry class.
 * @param {PXF.Shader} shader Shader that will be used to draw this object.
 * @param {JSON} bindBuffers Table that contains buffer names and a boolean that tells this function wether or not those buffers should be bound. 
 * E.g: var bindBuffers = { position : true, uv0 : false, normals : true } will bind those buffers if they are found.
 */
PXF.MeshObject.prototype.Draw = function(shader, bindBuffers) {

	if ( this.geometry.BindBuffers )
	{

		for( var it = this.geometry.Begin(); it.next(); )
        {
            this.geometry.BindBuffers( shader, bindBuffers );
            this.geometry.DrawBuffers();
            this.geometry.UnbindBuffers( shader, bindBuffers );
        } 
	};
};

PXF.MeshObject.prototype.UpdateBoundingVolume = function( ) {
	if ( !this.geometry.boundingVolume ) {
		return;
	}

	if ( !this.boundingVolume ) this.boundingVolume = new PXF.BoundingVolume();

	var volume = this.boundingVolume;
	    volume.Copy(this.geometry.boundingVolume);

    // transform all 8 corners and calculate new min/max pair
    var hw = volume.halfWidth[0]; 
    var hh = volume.halfWidth[1];
    var hd = volume.halfWidth[2];

    var corners = [];
    var newmin  = vec3.create( [ Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE] );
    var newmax  = vec3.create( [-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE] );

    corners.push( mat4.multiplyVec3( this.worldtransform, vec3.create([ volume.center[0] - hw, volume.center[1] - hh, volume.center[2] - hd ])) );
    corners.push( mat4.multiplyVec3( this.worldtransform, vec3.create([ volume.center[0] - hw, volume.center[1] - hh, volume.center[2] + hd ])) );
    corners.push( mat4.multiplyVec3( this.worldtransform, vec3.create([ volume.center[0] + hw, volume.center[1] - hh, volume.center[2] - hd ])) );
    corners.push( mat4.multiplyVec3( this.worldtransform, vec3.create([ volume.center[0] + hw, volume.center[1] - hh, volume.center[2] + hd ])) );

    corners.push( mat4.multiplyVec3( this.worldtransform, vec3.create([ volume.center[0] - hw, volume.center[1] + hh, volume.center[2] - hd ])) );
    corners.push( mat4.multiplyVec3( this.worldtransform, vec3.create([ volume.center[0] - hw, volume.center[1] + hh, volume.center[2] + hd ])) );
    corners.push( mat4.multiplyVec3( this.worldtransform, vec3.create([ volume.center[0] + hw, volume.center[1] + hh, volume.center[2] - hd ])) );
    corners.push( mat4.multiplyVec3( this.worldtransform, vec3.create([ volume.center[0] + hw, volume.center[1] + hh, volume.center[2] + hd ])) );

    for ( var c in corners )
    {
        var p = corners[c];

        newmin[0] = Math.min( newmin[0], p[0] );
        newmin[1] = Math.min( newmin[1], p[1] );
        newmin[2] = Math.min( newmin[2], p[2] );

        newmax[0] = Math.max( newmax[0], p[0] );
        newmax[1] = Math.max( newmax[1], p[1] );
        newmax[2] = Math.max( newmax[2], p[2] );
    };

    volume.min = newmin;
    volume.max = newmax;

    // calculate center + radius
	volume.SetInternals();

    return this;
};

PXF.MeshObject.prototype.IsVisible = function( camera ) 
{
	// alrady calculated
	if ( camera.touched == this.cullingTouched )
		return this.visible;	

	// perform boundingvolumetest
	if ( this.boundingVolume )
         this.visible = this.cullingfunction.call( camera, this.boundingVolume ) >= 0;
    else this.visible = true;

    // update frame timestamp
    this.cullingTouched = camera.touched;

    return this.visible;
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/AnimatedMeshObject.js: */

// DEPENDENCIES: /scene/Object.js

/**
 * DEPRECATED
 */
PXF.AnimatedMeshObject = function(id, parent, geometry, skeleton) {
	PXF.Object.call( this, id, parent );
	this.geometry 		= geometry;
	this.skeleton 		= skeleton;
	this.boneHash 		= {};
	this.boneMtxArray 	= new Float32Array(16 * this.skeleton.maxBones);
	//this.boneMtxArray_wut 	= new Float32Array(16 * this.skeleton.maxBones);

}

PXF.AnimatedMeshObject.prototype.constructor = PXF.AnimatedMeshObject;

/**
 * DEPRECATED
 */
PXF.AnimatedMeshObject.prototype.SetAnimation = function(animation) {
	this.animation = animation;
	this.animationTime	= 0;
	this.animationFrame = 0;

	//var framerate	= animation.Framerate || 24;
	//var duration 	= animation.Duration;

	//this.animationBones		= animation.Bones;
	//this.animationKeyframes = animation.Keyframes;
	
	//this.animationFreq 		= 1000/framerate;
	//this.animationMaxtime 	= this.animationFreq * duration;

	/*this.boneHash = {};
	for (b in this.animationBones) {
		this.boneHash[this.animationBones[b]] = b;
	}*/
}

/*
PXF.AnimatedMeshObject.prototype.GetKeyframePair = function(idx) {
	var keyframes = this.animationKeyframes[idx];
	var prev,next;

	for (var k = 0; k < keyframes.length; k++) {
		var kf = keyframes[k];

		if (kf.Frame == this.animationFrame) {
			prev = kf
			next = kf

			return [prev,next];
		} else if (kf.Frame > this.animationFrame) {
			var pIdx = k - 1 < 0 ? 0 : k - 1;
			var nIdx = k;

			var previousKF 	= keyframes[ pIdx ];
			var nextKF 		= keyframes[ nIdx ];

			return [previousKF,nextKF];
		}
	}
}
*/

/**
 * DEPRECATED
 */
PXF.AnimatedMeshObject.prototype.Update = function(delta) {
	PXF.Object.prototype.Update.call(this,delta);

	if(this.animation) {
		this.animationTime  = (this.animationTime + delta) % this.animation.animationMaxtime;
		this.boneMtxArray = this.animation.GetBoneMatrices(this.animationTime);
	} else {
		this.boneMtxArray = this.skeleton.bindPoseArray;
	}

	/*var bones = this.skeleton.bones;

	if(this.animation) {
		this.animationTime 		= (this.animationTime + delta) % this.animationMaxtime;
		this.animationFrame		= Math.floor( this.animationTime / this.animationFreq);
	}

	for (var i=0; i < bones.length; i++) {
		var b = bones[i];
		//var mtx = mat4.identity();
		var parent = b.Parent;
		//var mtx = //mat4.create(this.skeleton.bindPoseArray.subarray(i * 16, i * 16 + 16));

		var mtx = this.boneMtxArray.subarray(i*16,i*16+16);
		var bpos = b.Position;
		var brot = b.Rotation;
		if (parent !=undefined) {
			if (!b.worldPosition) b.worldPosition = vec3.create();
			if (!b.worldRotation) b.worldRotation = quat4.create();
			} else {
				b.worldPosition = b.Position;
				b.worldRotation = b.Rotation;
			}

		if (b && this.boneHash[b.Name] != undefined) {
			var keyframes = this.GetKeyframePair(this.boneHash[b.Name]);

			if (keyframes) {
				var previousKF = keyframes[0];
				var nextKF = keyframes[1];

				var prevTime 	= previousKF.Frame * this.animationFreq;
				var nextTime 	= nextKF.Frame * this.animationFreq;
				var diffTime 	= nextTime - prevTime;

				var relTime 	= diffTime ? (this.animationTime - prevTime) / diffTime : 0;
				var relPos 		= vec3.create();
				var relRot 		= quat4.create();

				//quat4.slerp(previousKF.Rotation,nextKF.Rotation,relTime,relRot);
				//vec3.lerp(previousKF.Position,nextKF.Position,relTime,relPos);

				//mat4.fromRotationTranslation(relRot,relPos,mtx);

				b.Position = nextKF.Position;
				b.Rotation = nextKF.Rotation;

				console.log(b.Name,b.Rotation);
			} 
		} 

		var posemtx = this.skeleton.bindInvPoseArray.subarray(16 * i, 16 * i + 16);
		//this.boneMtxArray_wut.set(mtx,i*16);
		//mat4.multiply(inv_pose_mtx, mtx, mtx);

		if (parent != undefined) {
			p = bones[parent];

			//var pMtx = this.boneMtxArray.subarray(parent*16,parent*16+16);
			//var inv_pose_pmtx = this.skeleton.bindInvPoseArray.subarray(16 * parent, 16 * parent + 16);
			//mat4.multiply(inv_pose_pmtx, pMtx, pMtx);
			//console.log(parent,pMtx);

			//mat4.multiply(pMtx,mtx,mtx);

			// Apply the parent transform to this bone


            quat4.multiplyVec3(p.worldRotation, b.Position, b.worldPosition);
            vec3.add(b.worldPosition, p.worldPosition,b.worldPosition);
            quat4.multiply(p.worldRotation, b.Rotation, b.worldRotation);

			mat4.fromRotationTranslation(b.worldRotation, b.worldPosition, mtx);
            mat4.multiply(mtx, posemtx,mtx);
		} 

		//console.log(b.Name,mtx);

	
		//console.log(b.Name,mtx);

		this.boneMtxArray.set(mtx,i*16);
	}*/

	//this.boneMtxArray = this.animation.GetBoneMatrices(this.animationTime);
}

/**
 * DEPRECATED
 */
PXF.AnimatedMeshObject.prototype.DebugDraw = function(shader) {
	// set bone matrix from skeleton
	var boneMtx =this.boneMtxArray;

	shader.SetUniform("mat4","uBones",this.boneMtxArray);

	shader.SetUniform("i","drawLines",1);
	if (!this.boneBatch) {
		this.boneBatch = new PXF.BoneBatch(this.geometry.gl);
	}

	var barr = [];

	this.boneBatch.Reset();
	for (b in this.skeleton.bones) {
		var bone = this.skeleton.bones[b];		
		var p0 = [0,0,0];
		var parent = bone.Parent;


		/*var X = [mtx[0],mtx[1],mtx[2]];
		var Y = [mtx[4],mtx[5],mtx[6]];
		var Z = [mtx[8],mtx[9],mtx[10]];
		var axisLength = 1.0;

		var xp = [],yp=[],zp=[];
		vec3.scale(X,axisLength,xp);
		vec3.add(p0,xp,xp);

		vec3.scale(Y,axisLength,yp);
		vec3.add(p0,yp,yp);

		vec3.scale(Z,axisLength,zp);
		vec3.add(p0,zp,zp);

		this.boneBatch.Add(p0,xp,[1,0,0]);
		this.boneBatch.Add(p0,yp,[0,1,0]);
		this.boneBatch.Add(p0,zp,[0,0,1]);*/
	}

	this.boneBatch.End();
	this.boneBatch.BindBuffers(shader);
	this.boneBatch.DrawBuffers();
	this.boneBatch.UnbindBuffers(shader);	

	shader.SetUniform("i","drawLines",0);
}

/**
 * DEPRECATED
 */
PXF.AnimatedMeshObject.prototype.Draw = function(shader) {
	shader.SetUniform("mat4","uBones",this.boneMtxArray);
	this.geometry.BindBuffers(shader);
	this.geometry.DrawBuffers();
	this.geometry.UnbindBuffers(shader);
};


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/BoneBatch.js: */

// DEPENDENCIES: /scene/LineBatch.js

// TODO: interpolation between points?
/**
 * DEPRECATED
 */
PXF.BoneBatch = function(gl, params)
{
	PXF.PrimitiveBatch.call( this, gl, params);

	this.pointCounter	= 0;
	this.lastPoint 		= [0,0,0];
}

PXF.BoneBatch.prototype.constructor = PXF.BoneBatch;
/**
 * DEPRECATED
 */
PXF.BoneBatch.prototype.Reset = function() {
	PXF.PrimitiveBatch.prototype.Reset.call(this);
	this.lastPoint = undefined;//[0,0,0];
	this.lastBone = 0;
}

/**
 * DEPRECATED
 */
PXF.BoneBatch.prototype.Add = function(p0, c0, bone)
{
	var vert = this.buffers.vert;
	var color = this.buffers.color;
	var bones = this.buffers.bones;
	var weights = this.buffers.weights;

	vert.push( p0[0], p0[1], p0[2]);
	color.push( c0[0], c0[1], c0[2]);
	weights.push( 1, 0, 0, 0);
	bones.push( b, 0, 0, 0);

	if (this.lastPoint)
	{
		vert.push( this.lastPoint[0], this.lastPoint[1], this.lastPoint[2]);
		color.push( c0[0], c0[1], c0[2]);
		weights.push( 0.5, 0.5, 0, 0);
		bones.push( b, this.lastBone, 0, 0);
	}
		
	this.lastPoint	= p0;
	this.lastBone 	= bone;
};





/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/BitmapFont.js: */

// DEPENDENCIES: /resource/Texture.js, /scene/QuadBatch.js, /pxf.js

PXF.BitmapFont = function( ctx, texture, char_width, default_size ) {

	this.ctx        = ctx;
	this.texture    = texture;
	this.char_width = char_width;
	this.size       = default_size;
	this.qb         = new PXF.QuadBatch(ctx);
	this.qb.depth   = 0.0;
	this.qb.SetNormal(1.0, 1.0, 1.0);

	this.labels = [];
};

PXF.BitmapFont.prototype.constructor = PXF.BitmapFont;


PXF.BitmapFont.prototype.Reset = function( ) {

	var qb = this.qb;
	qb.Reset();

};
PXF.BitmapFont.prototype.AddLabel = function( x, y, size, txt, align ) {

	var label = {
		x_f    :     x,
		x      :     x,
		y_f    :     y,
		y      :     y,
		size_f :  size,
		size   :  size,
		txt_f  :   txt,
		txt    :   txt,
		align  : align,
		recalc :  true
	};

	this.labels.push(label);

	return label;

};

PXF.BitmapFont.prototype.Recalc = function() {
	
	var qb = this.qb;

	// find out if we need to rebuild the qb
	// also recalc 
	var need_rebuild = false;
	for (var i = 0; i < this.labels.length; i++) {

		var label = this.labels[i];

		if (label.recalc)
		{
			need_rebuild = true;

			// if label x and y is functions, let them recalculate themselves
			if (typeof(label.x_f) == "function")
			{
				label.x = label.x_f(this, label);
			}

			if (typeof(label.y_f) == "function")
			{
				label.y = label.y_f(this, label);
			}

			if (typeof(label.size_f) == "function")
			{
				label.size = label.size_f(this, label);
			}

			if (typeof(label.txt_f) == "function")
			{
				label.txt = label.txt_f(this, label);
			}

			// reset recalc flag
			label.recalc = false;
		}
	};

	// need to rebuild quadbatch
	if (need_rebuild)
	{
		this.tex_delta  = (1.0 / this.texture.width) * this.size;

		qb.Reset();

		for (var i = 0; i < this.labels.length; i++) {

			var label = this.labels[i];
			var txt   = label.txt;
			var x     = label.x;
			var y     = label.y;
			var size  = label.size;
			var align = label.align;

			// calculate new x and y to compensate for alignment
			var string_len = txt.length;
			var str_size = string_len * size / this.size * this.char_width
			if (align == 1) { // right align
				x = x - str_size
			} else if (align == 0) { // center align
				x = x - str_size / 2.0
			}

			// add text quads
			var x_r = x;
			for (var i = 0; i < txt.length; i++) {
				var chr = txt.charCodeAt(i);

				// calc texture coords
				var s = (chr % this.size) * this.tex_delta;
				var t = Math.floor(chr / this.size) * this.tex_delta;

				// add quad
				qb.SetCoords(s, t, s + this.tex_delta, t, s + this.tex_delta, t + this.tex_delta, s, t + this.tex_delta)
				qb.AddCentered(x_r, y, size / this.size * this.size, size / this.size * this.size)
				
				// increase line width etc
				x_r = x_r + size / this.size * this.char_width
			}

		}

		qb.End();
	}

	

};

PXF.BitmapFont.prototype.Draw = function( override_mtx ) {

	this.Recalc();

	var qb = this.qb;
	var shader = this.ctx.Shaderlib["bitmapFont"];

	var proj_mtx = mat4.identity();
	if (override_mtx) {
		proj_mtx = mat4.create( override_mtx )
	} else {
		proj_mtx = mat4.ortho(0, ctx.ctxWidth, ctx.ctxHeight, 0, 0, 100);
	}

	mtx = proj_mtx;
	// mat4.multiply( proj_mtx, mtx, mtx );

	shader.Bind()
	shader.SetUniform("uMtx", mtx);
	this.texture.Bind(shader, "tex0", 0);
	qb.Draw(shader, { position: true, normal: true, uv0: true } );
	this.texture.Unbind();
	shader.Unbind();
	
};

PXF.BitmapFont.prototype.__DrawRaw = function( x, y, size, txt, align, override_mtx ) {
	
	var qb = this.qb;
	var shader = this.ctx.Shaderlib["bitmapFont"];

	// build text quads
	qb.Reset();
	var x_r = 0.0;
	for (var i = 0; i < txt.length; i++) {
		var chr = txt.charCodeAt(i);

		// calc texture coords
		var s = (chr % this.size) * this.tex_delta;
		var t = Math.floor(chr / this.size) * this.tex_delta;

		// add quad
		qb.SetCoords(s, t, s + this.tex_delta, t, s + this.tex_delta, t + this.tex_delta, s, t + this.tex_delta)
		qb.AddCentered(x_r, 0.0, size / this.size * this.size, size / this.size * this.size)
		
		// increase line width etc
		x_r = x_r + size / this.size * this.char_width
	}
	qb.End();

	// render text
	var mtx = mat4.identity()

	// var string_len = string.gsub(txt,"%^%d","")
	var string_len = txt.length;
	var str_size = string_len * size / this.size * this.char_width

	if (align == 1) {
		mat4.translate( mtx, [       - str_size, 0, 0], mtx );
	} else if (align == 0) {
		mat4.translate( mtx, [ - str_size / 2.0, 0, 0], mtx );
	}
	mat4.translate( mtx, [x, y, 0], mtx )

	var proj_mtx = mat4.identity();
	if (override_mtx) {
		proj_mtx = mat4.create( override_mtx )
	} else {
		proj_mtx = mat4.ortho(0, ctx.ctxWidth, ctx.ctxHeight, 0, 0, 100);
	}

	// mtx = proj_mtx;
	mat4.multiply( proj_mtx, mtx, mtx );

	shader.Bind()

	// var proj_mtx = mat4.ortho(-512, 512, 512, -512, 0, 100);
	shader.SetUniform("uMtx", mtx);
	// shader.SetUniform("i", "tex0", 0)
	// shader.SetUniform("f", "vis", vis)

	this.texture.Bind(shader, "tex0", 0);

	qb.Draw(shader, { position: true, normal: true, uv0: true } );

	this.texture.Unbind();

	shader.Unbind();



};

/*
gamefont = {}

gamefont.font_width = 8
gamefont.font_size  = 16
gamefont.font_dim   = 256

function gamefont.draw( x, y, size, txt, align, vis, be_cool, override_mtx )


		local qb = assets["font_batch"]
		local x_r = 0
		qb:Begin()

		if (vis == nil) then
			vis = 1.0
		end

        --print("gl gf1 .. error", gl.GetError())

		local color = {1,1,1}
		local waiting_color = false
		for i=1,#txt do



			-- calc uv coords
			local s = 0
			local t = 0

			local tex_delta = (1.0 / gamefont.font_dim) * gamefont.font_size
			local b = string.byte(txt, i)
			s = (b % gamefont.font_size) * tex_delta
			t = math.floor(b / gamefont.font_size) * tex_delta

			if (waiting_color) then
				if (b == string.byte("0", 1)) then
					color = {1,0,0}
				elseif b == string.byte("1", 1) then
					color = {0,1,0}
				elseif b == string.byte("2", 1) then
					color = {0,0,1}
				else
					color = {1,1,1}
				end
				--color = string

				waiting_color = false
			else

				if b == string.byte("^", 1) then
					waiting_color = true
					--print("chaning color")
				else

					local extra_y = 0
					if (be_cool) then
						extra_y = math.cos((i+be_cool)*0.8) * size*0.1
					end

					if (override_mtx) then
						--tex_delta = -tex_delta
						qb:SetCoords(s, t, s + tex_delta, t, s + tex_delta, t + tex_delta, s, t + tex_delta)
					else
						qb:SetCoords(s, t, s + tex_delta, t, s + tex_delta, t + tex_delta, s, t + tex_delta)
					end
					qb:SetNormals(color)
					if (override_mtx) then
						qb:AddCentered(x_r, extra_y, size / gamefont.font_size * gamefont.font_size, -size / gamefont.font_size * gamefont.font_size)
					else
						qb:AddCentered(x_r, extra_y, size / gamefont.font_size * gamefont.font_size, size / gamefont.font_size * gamefont.font_size)
					end
					
					x_r = x_r + size / gamefont.font_size * gamefont.font_width

				end
			end
		end
        
        --print("gl gf 2 .. error", gl.GetError())

		qb:Finish()
        
        --print("gl gf 3 .. error", gl.GetError())


		local mtx = mat4.identity()

		local string_len = string.gsub(txt,"%^%d","")
		local str_size = #string_len * size / gamefont.font_size * gamefont.font_width

		if (align == 1) then
			mat4.translate( mtx, { - str_size, 0, 0}, mtx )
		elseif (align == 0) then
			mat4.translate( mtx, { - str_size / 2.0, 0, 0}, mtx )
		end
		mat4.translate( mtx, {x, y, 0}, mtx )


		assets["font_shader"]:Bind()
		assets["font_shader"]:SetUniform("i", "flip_uv", 1)
		if (override_mtx) then
			assets["font_shader"]:SetUniform("mat4", "pmtx", override_mtx)
			--assets["font_shader"]:SetUniform("i", "flip_uv", 0)
		else
			assets["font_shader"]:SetUniform("mat4", "pmtx", mat4.ortho(0, game_w, game_h, 0, 0, 1))
		end
		assets["font_shader"]:SetUniform("mat4", "mmtx", mtx)
		assets["font_shader"]:SetUniform("i", "tex0", 0)
		assets["font_shader"]:SetUniform("f", "vis", vis)

		assets["font_texture"]:Bind(0)
        
        --print("gl gf 4 .. error", gl.GetError())


		qb:Draw(assets["font_shader"])
        
        --print("gl gf 5 .. error", gl.GetError())
		
		assets["font_texture"]:Unbind()

		assets["font_shader"]:Unbind()
        
        --print("gl gf 6 .. error", gl.GetError())

end


return gamefont

*/


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/scene/StaticLODMeshObject.js: */

// DEPENDENCIES: /scene/MeshObject.js
PXF.StaticLODMeshObject = function( ctx, scene, json, parent ) {
	if(!ctx) return;

	PXF.Object.call( this, ctx, scene, json, parent );

	this.material       = this.material ? scene.materials[ this.material ] : null;

	// store a ptr to scene for deferred loading
	this.scene 			= scene;
	this.ctx 			= ctx;
	this.gl 			= ctx.gl;
	this.lodSelection 	= PXF.INVERSE_EXPONENTIAL;
}

PXF.StaticLODMeshObject.prototype 				= new PXF.Object();
PXF.StaticLODMeshObject.prototype.constructor 	= PXF.StaticLODMeshObject;

PXF.StaticLODMeshObject.prototype.Insert = function( mesh, level, overrideDistance ) {
	if ( level === undefined )
	{
		// sort by vertex count
		console.warn("[/scene/StaticLODMeshObject.js:23] StaticLODMesh.Insert.sort not implemented");
	}

	this.lodmeshes[level] 				  	= mesh;
	this.lodmeshes[level].overrideDistance 	= overrideDistance;
}

PXF.StaticLODMeshObject.prototype.Select = function( camera ) {
	var currentSelection 	= null;
	var firstValidSelection = null;
	var numLods 		 	= this.lodmeshes.length;
	var lodStep 		 	= ( numLods + 1 );

	if ( numLods <= 0 ) {
		console.warn("[/scene/StaticLODMeshObject.js:37] PXF.StaticLODMeshObject.Select has no LODs, selecting this.geometry ptr as lvl 0.");
		if ( this.geometry ) this.lodmeshes.push(this.geometry);
	}

	var validMeshes 	= [];
	var bestSelection 	= -1;

	for(var m in this.lodmeshes)
	{	
		var lodLevel 	= m;
		var lodMesh 	= this.lodmeshes[m];
		validMeshes[m] 	= undefined;

		// try to select first valid mesh
		if ( typeof lodMesh == "string" )
		{
			if ( this.scene.geometry[lodMesh] instanceof PXF.Geometry )
			{
				console.log("[/scene/StaticLODMeshObject.js:55] Adding new mesh to self");
				this.Insert( new PXF.MeshObject( this.gl, this.scene, { geometry : lodMesh } ), lodLevel );
				lodMesh = this.lodmeshes[m];
			} else continue;
		} 

		var bv = lodMesh.boundingVolume;

		if ( !bv ) {
			if(!lodMesh.UpdateBoundingVolume()) continue;
			bv = lodMesh.boundingVolume;
		}
	
		var tmp = vec3.create();
		vec3.subtract( bv.center, camera.position, tmp );
		var distance = (vec3.length( tmp ) + bv.radius) / camera.far;

		// tween the distance curve
		switch( this.lodSelection ) 
		{
			case( PXF.LINEAR ) : break;
			case( PXF.EXPONENTIAL ) : 
				distance *= distance;
				break;
			case( PXF.INVERSE_EXPONENTAIL ) : 
				distance = 1 - ( distance - 1 )*( distance - 1 );
				break;
			default: break;
		}

		bestSelection 		= numLods - Math.floor( distance * numLods ) - 1;
		validMeshes[m] 		= lodMesh;
		lodMesh.lodDistance = distance;
    	lodMesh.lodLevel 	= m
	}

	// boundary check
	if ( bestSelection >= 0 && bestSelection < numLods )
	{
		// if best selection is a loaded mesh, return it
		if ( validMeshes[bestSelection] ) return validMeshes[bestSelection];
		else {
			var nextBestLodMesh;
			var nextToLoad;

			// best selection not found, pick second best and flag more for loading
			for (var i = 0; i < bestSelection; i++) {
				if ( validMeshes[i] !== undefined ) {

					if ( validMeshes[i].geometry.loaded )
					{
						nextBestLodMesh = validMeshes[i];	

						if ( validMeshes[i+1] && validMeshes[i+1].geometry.loaded ) continue;
						else 
						{
							if(!validMeshes[i+1])
								nextToLoad = i+1;

							break;
						}
					}
				}
			};

			if ( nextToLoad !== undefined && this.lodmeshes[nextToLoad] )
			{
				if ( typeof this.lodmeshes[nextToLoad] == "string" && this.scene.geometry[ this.lodmeshes[nextToLoad] ].load )
				{
					this.scene.geometry[ this.lodmeshes[nextToLoad] ].load();
					console.log("Loading next " + nextToLoad);
				}
			}

			return nextBestLodMesh;
		}

	}
}

PXF.StaticLODMeshObject.prototype.Draw = function( camera, shader, bindbuffer, selectonly ) {
	var mesh = this.Select(camera);

	if ( mesh && mesh.IsVisible(camera) && !selectonly )
	{
		mesh.Draw(shader,bindbuffer);
		return true;
	}
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/SimpleAxisAlignedBox.js: */

// DEPENDENCIES: /scene/QuadBatch.js

PXF.SimpleAxisAlignedBox = function( ctx )
{
	if ( !ctx ) return;

	PXF.QuadBatch.call( this, ctx, {} );

	this.Reset();

	// this.End();
}

PXF.SimpleAxisAlignedBox.prototype = new PXF.QuadBatch();
PXF.SimpleAxisAlignedBox.prototype.constructor = PXF.SimpleAxisAlignedBox;

PXF.SimpleAxisAlignedBox.prototype.AddCentered = function( x,y,z,w,h,d,inverted ) {
	// buffers
	var vert = this.buffers["position"];
	var norm = this.buffers["normal"];
	var uv   = this.buffers["uv0"];

	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
	this.h = h;
	this.d = d;

	// vectors
	var w2 = w / 2.0;
	var h2 = h / 2.0;
	var d2 = d / 2.0;

	var one   = -1.0;
	if (inverted)
	{
		one   = 1.0;
	}

	// +Z
	vert.data.push( x + w2, y + h2, z + d2*one ); // v0
	vert.data.push( x + w2, y - h2, z + d2*one ); // v1
	vert.data.push( x - w2, y - h2, z + d2*one ); // v2

	vert.data.push( x + w2, y + h2, z + d2*one ); // v0
	vert.data.push( x - w2, y - h2, z + d2*one ); // v2
	vert.data.push( x - w2, y + h2, z + d2*one ); // v3

	norm.data.push( 0.0, 0.0, -1.0 ); // v0
	norm.data.push( 0.0, 0.0, -1.0 ); // v1
	norm.data.push( 0.0, 0.0, -1.0 ); // v2

	norm.data.push( 0.0, 0.0, -1.0 ); // v0
	norm.data.push( 0.0, 0.0, -1.0 ); // v2
	norm.data.push( 0.0, 0.0, -1.0 ); // v3

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 0.0, 0.0 ); // v1
	uv.data.push( 1.0, 0.0 ); // v2

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 1.0, 0.0 ); // v2
	uv.data.push( 1.0, 1.0 ); // v3

	// -Z
	vert.data.push( x - w2, y + h2, z - d2*one ); // v0
	vert.data.push( x - w2, y - h2, z - d2*one ); // v1
	vert.data.push( x + w2, y - h2, z - d2*one ); // v2

	vert.data.push( x - w2, y + h2, z - d2*one ); // v0
	vert.data.push( x + w2, y - h2, z - d2*one ); // v2
	vert.data.push( x + w2, y + h2, z - d2*one ); // v3

	norm.data.push( 0.0, 0.0, 1.0 ); // v0
	norm.data.push( 0.0, 0.0, 1.0 ); // v1
	norm.data.push( 0.0, 0.0, 1.0 ); // v2

	norm.data.push( 0.0, 0.0, 1.0 ); // v0
	norm.data.push( 0.0, 0.0, 1.0 ); // v2
	norm.data.push( 0.0, 0.0, 1.0 ); // v3

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 0.0, 0.0 ); // v1
	uv.data.push( 1.0, 0.0 ); // v2

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 1.0, 0.0 ); // v2
	uv.data.push( 1.0, 1.0 ); // v3



	// +X
	vert.data.push( x + w2*one, y + h2, z - d2 ); // v0
	vert.data.push( x + w2*one, y - h2, z - d2 ); // v1
	vert.data.push( x + w2*one, y - h2, z + d2 ); // v2

	vert.data.push( x + w2*one, y + h2, z - d2 ); // v0
	vert.data.push( x + w2*one, y - h2, z + d2 ); // v2
	vert.data.push( x + w2*one, y + h2, z + d2 ); // v3

	norm.data.push( -1.0, 0.0, 0.0 ); // v0
	norm.data.push( -1.0, 0.0, 0.0 ); // v1
	norm.data.push( -1.0, 0.0, 0.0 ); // v2

	norm.data.push( -1.0, 0.0, 0.0 ); // v0
	norm.data.push( -1.0, 0.0, 0.0 ); // v2
	norm.data.push( -1.0, 0.0, 0.0 ); // v3

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 0.0, 0.0 ); // v1
	uv.data.push( 1.0, 0.0 ); // v2

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 1.0, 0.0 ); // v2
	uv.data.push( 1.0, 1.0 ); // v3


	// -X
	vert.data.push( x - w2*one, y + h2, z + d2 ); // v0
	vert.data.push( x - w2*one, y - h2, z + d2 ); // v1
	vert.data.push( x - w2*one, y - h2, z - d2 ); // v2

	vert.data.push( x - w2*one, y + h2, z + d2 ); // v0
	vert.data.push( x - w2*one, y - h2, z - d2 ); // v2
	vert.data.push( x - w2*one, y + h2, z - d2 ); // v3

	norm.data.push( 1.0, 0.0, 0.0 ); // v0
	norm.data.push( 1.0, 0.0, 0.0 ); // v1
	norm.data.push( 1.0, 0.0, 0.0 ); // v2

	norm.data.push( 1.0, 0.0, 0.0 ); // v0
	norm.data.push( 1.0, 0.0, 0.0 ); // v2
	norm.data.push( 1.0, 0.0, 0.0 ); // v3

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 0.0, 0.0 ); // v1
	uv.data.push( 1.0, 0.0 ); // v2

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 1.0, 0.0 ); // v2
	uv.data.push( 1.0, 1.0 ); // v3



	// +Y
	vert.data.push( x - w2, y + h2*one, z + d2 ); // v0
	vert.data.push( x - w2, y + h2*one, z - d2 ); // v1
	vert.data.push( x + w2, y + h2*one, z - d2 ); // v2

	vert.data.push( x - w2, y + h2*one, z + d2 ); // v0
	vert.data.push( x + w2, y + h2*one, z - d2 ); // v2
	vert.data.push( x + w2, y + h2*one, z + d2 ); // v3

	norm.data.push( 0.0, 1.0, 0.0 ); // v0
	norm.data.push( 0.0, 1.0, 0.0 ); // v1
	norm.data.push( 0.0, 1.0, 0.0 ); // v2

	norm.data.push( 0.0, 1.0, 0.0 ); // v0
	norm.data.push( 0.0, 1.0, 0.0 ); // v2
	norm.data.push( 0.0, 1.0, 0.0 ); // v3

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 0.0, 0.0 ); // v1
	uv.data.push( 1.0, 0.0 ); // v2

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 1.0, 0.0 ); // v2
	uv.data.push( 1.0, 1.0 ); // v3


	// -Y
	vert.data.push( x - w2, y - h2*one, z - d2 ); // v0
	vert.data.push( x - w2, y - h2*one, z + d2 ); // v1
	vert.data.push( x + w2, y - h2*one, z + d2 ); // v2

	vert.data.push( x - w2, y - h2*one, z - d2 ); // v0
	vert.data.push( x + w2, y - h2*one, z + d2 ); // v2
	vert.data.push( x + w2, y - h2*one, z - d2 ); // v3

	norm.data.push( 0.0, -1.0, 0.0 ); // v0
	norm.data.push( 0.0, -1.0, 0.0 ); // v1
	norm.data.push( 0.0, -1.0, 0.0 ); // v2

	norm.data.push( 0.0, -1.0, 0.0 ); // v0
	norm.data.push( 0.0, -1.0, 0.0 ); // v2
	norm.data.push( 0.0, -1.0, 0.0 ); // v3

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 0.0, 0.0 ); // v1
	uv.data.push( 1.0, 0.0 ); // v2

	uv.data.push( 0.0, 1.0 ); // v0
	uv.data.push( 1.0, 0.0 ); // v2
	uv.data.push( 1.0, 1.0 ); // v3
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/loaders/Loader.js: */

// DEPENDENCIES: /loaders/GeometryLoader.js, /resource/Texture.js, /loaders/SceneLoader.js

PXF.Load = function(ctx, url, onLoadComplete, params, onUpdateProgress ) {
	// silence, wench!!
	// console.log("[/loaders/Loader.js:5] Loading " + ( url || url.url ));

	function __loadResourceByUrl( ) {
		var ext 			= getExtension( url.url || url );
		var extLowerCase 	= ext.toLowerCase();

		// hm, better solution?
		switch(extLowerCase) {
			// textures 
			case "png" :
			case "jpg" :
			case "tga" : 
			case "gif" :
				return new PXF.Texture( ctx, url, params );
			// scene
			case "js"  : 
				return PXF.LoadScene( ctx, url, onLoadComplete, onUpdateProgress );
			// geometry
			case "mesh":
				return PXF.LoadGeometry( ctx, url, onLoadComplete );
			case "bin" :
				return PXF.LoadBinaryGeometry( ctx, url, onLoadComplete );
			case "ctm" :
				return PXF.LoadCTMGeometry( ctx, url, onLoadComplete );
			// shaders
			// wut 2 do :(
			default:
				console.error("[/loaders/Loader.js:32] Unidentified resource type: " + ext);
		}
	}

	return __loadResourceByUrl();
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/RoamCamera.js: */

// DEPENDENCIES: /pxf.js, /scene/CameraObject.js

PXF.RoamCamera = function(ctx, scene, json, parent ) {

    this.move_multiplier    = 0.09;
    this.move_vel           = vec3.create([0,0,0]);
    this.move_inertia       = vec3.create([0.9,0.9,0.9]);

    this.position           = vec3.create([0,0,0]);
    this.orient_multiplier  = 0.0025;
    this.orient_vel         = vec2.create([0.0, 0.0]);
    this.orient_inertia     = vec2.create([0.7, 0.7]);
    this.lookat_vec         = vec3.create();

    this.yaw                = 0.0;
    this.pitch              = 0.0;
    this.zoom               = 0.0;
    this.zoom_vel           = 0.0;
    this.auto_cycle         = true;

    this.into_path          = undefined;
    this.cycle_path         = [];
    this.scale_fact         = 100000000000;

    this.state              = undefined;
    this.stateTimer         = new Timer();
    //this.stateTimer.start();

    this.into_index         = 0;
    this.cycle_index        = 0;
    this.path_step_time     = 2;
    this.framerate          = 24;

    this.keyframes          = undefined;

    this.last_delta = 0.0;
    this.path_delta = 0.0;
    // total path time from start -> path end
    this.path_duration = 2.5; 

    // clamp mechanism
    this.max_yaw            =             0.7;
    this.min_yaw            =   -this.max_yaw;
    this.max_pitch          =             0.7;
    this.min_pitch          = -this.max_pitch;

    PXF.Camera.call( this, ctx, scene, json, parent );

    this.SetState(this.STATE_ROAM);
};


PXF.RoamCamera.prototype = new PXF.Camera();
PXF.RoamCamera.prototype.constructor = PXF.RoamCamera;

PXF.RoamCamera.prototype.STATE_ROAM         = 1;
PXF.RoamCamera.prototype.STATE_CYCLE_PATH   = 2;
PXF.RoamCamera.prototype.STATE_INTO_PATH    = 3;
PXF.RoamCamera.prototype.STATE_LOOKAT       = 4;


PXF.RoamCamera.prototype.GetLookAt = function( force_scale ) 
{
    force_scale = force_scale || this.scale_fact;

    this.SanityCheck();

    var rotmat = mat4.identity();
    mat4.rotate( rotmat,    this.yaw, [0.0, 1.0, 0.0]);
    mat4.rotate( rotmat, -this.pitch, [1.0, 0.0, 0.0]);

    var lookat_vec  = [0,0,-1];

    mat4.multiplyVec3( rotmat,lookat_vec,lookat_vec );
    vec3.scale( lookat_vec, force_scale, lookat_vec );

    // console.log("Sampling y,p", this.yaw, this.pitch, lookat_vec);

    return lookat_vec;
}

PXF.RoamCamera.prototype.SetState = function( state, force ) 
{
    if (!force && this.state == state) return;


    this.state              = state;
    this.is_new_state       = true;

    this.move_vel           = [0,0,0];
    this.orient_vel         = [0.0, 0.0];
}

PXF.RoamCamera.prototype.AddPoint = function( ) 
{
    this.cycle_path.push( [ vec3.create(this.position), this.GetLookAt(), this.path_step_time ] );
}   

PXF.RoamCamera.prototype.ClearAllPoints = function( ) 
{
    this.cycle_path = [];
}

PXF.RoamCamera.prototype.GetClosestWayPoint = function( ) 
{
    check_points    = this.compact_point_list;

    var current_pos = vec3.create(this.position);
    var min_len     = Number.MAX_VALUE;
    var min_index   = -1;
    var cmp_index   = -1;

    // find point to closest point
    for (var i = check_points.length - 1; i >= 0; i--) {
        var other_p     = check_points[i][0];
        var diff_vec    = vec3.create();

        vec3.subtract( current_pos, other_p, diff_vec );
        var diff_len    = vec3.length( diff_vec );

        if ( diff_len <= min_len ) {
            min_len     = diff_len;
            min_index   = check_points[i][2];
            cmp_index   = i;
        }
    };

    return [min_index,cmp_index];
}

PXF.RoamCamera.prototype.GetClosestCyclePoint = function( ) 
{
    var check_points    = this.cycle_path;

    if ( this.compact_point_list !== undefined ) check_points = this.compact_point_list;

    var current_pos = vec3.create(this.position);
    var min_len     = Number.MAX_VALUE;
    var min_index   = -1;
    var cmp_index   = -1;

    // find point to closest point
    for (var i = check_points.length - 1; i >= 0; i--) {
        var other_p     = check_points[i][0];
        var diff_vec    = vec3.create();

        vec3.subtract( current_pos, other_p, diff_vec );
        var diff_len    = vec3.length( diff_vec );

        if ( diff_len <= min_len ) {
            min_len     = diff_len;
            min_index   = check_points[i][2];
            cmp_index   = i;
        }
    };

    return [min_index,cmp_index];
}

PXF.RoamCamera.prototype.CatmullRom = function( factor, point_0, point_1, point_2, point_3 )
{
    var res = [];//vec3.create();
    var t   = factor;
    var t2  = t * t;
    var t3  = t2 * t;

    for(var c=0; c < point_0.length; c++) {

        var p0 = point_0[c];
        var p1 = point_1[c];
        var p2 = point_2[c];
        var p3 = point_3[c];
        res[c] = 0.5 * ( (2 * p1) +
                         (-p0 + p2) * t +
                         (2*p0 - 5*p1 + 4*p2 - p3) * t2 +
                         (-p0 + 3*p1 - 3*p2 + p3) * t3);
    }


    return res;
}

PXF.RoamCamera.prototype.CatmullRomQuat = function( factor, point_0, point_1, point_2, point_3 )
{
    var res = [];//vec3.create();
    var t   = factor;
    var t2  = t * t;
    var t3  = t2 * t;

    if (quat4.dot(point_0, point_1) < 0)
    {
        point_1 = quat4.create(point_1);
        quat4.scale(point_1, -1.0, point_1);
    }

    if (quat4.dot(point_1, point_2) < 0)
    {
        point_2 = quat4.create(point_2);
        quat4.scale(point_2, -1.0, point_2);
    }

    if (quat4.dot(point_2, point_3) < 0)
    {
        point_3 = quat4.create(point_3);
        quat4.scale(point_3, -1.0, point_3);
    }

    for(var c=0; c < point_0.length; c++) {

        var p0 = point_0[c];
        var p1 = point_1[c];
        var p2 = point_2[c];
        var p3 = point_3[c];
        res[c] = 0.5 * ( (2 * p1) +
                         (-p0 + p2) * t +
                         (2*p0 - 5*p1 + 4*p2 - p3) * t2 +
                         (-p0 + 3*p1 - 3*p2 + p3) * t3);
    }


    return res;
}

PXF.RoamCamera.prototype.SanityCheck = function( ) 
{
    if (this.pitch < 0) { this.pitch = 2 * Math.PI + this.pitch; } 
    else if(this.pitch >= 2 * Math.PI) { this.pitch = this.pitch - 2 * Math.PI; } 

    if (this.yaw < 0) { this.yaw = 2 * Math.PI + this.yaw; } 
    else if(this.yaw >= 2 * Math.PI) { this.yaw = this.yaw - 2 * Math.PI; } 
}

PXF.RoamCamera.prototype.SetYawPitch = function() {

    var rotmat      = mat3.identity();
    var transmat    = mat4.identity();


    var dir_vec     = [0,0,-1];

    mat4.toMat3( this.transform, rotmat );
    mat3.multiplyVec3( rotmat, dir_vec, dir_vec );


    var         x = dir_vec[0],
                y = dir_vec[1],
                z = dir_vec[2];

    var yaw     = Math.atan( x / z ),
        pitch   = -Math.atan2( this.transform[6],this.transform[10] );

    var add_rot = 0;
    var half_pi = Math.PI * 0.5;

    // console.log("Dir vec", dir_vec);

    if ( z < 0 && x > 0) {
        // console.log("+x -z")
        // yaw = Math.PI - yaw;
    }
    else if ( z < 0 && x < 0) {
        // console.log("-x -z");
        // yaw = Math.PI + yaw;
    }
    else if ( z > 0 && x < 0) {
        // console.log("-x +z")
        yaw     += Math.PI;
        pitch   += Math.PI;
    } 
    else if ( z > 0 && x > 0 ) {
        // console.log( "+x +x");
        yaw     += Math.PI;
        pitch   -= Math.PI;
    }

    this.yaw        = yaw; 
    this.pitch      = pitch;

    this.SanityCheck();
}

PXF.RoamCamera.prototype.Tween = function( t ) 
{
    /*
    var t = this.path_time_tot / this.path_duration;
    if ( t >= 1 ) return 1;
    */

    // return this.path_time_tot / this.path_duration;

    //var t = this.path_time_tot / this.path_duration * 2;
    t = t * 2;

    if ( t >= 2 ) return 1;

    if (t < 1) return ( 1/2 ) * Math.pow( t, 2 );
    else return (-1/2) * ((t-1) * (t-3) - 1);

    // return -1 * ( t * ( t - 2) );
}

PXF.RoamCamera.prototype.Update = function( dt, recurse_depth ) 
{
    // recurse_depth = recurse_depth === undefined ? 0 : recurse_depth;

    var old_lookat    = vec3.create(this.lookat);
    var old_position  = vec3.create(this.position);
    var oldpitch      = this.pitch;

    if (dt != undefined && recurse_depth < 5)

        this.orienting  = false;
        this.moving     = false;

        switch(this.state) {

            case this.STATE_LOOKAT:
            {
                var norm_dt = 1;

                this.yaw   += this.orient_vel[0] * norm_dt;
                this.pitch += this.orient_vel[1] * norm_dt;

                this.orient_vel[0] *= this.orient_inertia[0] * norm_dt;
                this.orient_vel[1] *= this.orient_inertia[1] * norm_dt;

                this.zoom     += this.zoom_vel;
                this.zoom_vel *= this.move_inertia[0]

                this.zoom = Math.max( 0, this.zoom );

                this.Identity();
                this.Rotate( -this.yaw, 0.0, 1.0, 0.0); // yaw
                this.Rotate( -this.pitch, 1.0, 0.0, 0.0); // pitch
                this.Translate( 0.0, 0.0, this.zoom ); // zoom

                this.lookat = vec3.create( this.lookat_vec );
                // this.lookat_vec = vec3.create();
                // var to_lookat = vec3.create();
                // vec3.subtract( this.lookat, getPositionFromMatrix(this.worldtransform), to_lookat );

                var lookatmat = mat4.identity();
                lookatmat[12] = this.lookat[0];
                lookatmat[13] = this.lookat[1];
                lookatmat[14] = this.lookat[2];

                mat4.multiply( lookatmat, this.transform, this.transform  );

            } break;
            case this.STATE_ROAM:
            {

                var norm_dt = 1.0;//Math.min(2.0, (dt / 0.016));
                // var norm_dt = dt * 20.0;//Math.min(2.0, (dt / 0.016));
                this.yaw   += this.orient_vel[0] * norm_dt;
                this.pitch += this.orient_vel[1] * norm_dt;

                this.orient_vel[0] *= this.orient_inertia[0] * norm_dt;
                this.orient_vel[1] *= this.orient_inertia[1] * norm_dt;

                if (vec2.length(this.orient_vel) > 0.0000000000001) {
                    this.orienting = true;
                } else {
                    this.orienting = false;
                }

                if ( this.restrict_orientation )
                {
                  var testpitch = this.pitch - Math.PI;

                  if ( testpitch < 0 && testpitch > ( -Math.PI / 2 )) this.pitch = Math.PI / 2;
                  else if ( testpitch > 0 && testpitch < ( Math.PI / 2 )) this.pitch = 1.5 * Math.PI;
                }

                this.SanityCheck();

                var rotmat = mat4.identity();
                mat4.rotate( rotmat,    this.yaw, [0.0, 1.0, 0.0]);
                mat4.rotate( rotmat, -this.pitch, [1.0, 0.0, 0.0]);

                // calculate new position
                var t_vel = vec3.create(this.move_vel);
                vec3.multiply(t_vel, [norm_dt, norm_dt, norm_dt], t_vel);
                vec3.add( this.position, t_vel, this.position );

                // apply inertia to the velocity vector
                var t_inert = vec3.create( this.move_inertia );
                vec3.multiply(t_inert, [norm_dt, norm_dt, norm_dt], t_inert);
                vec3.multiply( this.move_vel, t_inert, this.move_vel );

                if (vec3.length(this.move_vel) > 0.0000000000001) {
                    this.moving = true;
                } else {
                    this.moving = false;
                }

                // create translation matrix
                var transmat = mat4.identity();
                mat4.translate( transmat, this.position );

                // reset matrices and apply translation 
                this.Identity();
                mat4.multiply( this.transform, transmat );
                mat4.multiply( this.transform, rotmat );

            } break;

            case this.STATE_INTO_PATH:
            {
                if (this.into_path.length <= 0) { 
                    console.log("Into path < 0");
                    this.SetState( this.STATE_ROAM );
                }
                else {
                    if ( this.is_new_state )
                    { 
                        this.into_index     = 1;
                        this.path_delta     = 0;
                        this.path_length    = 0;
                        this.path_tot_delta = 0;
                        this.path_time      = 0;
                        this.path_time_tot  = 0;
                        this.position_old   = vec3.create(this.position);
                    }


                    function __calc( __dt )
                    {
                        this.path_time      += __dt;
                        this.path_time_tot  += __dt;

                        var update_value    = this.Tween(this.path_time_tot / this.path_duration); // ease value between 0..1 on path
                        var time_min        = 0;
                        var time_max        = 0;
                        var index           = -1;

                        var time            = this.path_time_tot; //update_value * this.path_duration;

                        // find correct keyframes based on time
                        for (var i = 1; i < this.into_path.length - 1; i++)
                        {
                            var t = this.path_duration * this.into_path[i][2]; 

                            if ( t > time ) {

                                time_max    = t;
                                time_min    = this.path_duration * this.into_path[i-1][2];

                                if (time_min == time_max)
                                {
                                    console.log("gonna have a bad time: ", time_min, time_max, time, i);
                                    return true;
                                }

                                index       = i-1;

                                break;
                            }
                        }

                        if ( update_value >= 1 || index == -1 )
                        {
                            console.log("update_value: ", update_value, "index: ", index);
                            return true;
                        }

                        var rel_val         = ( time - time_min ) / ( time_max - time_min );
                        this.path_delta     = rel_val != Infinity ? rel_val : 1.0;

                        var p0_ix           = index - 1;
                        var p1_ix           = index;
                        var p2_ix           = index + 1;
                        var p3_ix           = index + 2;

                        var p0              = this.into_path[ p0_ix ][0];
                        var p1              = this.into_path[ p1_ix ][0];
                        var p2              = this.into_path[ p2_ix ][0];
                        var p3              = this.into_path[ p3_ix ][0];

                        var r0              = this.into_path[ p0_ix ][1];
                        var r1              = this.into_path[ p1_ix ][1];
                        var r2              = this.into_path[ p2_ix ][1];
                        var r3              = this.into_path[ p3_ix ][1];

                        this.orienting      = true;
                        this.moving         = true;
                        
                        this.position       = this.CatmullRom( this.path_delta, p0,p1,p2,p3 );
                        var path_quat       = this.CatmullRomQuat( this.path_delta, r0,r1,r2,r3 );
                        quat4.normalize(path_quat);


                        var end_time    = this.path_duration;//this.cool_list[ this.into_path_waypoints.length-2 ];
                        var blend_factor = this.Tween(this.path_time_tot / this.path_duration * 1.0);
                        blend_factor     = blend_factor == Infinity ? 1 : blend_factor;

                        if (blend_factor >= 1)
                            console.log("done with blend....");

                        var wp          = this.into_path_waypoints;
                        var wp_pos      = this.CatmullRom( this.path_delta, wp[index-1][0],wp[index][0],wp[index+1][0],wp[index+2][0] );

                        // var t_q0 = quat4.create(wp[index-1][1]);
                        // var t_q1 = quat4.create(wp[index][1]);
                        // if (quat4.dot(t_q0, t_q1) < 0)
                        // {
                        //     quat4.scale(t_q0, -1.0, t_q0);
                        // }

                        // var wp_quat = quat4.create();
                        // quat4.slerp(t_q0, t_q1, this.path_delta, wp_quat);

                        var wp_quat     = this.CatmullRomQuat( this.path_delta, wp[index-1][1],wp[index][1],wp[index+1][1],wp[index+2][1] );
                        quat4.normalize(wp_quat);


                        var p0          = vec3.create(this.position);
                        var p1          = wp_pos;
                        var i_p         = vec3.create([
                                blend_factor * p0[0] + (1 - blend_factor) * p1[0],
                                blend_factor * p0[1] + (1 - blend_factor) * p1[1],
                                blend_factor * p0[2] + (1 - blend_factor) * p1[2],
                            ]);

                        var i_q = quat4.create();

                        if (quat4.dot(wp_quat, this.into_path[0][1]) < 0)
                        {
                            quat4.scale(wp_quat, -1.0, wp_quat);
                        }
                        quat4.slerp(wp_quat, path_quat, blend_factor, i_q);
                        quat4.normalize(i_q);

                        this.position   = i_p;
                        this.transform = mat4.fromRotationTranslation(i_q, i_p);

                        

                    } // end of __calc function

                    var old_path_time = this.path_time;
                    var old_path_time_tot = this.path_time_tot;

                    // always run once
                    if ( __calc.apply( this, [ dt ] ) )
                        this.SetState( this.STATE_ROAM );

                    this.SetYawPitch();

                }   

            } break;
        case this.STATE_CYCLE_PATH:
        {
            if (!this.cycle_path) this.SetState( this.STATE_ROAM );
            else {
                if ( this.is_new_state ) { 
                  this.path_cycle_time_tot  = 0;
                }

                var last_keyframe       = this.cycle_path[this.cycle_path.length-1][2];
                var duration_sec        = last_keyframe / this.framerate; 

                var relative_path_pos   = this.path_cycle_time_tot / duration_sec;
                var this_keyframe_float = this.path_cycle_time_tot * this.framerate;
                var this_keyframe       = Math.max( 0, Math.min( Math.floor( this_keyframe_float ), last_keyframe ));
                var this_keyframe_fract = this_keyframe_float - this_keyframe;
                var next_keyframe       = this_keyframe + 1;

                this.path_cycle_time_tot  += dt;

                var path_length     = this.cycle_path.length;

                this.orienting  = true;
                this.moving     = true;

                var p0_ix = (this_keyframe - 1) % path_length; p0_ix < 0 ? p0_ix = path_length-1 : p0_ix;
                var p1_ix = this_keyframe;
                var p2_ix = (this_keyframe + 1) % path_length;
                var p3_ix = (this_keyframe + 2) % path_length;

                var p0    = this.cycle_path[ p0_ix ][0];
                var p1    = this.cycle_path[ p1_ix ][0];
                var p2    = this.cycle_path[ p2_ix ][0];
                var p3    = this.cycle_path[ p3_ix ][0];

                var r0    = this.cycle_path[ p0_ix ][1];
                var r1    = this.cycle_path[ p1_ix ][1];
                var r2    = this.cycle_path[ p2_ix ][1];
                var r3    = this.cycle_path[ p3_ix ][1];

                this.position   = vec3.create([this_keyframe_fract * p2[0] + (1.0 - this_keyframe_fract) * p1[0],
                                               this_keyframe_fract * p2[1] + (1.0 - this_keyframe_fract) * p1[1],
                                               this_keyframe_fract * p2[2] + (1.0 - this_keyframe_fract) * p1[2]]);

                var rotmat      = mat4.identity();
                var transmat    = mat4.identity();

                this.Identity();

                var cur_squat = quat4.create(r2); //quat4.identity();

                if ( quat4.dot( r1, cur_squat ) < 0)
                {
                    quat4.scale(cur_squat, -1.0, cur_squat);
                }

                quat4.slerp(r1, cur_squat, this_keyframe_fract, cur_squat);
                quat4.normalize(cur_squat);

                mat4.fromRotationTranslation( cur_squat, this.position, this.transform );

                this.SetYawPitch();

                if ( relative_path_pos >= 1 ) {
                    this.path_cycle_time_tot = 1 - relative_path_pos;
                }
            }
        } break;
    }

    this.is_new_state = false;

    this.SetInternals();

    PXF.Object.prototype.Update.call(this, dt);
};

PXF.RoamCamera.prototype.ApplyLookat = function( lookat_vec )
{
    vec3.add( this.lookat_vec, lookat_vec );
    this.SetState( this.STATE_LOOKAT );
};

PXF.RoamCamera.prototype.ApplyOrbit = function( orbit_vec )
{
    this.orient_vel[0] += orbit_vec[0] * this.orient_multiplier;
    this.orient_vel[1] += orbit_vec[1] * this.orient_multiplier;

    this.SetState( this.STATE_LOOKAT );
};

PXF.RoamCamera.prototype.ApplyZoom = function( zoom_val )
{
    this.zoom_vel += zoom_val * this.move_multiplier;
    this.SetState( this.STATE_LOOKAT );
};

PXF.RoamCamera.prototype.ApplyMove = function( move_vec )
{
    //camera_move = true;
    var rotmat = mat4.identity();
    mat4.rotate( rotmat,    this.yaw, [0.0, 1.0, 0.0]);
    ( !this.restrict_orientation ) && mat4.rotate( rotmat, -this.pitch, [1.0, 0.0, 0.0]);

    // rotate move direction vector
    vec3.multiply( move_vec, [this.move_multiplier, this.move_multiplier, this.move_multiplier] );
    mat4.multiplyVec3( rotmat, move_vec );

    // TODO clamp velocity
    vec3.add(this.move_vel, move_vec);

    this.SetState( this.STATE_ROAM );
};

PXF.RoamCamera.prototype.ApplyOrientation = function( orient_vec )
{
    var t_yaw   = orient_vec[0] * this.orient_multiplier;
    var t_pitch = orient_vec[1] * this.orient_multiplier;

    this.orient_vel[0] -= t_yaw;
    this.orient_vel[1] += t_pitch;

    // TODO do clamp on velocity instead
    this.orient_vel[0] = Math.max( Math.min(this.orient_vel[0], this.max_yaw),   this.min_yaw );
    this.orient_vel[1] = Math.max( Math.min(this.orient_vel[1], this.max_pitch), this.min_pitch );

    this.SetState( this.STATE_ROAM );
};

PXF.RoamCamera.prototype.Clone = function( other )
{
    this.move_multiplier    = other.move_multiplier; 
    this.move_vel           = vec3.create(other.move_vel); 
    this.move_inertia       = vec3.create(other.move_inertia); 
    this.position           = vec3.create(other.position); 
    this.orient_multiplier  = other.orient_multiplier; 
    this.orient_vel         = vec3.create(other.orient_vel); 
    this.orient_inertia     = vec3.create(other.orient_inertia); 
    this.yaw                = other.yaw; 
    this.pitch              = other.pitch; 
    this.auto_cycle         = other.auto_cycle; 
    this.into_path          = other.into_path; 
    this.cycle_path         = other.cycle_path; 
    this.scale_fact         = other.scale_fact; 
    this.state              = other.state; 
    this.into_index         = other.into_index; 
    this.cycle_index        = other.cycle_index; 
    this.path_step_time     = other.path_step_time; 
    this.framerate          = other.framerate; 
    this.keyframes          = other.keyframes; 
    this.last_delta         = other.last_delta; 
    this.path_delta         = other.path_delta; 
    this.path_duration      = other.path_duration; 
    this.max_yaw            = other.max_yaw; 
    this.min_yaw            = other.min_yaw; 
    this.max_pitch          = other.max_pitch; 
    this.min_pitch          = other.min_pitch; 
}


/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/TrackballCamera.js: */

// DEPENDENCIES: /scene/CameraObject.js

PXF.TrackballCamera = function(ctx, scene, json, parent )
{
	if(!ctx) return;

	extend( this, extend({ ctx : ctx}, PXF.TrackballCamera.defaultParameters));

	PXF.RoamCamera.apply( this, arguments );

	this.SetState(this.STATE_LOOKAT);
};

PXF.TrackballCamera.defaultParameters = {
    lastwheel       : 0
};

// trackball_camera.yaw += PXF._inputState.mouseDelta[0];
// trackball_camera.pitch += PXF._inputState.mouseDelta[1];

PXF.TrackballCamera.prototype = new PXF.RoamCamera();
PXF.TrackballCamera.prototype.constructor = PXF.TrackballCamera;


PXF.TrackballCamera.prototype.Update = function(dt) {

	var gestures = this.ctx.GetGestures();

	if ( gestures.release )
	{
		this.lastDeltaX = undefined;
		this.lastDeltaY = undefined;
		this.lastScale  = undefined;
	}

	if ( gestures.touch )
	{
		this.lastDeltaX = undefined;
		this.lastDeltaY = undefined;
		this.lastScale  = undefined;
	};

	if ( gestures.drag )
	{
		if ( !this.lastDeltaX ) this.lastDeltaX = gestures.drag.deltaX;
		if ( !this.lastDeltaY ) this.lastDeltaY = gestures.drag.deltaY;

		var deltaX = gestures.drag.deltaX;
		var deltaY = gestures.drag.deltaY;
		var dx     = (deltaX - this.lastDeltaX) * dt;
		var dy     = (deltaY - this.lastDeltaY) * dt;

		this.lastDeltaY = deltaY;
		this.lastDeltaX = deltaX;

	    this.ApplyOrbit( [dx,dy] );
	};

	if ( this.lastwheel != this.ctx._inputState.mouseWheelDelta )
	{
		var dir        = (this.ctx._inputState.mouseWheelDelta - this.lastwheel)/120;
		var zoomval    = dir * dt;
        this.lastwheel = 0;
        this.ApplyZoom( -zoomval );
	};

	if ( gestures.pinch )
	{
		if ( !this.lastScale ) this.lastScale = gestures.pinch.scale;

		var zoomval = (gestures.pinch.scale - this.lastScale) * dt;

		this.ApplyZoom( -zoomval );
	};

	PXF.RoamCamera.prototype.Update.apply( this, [dt] );

    // this.position = vec3.create(this.worldposition);
    // this.SetInternals();
}



/* SOURCE C:\Users\dev\Documents\dev\code\pxf.js\src/extra/GestureRoamCamera.js: */

// DEPENDENCIES: /extra/RoamCamera.js

PXF.GestureRoamCamera = function(ctx, scene, json, parent )
{
	if(!ctx) return;

	extend( this, extend({ ctx : ctx}, PXF.GestureRoamCamera.defaultParameters));

	PXF.RoamCamera.apply( this, arguments );
};

PXF.GestureRoamCamera.defaultParameters = {
	dragMultiplier      : 5,
	transformMultiplier : 1,
	zoomMultiplier      : 20,
	zoomFovMax          : 100
};

PXF.GestureRoamCamera.prototype = new PXF.RoamCamera();
PXF.GestureRoamCamera.prototype.constructor = PXF.GestureRoamCamera;


PXF.GestureRoamCamera.prototype.Update = function(dt) {

	var numTouches = dictLength( this.ctx._inputState.touches );
	var doTransform = true;

	var gestures = this.ctx.GetGestures();

	if ( gestures.touch )
	{
		this.lastDeltaX = undefined;
		this.lastDeltaY = undefined;
		this.lastScale = undefined;
	};

	if ( gestures.drag )
	{
		if ( !this.lastDeltaX ) this.lastDeltaX = gestures.drag.deltaX;
		if ( !this.lastDeltaY ) this.lastDeltaY = gestures.drag.deltaY;

		var deltaX = gestures.drag.deltaX;
		var deltaY = gestures.drag.deltaY;
		var dx     = (deltaX - this.lastDeltaX) * dt * this.dragMultiplier;
		var dy     = (deltaY - this.lastDeltaY) * dt * this.dragMultiplier;

        this.lastDeltaY = deltaY;
        this.lastDeltaX = deltaX;

        this.ApplyOrientation( [ -dx,-dy ] );
	};

	if ( gestures.pinch )
	{
		if ( !this.lastScale ) this.lastScale = gestures.pinch.scale;

		var ds = (gestures.pinch.scale - this.lastScale) * dt * this.zoomMultiplier;

		this.ApplyMove( [0,0,-ds] );
		this.lastScale = gestures.pinch.scale;
	} 

	/* 
	if ( PXF.Gesture.transform ){
		if ( !this.lastDeltaX ) this.lastDeltaX = PXF.Gesture.transform.deltaX;
		if ( !this.lastDeltaY ) this.lastDeltaY = PXF.Gesture.transform.deltaY;

        var oldyaw = this.yaw;
        var oldpitch = this.pitch;
		var dir    = PXF.Gesture.transform.direction;
		var deltaX = PXF.Gesture.transform.deltaX;
		var deltaY = PXF.Gesture.transform.deltaY;
		var dx     = (deltaX - this.lastDeltaX) * dt * this.transformMultiplier;
		var dy     = (deltaY - this.lastDeltaY) * dt * this.transformMultiplier;

		this.pitch = 0;

		if ( numTouches >= 3  )
			 this.ApplyMove( [0,dy,0] );
		else this.ApplyMove( [ -dx,0,-dy ] );

		this.lastDeltaY = deltaY;
        this.lastDeltaX = deltaX;
		this.pitch = oldpitch;
	}; 
	*/

	if ( gestures.release )
	{

	};

	PXF.RoamCamera.prototype.Update.apply( this, [dt] );
}


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/template/templatemanager.js: */

// DEPENDENCIES: /porcupine.js

porcupine.templates = porcupine.templates || {};
porcupine.templates.get = function( templates, onsuccess )
{
	var templatesloaded = {};

	for ( var t in templates )
	{
		templatesloaded[templates[t]] = false;

		(function()
		{
			var _t_id = t;
			var _t    = templates;

			load_external_script( templates[t], function( id )
			{
				// mark as finished
				this[id] = true;

				var _allloaded = true;

				// check if every template has been loaded
				for ( var _tk in this ) 
				{
					if (!this[_tk])
						_allloaded = false;
				};

				if ( _allloaded ) onsuccess();

			}.bind( templatesloaded, _t[_t_id] ) );
		})();
	}
};


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/screen/screenmanager.js: */

// DEPENDENCIES: /porcupine.js

porcupine.screenmanager = function( instance, config ) {
	extend(this, {speed_forward : 1.3, speed_backward : 1.3 });
	extend(this,config);

	this.instance      = instance;
	this.screen_stack  = [];
	this.screen_change = 0;

	this.resize        = function(w,h) {
		for( var s in this.screen_stack )
		{
			var screen = this.screen_stack[s];
			screen.resize(this.instance, w,h);
		}
	};

	this.render        = function()	{
		var visibility_top,visibility_bot;

		// calculate visibility
		if ( this.screen_change < 0 )
		{
			visibility_bot = 1 + this.screen_change;
			visibility_top = -this.screen_change;
		} else if ( this.screen_change > 0 )
		{
			visibility_bot = this.screen_change;
			visibility_top = 1 - this.screen_change;
		};

		// draw current stack
		for ( var s in this.screen_stack )
		{
			var screen = this.screen_stack[s];

			if ( !screen.visible ) continue;

			if ( screen.propagate )
			{
				if ( visibility_top && visibility_bot )
					 screen.draw( this.instance, visibility_top );
				else screen.draw( this.instance, 1.0 );

				continue;
			} else {
				if ( visibility_top && visibility_bot ) {
					var screen_top = screen;
					var screen_bot = this.screen_stack[s+1];

					screen_top && screen_top.draw( this.instance, visibility_top );
					screen_bot && screen_bot.draw( this.instance, visibility_bot );
				} else screen.draw( this.instance, 1.0 );

				break;
			}
		}
	};

	this.update        = function( dt ) { 
		var visibility_top, visibility_bot;
		
		if ( this.screen_change > 0 )
		{
			this.screen_change -= this.speed_forward * dt;

			if ( this.screen_change <= 0)
				this.screen_change = 0;
		} else if ( this.screen_change < 0 ) {
			this.screen_change += this.speed_backward * dt;

			if ( this.screen_change >= 0 ) {
				this.screen_change = 0;

				var screen = this.instance.pop_screen();

				if ( this.screen_stack.length == 1 )
				{
					this.instance.set_state(this.instance.STATE.STOPPED);
				};
			};
		};

		// calculate visibility
		if ( this.screen_change < 0 )
		{
			visibility_bot = 1 + this.screen_change;
			visibility_top = -this.screen_change;
		} else if ( this.screen_change > 0 )
		{
			visibility_bot = this.screen_change;
			visibility_top = 1 - this.screen_change;
		};

		// update stack
		for ( var s in this.screen_stack )
		{
			var screen = this.screen_stack[s];

			// propagate updates until a non-propagating object is found
			if ( screen.propagate )
			{
				if ( visibility_top && visibility_bot )
					 screen.update( this.instance, dt, visibility_top );
				else screen.update( this.instance, dt, 1.0 );

				continue;

			} else {
				if ( visibility_top && visibility_bot )
				{
					var screen_top = screen;
					var screen_bot = this.screen_stack[s+1];

					screen_top&&screen_top.update( this.instance, dt, visibility_top );
					screen_bot&&screen_bot.update( this.instance, dt, visibility_bot );
				} else screen.update( this.instance, dt, 1.0 );

				break;
			};
		};
	};
};

porcupine.instance.prototype.empty_screen = function( config ) {
	return extend({
		init      : function() {},
		update    : function() {},
		draw      : function() {},
		resize    : function() {},
		show      : function() { this.visible = true; },
		hide      : function() { this.visible = false; },
		toggle    : function() { this.visible = !this.visible; },
		visible   : true,
		propagate : false
	},config);
};

porcupine.instance.prototype.peek_screen = function(id) {
	return this.screenmanager.screen_stack[id || 0];
}

porcupine.instance.prototype.push_screen = function(screen) {
	screen.instance = this;

	this.screenmanager.screen_stack.unshift( screen );

	if ( screen.init ) screen.init( this );
	this.screenmanager.screen_change = 1.0;

	return screen;
};

porcupine.instance.prototype.pop_screen = function() {
	if ( this.screenmanager.screen_change > 0 )
		 this.screenmanager.screen_change = -( 1.0 - this.screenmanager.screen_change );
	else this.screenmanager.screen_change = -1.0;

	var screen = this.screen_stack.shift();

	return screen;
};


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/screen/screenboot.js: */

// DEPENDENCIES: /porcupine.js, /screen/screenmanager.js

porcupine.instance.prototype.bootscreen = function()
{
	var screen = this.empty_screen();

	screen.init = function( instance ) 
	{
		instance.log("Booting up Porcupine Engine {0}".format( porcupine.version ));

	};

	return screen;	
}


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/core/resources.js: */

// DEPENDENCIES: /lib/pxf.js

// built in resources with porcupine.js
porcupine.static_resources = {};
porcupine.static_resources.bitmap_font_tex = { loader : PXF.Texture,
	                                           args : [ "iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAF1dJREFUeNrsXeFu5igMbKK8/xNX+u5P02MpSbBnwBBmpGpve+tAjDGGMPb2+Xy+BEFYE7tUIAhyAIIgyAEIgrASjqYPP47fA4bv7++tt/wQCj6Oz2x9T/WeYtYxiLJfdj9a9GFrdQj4Y/jp300vgMqnkw+ZhARZV9+jHEiu9+z/fc3szHrbH3Him/uQ2/6VHe0tjeg4jt+fn79/vEZokc/68LHKlp6BTKSI9oX/9Xf+WO3Pa7/svh/H4babpznQ9AwgnQBOJfzzp3fyIQ4EmcCslRhxIKs7D6vtjNh/6/z5WfFz2//qFgGgE5jlQJhhsGcSMhwYGgEhzutc/WZf/a3vkE6g9BkR2x8kAkhtLyQCQCdvGoLNanynDhTK99d/Fr6bJvDpBKLPPpAIoOb8YO/xAojzSCeSRwGeQxxUnuA0t9TxJYa8eZ7h7bdH929zIhFbwLuDWKsDTJ1I6R1W+ArgngSIfHqCm3jj4U+h3/IVIA+De48/s++pUzc+4/ErwNaSCzDCPQD0M1qkfMR36Dd9BmR8P4+6x9Hy2383ByDMG/5ebSuknXdBDkAQFoa4AIIgByAIghyAIAhyAIIgyAEIgrCyA2DdfkKew5AF7sJ/0h9EPmqA0baj5VcHy3avnrPfPYBxBTKajut9Rk4lRcg4UTwAdAyj5Wd3QIwFiGW7bjIQwwBQ2ai72CibbwQ+uVd/0XToURwQo+8jE8GqzgBQA2I4jpnYdDmd9HQikdd5eydkYYa+DPvzyEeH/l4HbCGz7YaHQgbkmUAIG441gQkD2Z1Rh+qPof/cVrzbJ4b9ARmBPozJO/ICthsN2U2n9e5hPAPInERRkx85gGToLx9rD5PR237ugFD7i1pA0u2jI58fFIHV5jPY2ZOfMYEYfPxkFd+i6ZzenIjeQ8RR8hmg48e0P4SR+ebUakeLyZ8Ngms7kMqCuQDSP3tOgNCssqj+RmgfzehMkC/Z1GZt29qHU+YpKmO8/y0bkDVpgtNyb1HPQPj8uQF4HSDqgKLzKUQewqETcAaIDvxivKGwiiAHIAhCI4gLIAhyAIIgyAEIgiAHIAiCHIAwOUTFFZ7soHVtwA9ynzraiJk0Vs91XrR9BhUX5aNr+sVP/js72Fs3jDC50HwAyCRO20b675mMjMKeI4zfyrkAtAUYxOsxuPDe2vJZH6ou41wUtgwrTY7ew/fqH3HArAgIjZyieQQ1tre/dfKfxmc1wlIyEA8TLXMCUXfxp7sByCqNHhUJWLLxKAKoMF60rLN1FctzAQBEptwJfKyyqfPwGNCM139L+vdQaVcvzV4bee4jG0KkEdeUVjZsA6qfcbUFWMWILaWt7xxIdDKZ/GdUZ3w0VsSn9yS+2wJY9uBZ+GlegdKVGyxRHraNCIwAPgUduOm0Edsvoi03LWvejAzEqM9OCn/c6azAXASbdyAvqLxheQU9+mOM/cyl3XuF8MM6gGwibUEK3KJyEbB0l65ovfuCjF/k2EdPQLYNt+y36MCCMODk7+U45AAEYbDoryfkAARhYYgMJAhyAIIgyAEIgiAHIAjCGri8CYjmpU+fgch62r+6NtrrHVjte2+zMdpn1CVAdS8AE7vSdopfAUqMrJ63wZD27yoR9XgHVvvewh6M9tHxZ9jPaJMp4CYreoOxSvfHk9H/eBDoPr238572C/fAaU7I8S6uFfhCB6aSVNnvuumfYT+jraLWviNVhXLiF3ITMB3/q/4fFQYFeR8rchKRlwbLjkCc73LpDCwTyPP+T9uBFVZehEzjXTyubKe2LwXbNTmC/Nr40/j/2QJcEVGsISSy+qLbCNYWwvPuF/vf6mfcGBBUH7BnCM94BwKL8uMlgnmjL0YEwJxDNTo4LCGsZxVn7GOcL//PBPSEoAVaMKXKq/UdeobQjBD+ahvmjOK6VgbOIlBzJIFGAEwnVOMAj68BUVKA5/zB48DQM4RS+DaCDqP23iP0wbuF8pwBoKW98z18awc43FeAEU6xRwyhZ/kKc7ONbEprZcszzyIi2qt9/0syUOQ9gBG+Y7PfIeI7etQ9jFy+dz6G2em8PR2J2IDCssYvyAEIwtIQF0AQ5AAEQZADEARBDkAQBDkAQRBejmb5ANh8/sj2e98FH+X9CzfivPfZIUJP7/6z6yGg7TNyUlzJNrkJ2ILPH9l+TyLMSO+fcgGQPvQkg6H9Z1dEsj6PoX/L+O9XwoXihqbilmejYJ14szy7fa9s2j5SF9Aqz3z/NyCKi5AWde0a0hvHf396id4v0GAgNnQSohMINTzCvfAlr8VGE5HQudNj7h2zKAAZxAGYcK5rqah8QYduOnTPFYw5ZlGTPy8NP6oT2Ft2Ig1BUHlkBT6O4xMR/qIrL2PlZum/Z/jK3K5Ebn1Q3fXQ/V67B528UKLbEFhlrqPC/5URvXgwxq61Ezgu9sxwVhP2FqJ2Aqb9R7cQ6ORHwm/wzIPy/kHnNdS+nyE4mhFqFnahVYfV+QAsHo31HRbxpm+4B8D4fs5ov/c9AJb+I+zvFfcABEFYA7oKLAhyAIIgyAEIgiAHIAiCHIAgCC/HIRUIrzVuoLw66xPs6HcHLunA+e9WzgdgfQabj26RH+E7dIvv8M5JnP7dRKVlUJgt7bZwRK4IgF3bzCo/avu1z7io7NpFPpctVZoduf8M/Rdkuq7EpdqCwORv7gSquADny6yQDyClD+f9mO1e/oz8/1T/LDKSo6BrKP07i0KajuMSh4DWCVz6dzOScoCqvL/yVj4EKn8+4/y3MxYXJU7+rbUT2Ec3YIYBzpTUhDGBmH3wtI3KlyK5ziS0rcfq+9D2Vvp7VwcQZYD5/g1Z9VdPiYWsQqkd9NTdKKXNIxeBXtFndT6AqEHwngHMnMrMu4Lm0YMnhI7OKVhKihmR0CUyCug6v9gHGtF89NXbz53n5I6w5By8n+a2jnoPdRiWz6i39wCIlyHMq1Dafks+tKUfyCD0bD+Vi8irz+o/shixvsdb7wUw7wEwtm+FBWF7dACtPJLSWwlRKyG6mHkXn6CEpFgEIAjCGhAZSBDkAARBkAMQBEEOQBAEOQBBEFZ1AJGXGaJKeY3Wl8CSZpR20ed45Rn9H8kGuzuAlIscYXzs+nAz9iWqbVa76HO88oz+j2SDzce79Mv0Oity/TJ9HmhI3dtnrCDe9hlkGMZNRET/3luILPlcD70u5NzZjTcjUkv7P54GgJQWqWt5bLT9u+uUrdu/YuKh/feMAVKe3JqJiC3PeAd03D3OlDF2Fvt7ogN7lb4xmGQe+RKbDJVHVm9r+yiXHu0/qv+RMAqV3avHHvZ/RHjCiIGIuJM9MxPvNXvcBfMJWLC3nPyta5vXTsLAA81p8wm+BUoE09kBlJJS9AzhSu2j8sj7944CmPp/w+q/mhOw2n8zNiAzL/8IXwEQTnvvXASZvNkJovkEGO+AfAlh9J+di8Fb24GRU+FOdio6cL6h0A677gxmti3I6jkBe2IKB8A4Sfhe0AkgEcgo/W/Z90MLyfgO4AAnswZZuLONb+lgvo5ZO63JLwiTOQBNYEF4uQM4OnZSTkQQ/iI0H8B34WfpUEfgj/vD9/8DkP1qJLuMA6h1Ck8/LY1Ht8jmnvwoHbm37EgOcBp8NzSe5L/1LXrOyf/4KZH9NYBBp2c7wKs+HDVeo/dNupLXQqvLRJSGiqjMU/q31j6glYFY8qgN1Cwcb90apgvYnRM47gSz33Xho18xCRFOPSpv8eSFyMH9/oXrvLfPKMla5NH22fKIDbzl7CJ1oh77PetDXtnwY3XgdAJ4GicownyPPa9uG1HfHgwff/WOXIllkpk6F1f9pzKxtX1rPb8We2GkunCeksx7pnC+/9083Af3gl/f39+bd/LOXiYcnbzZ6utiRCKyXgdy/juv87FOvpZnSN6ELsnC9eV5Tu0h4GvTgkfUtm8xkXtHIHdboIj2Tz2sRuc9Fz4kn8TpPG7TlNWEkI4V4BO1+l7s/z3h85aHYjXPKL1/wBbCzQa8Sinl1QHSfr6NWeUMIH1HNKHq1XNP/CEDXRgAwgV3GYG33dJqEZFVlsHGY3Dxkb4jp/iI82N9BagNw0uEMW8Ij8r2xqMDIKT0DgljhfAtWNd03A82+Pz1pXAWgEQcs0QrRTowc/BGMQRBECodgCAIi0RqUoEwmhGKuSkHIMgoi5BzkAMQXoZvGajOAARBaLDCP3yNeOICfBBO/CkXVas9uv+z16mfXX8M+4tMCsLQ39Mtzv1J2FtaK+Mid6/VHt3/EerUIxN4dv0x7C8yKQhLf0+ciMt7AKfw7z7Nyq4iVzdB5aOrC0Xc5kOLg0h//0ygbtWFmO//1PfHMxYCH9mVWadkwOAEaFZjfTT5GweO6H8q/eULl0NuS0Jw9yRGswJ5+1+LIdmA1hrnNwO4rHz6nJRh1kP/0fJMRNHJa0N4VP6oeRDDk/UegLvMMivIs8aPVeF5tgk4Clrr77gLf0YoMJmFse6USEgEMps8c/w8+h9JfkagWziL/P4UgnqMx1qj/EneOQHcHnR2efb4ofrvLX+1D59RHnV6T/KXF4EYVN6RToE9z5hZ/m3jF5FTIVI+X62dh6iP8rc3AUXlnT+U1PgJrghAEIT3Y5cKBEEOQBAEOQBBEOQABEGQAxDWBovOLUzuAKI46SmddbZ8AMxcABHts+i0iAMZwQEh+r/7e88558oHkBtCVHkoLyc9ks/OzgUQ0f7Pcx6LS7ZyIMx8Egwb9Og/dWAeMhRjzj21fXsTMP+dp8a95xklLra1/bwPUdV1GG1bn8MYu5RHjhS6RPWH5pNgVPf5aRupUNxN1vqc407w4vemGvfeZ7AiCG+7DD4+o+2UDFTzHER2FP2z80kwmKxOJ9Kcz4/2v2YL8GWtUJpz2c/npINR+ZzfP2fho4/EZY/cN0fqIC+x7S3Rndqed+vgsd/U/tF8AOk8cp0BMBTw1Ik755M6Id1pj5nMq71zzqS0ruD5Aui13zSC8yaUeYpejtpJSAhfXftRIWwCfGZNxnGRDwHaAnj4+Pni5+mD9xyg1llURwC1HuiKy47wuq0hFDsfgUUebXuE9vNVzLsCRujfugLWHJ558xlERbAW5z3kV4DUW45yEt+77ej235BVGFn5GfbHaB+IHKq+gIgOLDSdgELs+LkzAgmC8H6ICyAIcgCCIMgBCIIgByAIghyAIAirOwAGr3xW+Wg+OyOfAUN/Mxo2g0Y7Qj/QcX8a//3pQYwa7TPKR/PZWfkMGPqbzQmU+Pg95SP1V8qj4coHkL94RGUV1k046zNQPjaTz/3T7/PvX9a76DkfA61Q00v/pd97y6MjfHyPPEN/uayVCl2ru6PGiLwvUipSaJX1tI9y4tHa8AkZZUNXj1FWUiSXgmUM2bkkkMmbyvfUXyl6sDzHNFY1kyANI3on80gJGbMlE/GW5karA7fQgfMZZsO8cpqWvuRsQKv+C1mQ4NUcWThRJ+Y6BCxx+ldDwuJy7eMYlX1Z1YW9IXCaFsz7LuePRwZNheUZw6uUdF4H6uXy54tAi7OEx5RgUSvQWxwI6ATQ6sJuWVYoy0C6pfJswawraIEF+BX9zq10v7dYgS72Ua5sJlF8cqYTQCad5yQfzaicrkCJvFn/TH0D5zBuGyyltvPYsFcXqUwr263+CuDtRNRXAFSexMeGvDeif+bYtTTAHvtpYhTU9StAD4gOLAgLQ1eBBUEOQBAEOQBBEOQABEGQAxAEQQ5AEITlHEBOhfRQKr3yaNulZ80mz3j3SETnUnhL/1u//37VaM5ld96lNsujbV89y6t8Lxf//InIJcAwfiSZyAi5FN7S/9bjf0cH/vOnhYueceE9pZ3+/Dn6rar0/WdFqf9IaXT1f2z7OSwTuHLibjfPeByIO/ne4Z8HIxBJkGvAaP8R5iADq/ffOv7HXQfyKMAY/rgigFJd896TH2lvRPmeK2DOJI1cQRmJaBB57+TtOf53CUHoK7jREL8YabWiVxCvPEoj9kZO0f1njV8UDXs0+Sc96AzgQonIVgCVj8bs/We9/+zyNeO3s0PwlEteigBq5b1bEEEQ6rHfTOA/f65wBiAIK6FJPoAsHdPmSarJCo3QbUOUvFd3LPnZ+896/9nx9P5KCCII2gIIgiAHIAiCHIAgCHIAgiDIAayJ9EsEWp5b2hSmdQCj85lbtJ/SMBnlvSPyGazOx1f7dfbzWBiEUBo5siqPu31CWS5KYY6sSGRYeXPrO7DLs1vlS79fsf0ned2xvRmAwu+2HvIFw4GfgcDaPrs8uKV9dnnx3u23eP87+cM4KdweEJX3rqLW9kt0Ukt5clT+4pnd3v+qbWcUZB6/nM1mbf+Oz9/j/dH2U/kCs4/e/tHDA87kwUcE2n+vPCOKSZ/RewXN6dAT9v/Tuv3D4k16e8CaPUzLFRQlIbFITL3f/2oMe7TPsp9s4izTf3oEgJY1dk6crXCY0Z1jjZZIJ5dY7/r+7EjJmtSiQRS1rdJ/y7/VPQBBWBj6CvBwCJNGIp5DHKu8IPTE8HTgaD7/rO8fzYefvf1V9Kd8AIKwMHQGIAg6AxCEaYGGsEufyygCEAQ5AEEQ5ACEcfZmhHwEguB2AKvXp4+cfKx8BCO8/4rOCylNznhWXh79Tr74GZDBJy/9vtf3VLT/ped4+++9zozkE2COH/L+nfJBDHUIWLrHD3AQzM96IAN9uenA3k4X/t8ybDwPm+tKh710h7I5hcmiFaNhdOFjR+YDuPKcSPsW+Rb5BEYZP3QLIefTwQHc1eaLyojincSe/jMjgIgVNDofA7M0uDeCYjqdiC1sqAOI5vOX6ttH8dk9+RBaRBCePrP45N7xY06cnvqbfQtLyQfwBj4/a6BGe06P9tHxG5HPvxKUD2Dywcv3/ucqqEkgNN8CCGOGcZr8Qgs0pwOvXt99dj55tP4r2qffA2B+BSGcfzT9CqJ8AMLsEBsQgM4ABEFnAIIw7zZWKlAEIAiCHIAgCHIAgiDMfQYQ/R2c8Rlt9noA6Ceo6PdXPYZnNPsMiBjPBR02tD498g4z3uJDee2M92fZUKT+GQtISwe8Pz3Ak1nmVH5KY3Uq4E+JaU/71n6k13HBhA4U4wf0584KhOggdaCJE/0gY+ixP0T/qP6yfnxQG0b0dye71z7A2Qm3AeSGaCWjpMZrNWKm8hF5NCUYOHb/0MJ7pvbKJ7DVhhKbYfShu/4u3r+JA94ND3CV12akhOodvp0GlJJyLAOIyjMnkDclGDIB8/FHxwJcOBDn+ZX9+bHKJ4uPW38t7edobIj/TIBZ9sFoUgtmUgzA+D+oPJrbzlsePcsJ8UGc2Iz2l+uv5SK4P3lPjwecGaWUXD3lWREUI/8C4xwkcgy9Z0hZ9GAeg3wLgsiHRQB5mWuPB53xFDxdfTyrOCp/sYJGsQldK2geQSCrd2pL1ryGiP2lNu+0/Q3Jioxko8r7fNf/Jp8BWem0GVRK7wCi9xCIab0pOvDKIhEF8h0+X3yQMRiczhyKpvcAdAFD+hPGhvIBCMLCEBdAEOQABEGQAxAEQQ5AEAQ5AEEQ5ABi0KrA5CzvgTLRWH1f4fZnC/3Porv96QXQF0GokIy2EUomYxJHMPkYRlxLJ51hIlvtiMUEnEF3xXsAjIQcmSK7J3RgJYRgvINX9vxv4Cal6y574SbncklNGIxKRHe9MmJdFgdlXIVF2FjZFVCTPOMq8oURfCIq1FrbZWQ0YobRoP43Qj+aTqIbG4YXL7YuqrYApYw6Di4zxCbLwihXQhBmGNZrEpXYhN58BOkzPGOHsBHRMJi1/Wm9gtYufsNGSa0igNz7eldeb9tIBHH1vB7nBo1WIDQC2wL6voF1JSE6NsIGRJh8QzgARgiChLG5AlE2X+8QmGGArPaRLQDqMFEHEj1xzvZ76y78EJAVQnm9IHoIOdIhJmMPCDxjW5VVyKRUR/W/h0MZlg0YycdnGVEkF18QpXpqByAjEgQ5AEEQGkJcAEFYGP8NACF0N1/OgL5XAAAAAElFTkSuQmCC",
	                                                    { base64 : true,
	                                                      magFilter : 0x2600 // we dont have access to context at this point, have to use a "magic webgl number" from spec
	                                                    } ],
	                                         };
porcupine.static_resources.loadingbar_shader = { loader : PXF.Shader,
	                                             args : [
"attribute vec3 position;\n\
attribute vec2 uv0;\n\
uniform mat4 mtx;\n\
varying vec2 v_uv0;\n\
void main()\n\
{\n\
	v_uv0 = uv0;\n\
	gl_Position = mtx * vec4(position.xy, 0.0, 1.0);\n\
}",
"precision highp float;\n\
uniform float proc;\n\
varying vec2 v_uv0;\n\
void main()\n\
{\n\
	if (v_uv0.s > proc)\n\
	{\n\
		gl_FragColor = vec4(0.20, 0.20, 0.20, 1.0);\n\
		// discard;\n\
		return;\n\
	}\n\
	gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);\n\
}",

	                                                    	false ],
	                                           };

porcupine.resource_loaders = {};

porcupine.add_resouce_loader = function( resource_type, resource_loader ) {

	porcupine.resource_loaders[resource_type] = resource_loader;

};

porcupine.instance.prototype.add_resource = function( resource_id, resource_raw ) {
	
	this.log( "Adding resource:", resource_id );
	this._unloaded_resources[resource_id] = resource_raw;

	return { get : (function() {
			return this.get_resource( resource_id );
		}).bind(this)};

};



porcupine.instance.prototype.load_resource = function( resource_id, progress_callback )
{
	// find unloaded resource -> a "raw" resource that haven't loaded yet
	// or are forcing a reload on
	var _resource_raw;
	if (this._unloaded_resources[resource_id])
	{
		_resource_raw = this._unloaded_resources[resource_id];
	} else if (porcupine.static_resources[resource_id])
	{
		_resource_raw = porcupine.static_resources[resource_id];
	}

	// console.log(_resource_raw);

	// find the resource loader function for this type of resource
	var _loader;
	if (typeof(porcupine.resource_loaders[_resource_raw.loader]) !== "undefined") {
		_loader = porcupine.resource_loaders[_resource_raw.loader];
	} else {
		_loader = _resource_raw.loader;
	}

	// call loader and return new resource
	this.resources[resource_id] = _loader(this, progress_callback, _resource_raw.args);
	this.log("Loaded:", resource_id);
	return this.resources[resource_id];
};


porcupine.instance.prototype.get_resource = function( resource_id, force ) {

	// if resource already has been loaded
	if (typeof(this.resources[resource_id]) !== "undefined" && !force)
		return this.resources[resource_id];


	return this.load_resource( resource_id, undefined );

}

// add often used resource loaders
porcupine._resource_texture_loader = function( instance, cb, args ) {
	return new PXF.Texture(instance.ctx, args[0], args[1], function() { cb(1.0); } );
};

porcupine._resource_texturecube_loader = function( instance, cb, args ) {
	return new PXF.TextureCube(instance.ctx, args[0], args[1], function() { cb(1.0) });
};

porcupine._resource_shader_loader = function( instance, cb, args ) {
	var shader = new PXF.Shader(instance.ctx, args[0], args[1], args[2]);
	if (cb)
		cb(1.0); // call progress callback
	return shader;
};

porcupine._resource_scene_loader = function( instance, cb, args ) {
	var _scene = PXF.LoadScene( instance.ctx, args[0], function () { 
		// nah man.. 
	}, function(item,progress) {
		
		cb( _scene.resourceProgress.getProgress() );  //) progress.getProgress() );

	}, args[1]  );

	return _scene
};

porcupine._resource_geometry_loader = function( instance, cb, args ) {
	var buffer = args[0];
	if ( typeof args[0] == "string" ) buffer = { type : "binary", url : args[0] };

	// TODO: add support for non-binary files
	return PXF.LoadBinaryGeometry( instance.ctx, buffer, function () { cb(1.0); } );
};

porcupine.add_resouce_loader( PXF.Texture, porcupine._resource_texture_loader );
porcupine.add_resouce_loader( PXF.TextureCube, porcupine._resource_texturecube_loader );
porcupine.add_resouce_loader( PXF.Shader, porcupine._resource_shader_loader );
porcupine.add_resouce_loader( PXF.Scene, porcupine._resource_scene_loader );
porcupine.add_resouce_loader( PXF.Geometry, porcupine._resource_geometry_loader );


/* SOURCE C:\Users\dev\Documents\dev\code\porcupine.js\engine/screen/screenpreload.js: */

// DEPENDENCIES: /porcupine.js, /screen/screenmanager.js

porcupine.instance.prototype.preloadscreen = function( resource_list, progress_callback )
{
	var screen = this.empty_screen();


	var default_preloadhandler = {
		resize : function(instance) {
			// simple loading bar with a single quad
			this.loading_bar.Reset();
			this.loading_bar.AddCentered(instance.settings.width/2.0, instance.settings.height/2.0 - 16, instance.settings.width*0.4, 3.0);
			this.loading_bar.End();
		},
		init : function( instance ) {
			var _this = this;

			// setup simple gui font
			this.loading_font      = new PXF.BitmapFont( instance.ctx, instance.get_resource('bitmap_font_tex'), 8, 16 );
			this.loading_bar       = new PXF.QuadBatch( instance.ctx );
			this.loading_barshader = instance.get_resource('loadingbar_shader');
			this.loading_label     = this.loading_font.AddLabel( function() { return (instance.settings.width/2.0); },
                                                         function() { return (instance.settings.height/2.0); },
                                                         function() { return (16*(1)); },
                                                         function() { return ("Loading: ".concat((_this.progress*100.0).toFixed(0), "%")); },
                                                         0 );
		},
		update : function(instance) {
			// simple loading bar with a single quad
			this.loading_bar.Reset();
			this.loading_bar.AddCentered(instance.settings.width/2.0, instance.settings.height/2.0 - 16, instance.settings.width*0.4, 3.0);
			this.loading_bar.End();
		},
		draw : function(instance)
		{
			var gl = instance.ctx.gl;

			gl.disable( gl.DEPTH_TEST );
	        gl.enable( gl.BLEND );
	        gl.blendFunc ( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	        gl.disable( gl.CULL_FACE );
	        gl.viewport( 0, 0, instance.settings.width, instance.settings.height );
	        gl.clearColor( 0.25,0.25,0.25,1);
	        gl.clear( gl.COLOR_BUFFER_BIT );
	        this.loading_label.recalc = true;

	        this.loading_barshader.Bind();
	        this.loading_barshader.SetUniform( "proc", this.progress );
	        this.loading_barshader.SetUniform( "mtx", mat4.ortho(0, instance.settings.width, 0, instance.settings.height, 0, 1.0) );
	        this.loading_bar.Draw( this.loading_barshader, { position: true, normal: false, uv0: true } );
	        this.loading_barshader.Unbind();

	        this.loading_font.Draw( mat4.ortho(0, instance.settings.width, instance.settings.height, 0, 0, 100) );
		}
	};


	screen.init = function( instance ) 
	{

		// this.resources_raw      = resource_list;
		this.resource_ids = [];
		// this.finished_resources = [];
		this.progress_callback  = progress_callback;
		this.progress = 0.0;
		this.total_resource_count    = 0;
		this.finished_resource_count = 0;
		this.frame = 0;


		// add all raw resources to instance
		// for (var i = 0; i < this.resources_raw.length; i++) {
		for (var k in resource_list) {
			instance.add_resource(k, resource_list[k]);
			this.resource_ids.push(k);
			this.total_resource_count += 1;
		};

		
		if(!this.handler)
			this.handler = default_preloadhandler;

		this.handler.init.call(this,instance);
		this.resize( instance );

		// if there are no resources to load from the beginning, notify that we are done
		if (this.total_resource_count == 0)
		{
			this.progress = 1.0;
			this.progress_callback(1.0);
		}

	};
	
	screen.update_resources = function(instance,dt,vis)
	{
		var _this = this;
		var _res_id = this.resource_ids.shift();
		if (_res_id !== undefined)
		{
			instance.load_resource( _res_id, function ( d ) {
				var _extra_progress = 0;

				if ( d >= 1.0 )
					_this.finished_resource_count += 1;
				else _extra_progress = (1/_this.total_resource_count) * d;

				_this.progress = ( _this.finished_resource_count + _extra_progress )/ _this.total_resource_count;
				_this.progress_callback(_this.progress);
			} );
		}
	}

	screen.resize = function( instance, w, h ) {
		this.handler.resize.apply( this, arguments );
	};


	screen.update = function( instance, dt, vis ) {
		this.update_resources.apply(this,arguments);
		this.handler.update.apply(this,arguments);
	};

	screen.draw = function( instance, vis ) {

		this.handler.draw.apply(this,arguments);

        this.frame += 1;
	};

	return screen;	
}